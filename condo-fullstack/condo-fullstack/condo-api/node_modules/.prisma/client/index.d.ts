
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AreaComum
 * 
 */
export type AreaComum = $Result.DefaultSelection<Prisma.$AreaComumPayload>
/**
 * Model Condominio
 * 
 */
export type Condominio = $Result.DefaultSelection<Prisma.$CondominioPayload>
/**
 * Model Bloco
 * 
 */
export type Bloco = $Result.DefaultSelection<Prisma.$BlocoPayload>
/**
 * Model Unidade
 * 
 */
export type Unidade = $Result.DefaultSelection<Prisma.$UnidadePayload>
/**
 * Model ConfigReserva
 * 
 */
export type ConfigReserva = $Result.DefaultSelection<Prisma.$ConfigReservaPayload>
/**
 * Model Cobranca
 * 
 */
export type Cobranca = $Result.DefaultSelection<Prisma.$CobrancaPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>
/**
 * Model LogAuditoria
 * 
 */
export type LogAuditoria = $Result.DefaultSelection<Prisma.$LogAuditoriaPayload>
/**
 * Model Reserva
 * 
 */
export type Reserva = $Result.DefaultSelection<Prisma.$ReservaPayload>
/**
 * Model VisitorLog
 * 
 */
export type VisitorLog = $Result.DefaultSelection<Prisma.$VisitorLogPayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model ShiftNote
 * 
 */
export type ShiftNote = $Result.DefaultSelection<Prisma.$ShiftNotePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Aviso
 * 
 */
export type Aviso = $Result.DefaultSelection<Prisma.$AvisoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SINDICO: 'SINDICO',
  ADMINISTRADORA: 'ADMINISTRADORA',
  MORADOR: 'MORADOR',
  PORTEIRO: 'PORTEIRO'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.areaComum`: Exposes CRUD operations for the **AreaComum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaComums
    * const areaComums = await prisma.areaComum.findMany()
    * ```
    */
  get areaComum(): Prisma.AreaComumDelegate<ExtArgs>;

  /**
   * `prisma.condominio`: Exposes CRUD operations for the **Condominio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Condominios
    * const condominios = await prisma.condominio.findMany()
    * ```
    */
  get condominio(): Prisma.CondominioDelegate<ExtArgs>;

  /**
   * `prisma.bloco`: Exposes CRUD operations for the **Bloco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocos
    * const blocos = await prisma.bloco.findMany()
    * ```
    */
  get bloco(): Prisma.BlocoDelegate<ExtArgs>;

  /**
   * `prisma.unidade`: Exposes CRUD operations for the **Unidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unidades
    * const unidades = await prisma.unidade.findMany()
    * ```
    */
  get unidade(): Prisma.UnidadeDelegate<ExtArgs>;

  /**
   * `prisma.configReserva`: Exposes CRUD operations for the **ConfigReserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigReservas
    * const configReservas = await prisma.configReserva.findMany()
    * ```
    */
  get configReserva(): Prisma.ConfigReservaDelegate<ExtArgs>;

  /**
   * `prisma.cobranca`: Exposes CRUD operations for the **Cobranca** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cobrancas
    * const cobrancas = await prisma.cobranca.findMany()
    * ```
    */
  get cobranca(): Prisma.CobrancaDelegate<ExtArgs>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs>;

  /**
   * `prisma.logAuditoria`: Exposes CRUD operations for the **LogAuditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogAuditorias
    * const logAuditorias = await prisma.logAuditoria.findMany()
    * ```
    */
  get logAuditoria(): Prisma.LogAuditoriaDelegate<ExtArgs>;

  /**
   * `prisma.reserva`: Exposes CRUD operations for the **Reserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservas
    * const reservas = await prisma.reserva.findMany()
    * ```
    */
  get reserva(): Prisma.ReservaDelegate<ExtArgs>;

  /**
   * `prisma.visitorLog`: Exposes CRUD operations for the **VisitorLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitorLogs
    * const visitorLogs = await prisma.visitorLog.findMany()
    * ```
    */
  get visitorLog(): Prisma.VisitorLogDelegate<ExtArgs>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs>;

  /**
   * `prisma.shiftNote`: Exposes CRUD operations for the **ShiftNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftNotes
    * const shiftNotes = await prisma.shiftNote.findMany()
    * ```
    */
  get shiftNote(): Prisma.ShiftNoteDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.aviso`: Exposes CRUD operations for the **Aviso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avisos
    * const avisos = await prisma.aviso.findMany()
    * ```
    */
  get aviso(): Prisma.AvisoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AreaComum: 'AreaComum',
    Condominio: 'Condominio',
    Bloco: 'Bloco',
    Unidade: 'Unidade',
    ConfigReserva: 'ConfigReserva',
    Cobranca: 'Cobranca',
    Pagamento: 'Pagamento',
    LogAuditoria: 'LogAuditoria',
    Reserva: 'Reserva',
    VisitorLog: 'VisitorLog',
    Delivery: 'Delivery',
    ShiftNote: 'ShiftNote',
    Notification: 'Notification',
    Aviso: 'Aviso'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "areaComum" | "condominio" | "bloco" | "unidade" | "configReserva" | "cobranca" | "pagamento" | "logAuditoria" | "reserva" | "visitorLog" | "delivery" | "shiftNote" | "notification" | "aviso"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AreaComum: {
        payload: Prisma.$AreaComumPayload<ExtArgs>
        fields: Prisma.AreaComumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaComumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaComumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>
          }
          findFirst: {
            args: Prisma.AreaComumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaComumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>
          }
          findMany: {
            args: Prisma.AreaComumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>[]
          }
          create: {
            args: Prisma.AreaComumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>
          }
          createMany: {
            args: Prisma.AreaComumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaComumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>[]
          }
          delete: {
            args: Prisma.AreaComumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>
          }
          update: {
            args: Prisma.AreaComumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>
          }
          deleteMany: {
            args: Prisma.AreaComumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaComumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AreaComumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaComumPayload>
          }
          aggregate: {
            args: Prisma.AreaComumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAreaComum>
          }
          groupBy: {
            args: Prisma.AreaComumGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaComumGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaComumCountArgs<ExtArgs>
            result: $Utils.Optional<AreaComumCountAggregateOutputType> | number
          }
        }
      }
      Condominio: {
        payload: Prisma.$CondominioPayload<ExtArgs>
        fields: Prisma.CondominioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CondominioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CondominioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>
          }
          findFirst: {
            args: Prisma.CondominioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CondominioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>
          }
          findMany: {
            args: Prisma.CondominioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>[]
          }
          create: {
            args: Prisma.CondominioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>
          }
          createMany: {
            args: Prisma.CondominioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CondominioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>[]
          }
          delete: {
            args: Prisma.CondominioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>
          }
          update: {
            args: Prisma.CondominioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>
          }
          deleteMany: {
            args: Prisma.CondominioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CondominioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CondominioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CondominioPayload>
          }
          aggregate: {
            args: Prisma.CondominioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCondominio>
          }
          groupBy: {
            args: Prisma.CondominioGroupByArgs<ExtArgs>
            result: $Utils.Optional<CondominioGroupByOutputType>[]
          }
          count: {
            args: Prisma.CondominioCountArgs<ExtArgs>
            result: $Utils.Optional<CondominioCountAggregateOutputType> | number
          }
        }
      }
      Bloco: {
        payload: Prisma.$BlocoPayload<ExtArgs>
        fields: Prisma.BlocoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlocoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlocoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>
          }
          findFirst: {
            args: Prisma.BlocoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlocoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>
          }
          findMany: {
            args: Prisma.BlocoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>[]
          }
          create: {
            args: Prisma.BlocoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>
          }
          createMany: {
            args: Prisma.BlocoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlocoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>[]
          }
          delete: {
            args: Prisma.BlocoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>
          }
          update: {
            args: Prisma.BlocoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>
          }
          deleteMany: {
            args: Prisma.BlocoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlocoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlocoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoPayload>
          }
          aggregate: {
            args: Prisma.BlocoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBloco>
          }
          groupBy: {
            args: Prisma.BlocoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlocoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlocoCountArgs<ExtArgs>
            result: $Utils.Optional<BlocoCountAggregateOutputType> | number
          }
        }
      }
      Unidade: {
        payload: Prisma.$UnidadePayload<ExtArgs>
        fields: Prisma.UnidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>
          }
          findFirst: {
            args: Prisma.UnidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>
          }
          findMany: {
            args: Prisma.UnidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>[]
          }
          create: {
            args: Prisma.UnidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>
          }
          createMany: {
            args: Prisma.UnidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>[]
          }
          delete: {
            args: Prisma.UnidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>
          }
          update: {
            args: Prisma.UnidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>
          }
          deleteMany: {
            args: Prisma.UnidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadePayload>
          }
          aggregate: {
            args: Prisma.UnidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnidade>
          }
          groupBy: {
            args: Prisma.UnidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnidadeCountArgs<ExtArgs>
            result: $Utils.Optional<UnidadeCountAggregateOutputType> | number
          }
        }
      }
      ConfigReserva: {
        payload: Prisma.$ConfigReservaPayload<ExtArgs>
        fields: Prisma.ConfigReservaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigReservaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigReservaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>
          }
          findFirst: {
            args: Prisma.ConfigReservaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigReservaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>
          }
          findMany: {
            args: Prisma.ConfigReservaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>[]
          }
          create: {
            args: Prisma.ConfigReservaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>
          }
          createMany: {
            args: Prisma.ConfigReservaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigReservaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>[]
          }
          delete: {
            args: Prisma.ConfigReservaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>
          }
          update: {
            args: Prisma.ConfigReservaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>
          }
          deleteMany: {
            args: Prisma.ConfigReservaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigReservaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigReservaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigReservaPayload>
          }
          aggregate: {
            args: Prisma.ConfigReservaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigReserva>
          }
          groupBy: {
            args: Prisma.ConfigReservaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigReservaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigReservaCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigReservaCountAggregateOutputType> | number
          }
        }
      }
      Cobranca: {
        payload: Prisma.$CobrancaPayload<ExtArgs>
        fields: Prisma.CobrancaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CobrancaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CobrancaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>
          }
          findFirst: {
            args: Prisma.CobrancaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CobrancaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>
          }
          findMany: {
            args: Prisma.CobrancaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>[]
          }
          create: {
            args: Prisma.CobrancaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>
          }
          createMany: {
            args: Prisma.CobrancaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CobrancaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>[]
          }
          delete: {
            args: Prisma.CobrancaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>
          }
          update: {
            args: Prisma.CobrancaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>
          }
          deleteMany: {
            args: Prisma.CobrancaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CobrancaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CobrancaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CobrancaPayload>
          }
          aggregate: {
            args: Prisma.CobrancaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCobranca>
          }
          groupBy: {
            args: Prisma.CobrancaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CobrancaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CobrancaCountArgs<ExtArgs>
            result: $Utils.Optional<CobrancaCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
      LogAuditoria: {
        payload: Prisma.$LogAuditoriaPayload<ExtArgs>
        fields: Prisma.LogAuditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogAuditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogAuditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          findFirst: {
            args: Prisma.LogAuditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogAuditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          findMany: {
            args: Prisma.LogAuditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>[]
          }
          create: {
            args: Prisma.LogAuditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          createMany: {
            args: Prisma.LogAuditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogAuditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>[]
          }
          delete: {
            args: Prisma.LogAuditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          update: {
            args: Prisma.LogAuditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          deleteMany: {
            args: Prisma.LogAuditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogAuditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogAuditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogAuditoriaPayload>
          }
          aggregate: {
            args: Prisma.LogAuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogAuditoria>
          }
          groupBy: {
            args: Prisma.LogAuditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogAuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogAuditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<LogAuditoriaCountAggregateOutputType> | number
          }
        }
      }
      Reserva: {
        payload: Prisma.$ReservaPayload<ExtArgs>
        fields: Prisma.ReservaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          findFirst: {
            args: Prisma.ReservaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          findMany: {
            args: Prisma.ReservaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          create: {
            args: Prisma.ReservaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          createMany: {
            args: Prisma.ReservaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          delete: {
            args: Prisma.ReservaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          update: {
            args: Prisma.ReservaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          deleteMany: {
            args: Prisma.ReservaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          aggregate: {
            args: Prisma.ReservaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReserva>
          }
          groupBy: {
            args: Prisma.ReservaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservaCountArgs<ExtArgs>
            result: $Utils.Optional<ReservaCountAggregateOutputType> | number
          }
        }
      }
      VisitorLog: {
        payload: Prisma.$VisitorLogPayload<ExtArgs>
        fields: Prisma.VisitorLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>
          }
          findFirst: {
            args: Prisma.VisitorLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>
          }
          findMany: {
            args: Prisma.VisitorLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>[]
          }
          create: {
            args: Prisma.VisitorLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>
          }
          createMany: {
            args: Prisma.VisitorLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitorLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>[]
          }
          delete: {
            args: Prisma.VisitorLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>
          }
          update: {
            args: Prisma.VisitorLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>
          }
          deleteMany: {
            args: Prisma.VisitorLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitorLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorLogPayload>
          }
          aggregate: {
            args: Prisma.VisitorLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitorLog>
          }
          groupBy: {
            args: Prisma.VisitorLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorLogCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorLogCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      ShiftNote: {
        payload: Prisma.$ShiftNotePayload<ExtArgs>
        fields: Prisma.ShiftNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>
          }
          findFirst: {
            args: Prisma.ShiftNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>
          }
          findMany: {
            args: Prisma.ShiftNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>[]
          }
          create: {
            args: Prisma.ShiftNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>
          }
          createMany: {
            args: Prisma.ShiftNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>[]
          }
          delete: {
            args: Prisma.ShiftNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>
          }
          update: {
            args: Prisma.ShiftNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>
          }
          deleteMany: {
            args: Prisma.ShiftNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftNotePayload>
          }
          aggregate: {
            args: Prisma.ShiftNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftNote>
          }
          groupBy: {
            args: Prisma.ShiftNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftNoteCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Aviso: {
        payload: Prisma.$AvisoPayload<ExtArgs>
        fields: Prisma.AvisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>
          }
          findFirst: {
            args: Prisma.AvisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>
          }
          findMany: {
            args: Prisma.AvisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>[]
          }
          create: {
            args: Prisma.AvisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>
          }
          createMany: {
            args: Prisma.AvisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>[]
          }
          delete: {
            args: Prisma.AvisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>
          }
          update: {
            args: Prisma.AvisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>
          }
          deleteMany: {
            args: Prisma.AvisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvisoPayload>
          }
          aggregate: {
            args: Prisma.AvisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAviso>
          }
          groupBy: {
            args: Prisma.AvisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvisoCountArgs<ExtArgs>
            result: $Utils.Optional<AvisoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reservas: number
    cancelacoes: number
    visitanteRegistros: number
    entregasCriadas: number
    entregasRecebidas: number
    plantaoNotas: number
    notificacoes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | UserCountOutputTypeCountReservasArgs
    cancelacoes?: boolean | UserCountOutputTypeCountCancelacoesArgs
    visitanteRegistros?: boolean | UserCountOutputTypeCountVisitanteRegistrosArgs
    entregasCriadas?: boolean | UserCountOutputTypeCountEntregasCriadasArgs
    entregasRecebidas?: boolean | UserCountOutputTypeCountEntregasRecebidasArgs
    plantaoNotas?: boolean | UserCountOutputTypeCountPlantaoNotasArgs
    notificacoes?: boolean | UserCountOutputTypeCountNotificacoesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCancelacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVisitanteRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEntregasCriadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEntregasRecebidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlantaoNotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AreaComumCountOutputType
   */

  export type AreaComumCountOutputType = {
    reservas: number
  }

  export type AreaComumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | AreaComumCountOutputTypeCountReservasArgs
  }

  // Custom InputTypes
  /**
   * AreaComumCountOutputType without action
   */
  export type AreaComumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComumCountOutputType
     */
    select?: AreaComumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaComumCountOutputType without action
   */
  export type AreaComumCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
  }


  /**
   * Count Type CondominioCountOutputType
   */

  export type CondominioCountOutputType = {
    blocos: number
  }

  export type CondominioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocos?: boolean | CondominioCountOutputTypeCountBlocosArgs
  }

  // Custom InputTypes
  /**
   * CondominioCountOutputType without action
   */
  export type CondominioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CondominioCountOutputType
     */
    select?: CondominioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CondominioCountOutputType without action
   */
  export type CondominioCountOutputTypeCountBlocosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocoWhereInput
  }


  /**
   * Count Type BlocoCountOutputType
   */

  export type BlocoCountOutputType = {
    unidades: number
  }

  export type BlocoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidades?: boolean | BlocoCountOutputTypeCountUnidadesArgs
  }

  // Custom InputTypes
  /**
   * BlocoCountOutputType without action
   */
  export type BlocoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoCountOutputType
     */
    select?: BlocoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlocoCountOutputType without action
   */
  export type BlocoCountOutputTypeCountUnidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnidadeWhereInput
  }


  /**
   * Count Type UnidadeCountOutputType
   */

  export type UnidadeCountOutputType = {
    moradores: number
    cobrancas: number
  }

  export type UnidadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moradores?: boolean | UnidadeCountOutputTypeCountMoradoresArgs
    cobrancas?: boolean | UnidadeCountOutputTypeCountCobrancasArgs
  }

  // Custom InputTypes
  /**
   * UnidadeCountOutputType without action
   */
  export type UnidadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeCountOutputType
     */
    select?: UnidadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnidadeCountOutputType without action
   */
  export type UnidadeCountOutputTypeCountMoradoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UnidadeCountOutputType without action
   */
  export type UnidadeCountOutputTypeCountCobrancasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CobrancaWhereInput
  }


  /**
   * Count Type CobrancaCountOutputType
   */

  export type CobrancaCountOutputType = {
    pagamentos: number
  }

  export type CobrancaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamentos?: boolean | CobrancaCountOutputTypeCountPagamentosArgs
  }

  // Custom InputTypes
  /**
   * CobrancaCountOutputType without action
   */
  export type CobrancaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CobrancaCountOutputType
     */
    select?: CobrancaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CobrancaCountOutputType without action
   */
  export type CobrancaCountOutputTypeCountPagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }


  /**
   * Count Type DeliveryCountOutputType
   */

  export type DeliveryCountOutputType = {
    notificacoes: number
  }

  export type DeliveryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificacoes?: boolean | DeliveryCountOutputTypeCountNotificacoesArgs
  }

  // Custom InputTypes
  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryCountOutputType
     */
    select?: DeliveryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountNotificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senhaHash: string | null
    role: $Enums.UserRole | null
    apartamento: string | null
    bloco: string | null
    unidadeId: string | null
    ativo: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senhaHash: string | null
    role: $Enums.UserRole | null
    apartamento: string | null
    bloco: string | null
    unidadeId: string | null
    ativo: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senhaHash: number
    role: number
    apartamento: number
    bloco: number
    unidadeId: number
    ativo: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senhaHash?: true
    role?: true
    apartamento?: true
    bloco?: true
    unidadeId?: true
    ativo?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senhaHash?: true
    role?: true
    apartamento?: true
    bloco?: true
    unidadeId?: true
    ativo?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senhaHash?: true
    role?: true
    apartamento?: true
    bloco?: true
    unidadeId?: true
    ativo?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento: string | null
    bloco: string | null
    unidadeId: string | null
    ativo: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    apartamento?: boolean
    bloco?: boolean
    unidadeId?: boolean
    ativo?: boolean
    createdAt?: boolean
    reservas?: boolean | User$reservasArgs<ExtArgs>
    cancelacoes?: boolean | User$cancelacoesArgs<ExtArgs>
    visitanteRegistros?: boolean | User$visitanteRegistrosArgs<ExtArgs>
    entregasCriadas?: boolean | User$entregasCriadasArgs<ExtArgs>
    entregasRecebidas?: boolean | User$entregasRecebidasArgs<ExtArgs>
    plantaoNotas?: boolean | User$plantaoNotasArgs<ExtArgs>
    notificacoes?: boolean | User$notificacoesArgs<ExtArgs>
    unidade?: boolean | User$unidadeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    apartamento?: boolean
    bloco?: boolean
    unidadeId?: boolean
    ativo?: boolean
    createdAt?: boolean
    unidade?: boolean | User$unidadeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    apartamento?: boolean
    bloco?: boolean
    unidadeId?: boolean
    ativo?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | User$reservasArgs<ExtArgs>
    cancelacoes?: boolean | User$cancelacoesArgs<ExtArgs>
    visitanteRegistros?: boolean | User$visitanteRegistrosArgs<ExtArgs>
    entregasCriadas?: boolean | User$entregasCriadasArgs<ExtArgs>
    entregasRecebidas?: boolean | User$entregasRecebidasArgs<ExtArgs>
    plantaoNotas?: boolean | User$plantaoNotasArgs<ExtArgs>
    notificacoes?: boolean | User$notificacoesArgs<ExtArgs>
    unidade?: boolean | User$unidadeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidade?: boolean | User$unidadeArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      reservas: Prisma.$ReservaPayload<ExtArgs>[]
      cancelacoes: Prisma.$ReservaPayload<ExtArgs>[]
      visitanteRegistros: Prisma.$VisitorLogPayload<ExtArgs>[]
      entregasCriadas: Prisma.$DeliveryPayload<ExtArgs>[]
      entregasRecebidas: Prisma.$DeliveryPayload<ExtArgs>[]
      plantaoNotas: Prisma.$ShiftNotePayload<ExtArgs>[]
      notificacoes: Prisma.$NotificationPayload<ExtArgs>[]
      unidade: Prisma.$UnidadePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      email: string
      senhaHash: string
      role: $Enums.UserRole
      apartamento: string | null
      bloco: string | null
      unidadeId: string | null
      ativo: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservas<T extends User$reservasArgs<ExtArgs> = {}>(args?: Subset<T, User$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany"> | Null>
    cancelacoes<T extends User$cancelacoesArgs<ExtArgs> = {}>(args?: Subset<T, User$cancelacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany"> | Null>
    visitanteRegistros<T extends User$visitanteRegistrosArgs<ExtArgs> = {}>(args?: Subset<T, User$visitanteRegistrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "findMany"> | Null>
    entregasCriadas<T extends User$entregasCriadasArgs<ExtArgs> = {}>(args?: Subset<T, User$entregasCriadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    entregasRecebidas<T extends User$entregasRecebidasArgs<ExtArgs> = {}>(args?: Subset<T, User$entregasRecebidasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    plantaoNotas<T extends User$plantaoNotasArgs<ExtArgs> = {}>(args?: Subset<T, User$plantaoNotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "findMany"> | Null>
    notificacoes<T extends User$notificacoesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    unidade<T extends User$unidadeArgs<ExtArgs> = {}>(args?: Subset<T, User$unidadeArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly nome: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly senhaHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly apartamento: FieldRef<"User", 'String'>
    readonly bloco: FieldRef<"User", 'String'>
    readonly unidadeId: FieldRef<"User", 'String'>
    readonly ativo: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.reservas
   */
  export type User$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * User.cancelacoes
   */
  export type User$cancelacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * User.visitanteRegistros
   */
  export type User$visitanteRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    where?: VisitorLogWhereInput
    orderBy?: VisitorLogOrderByWithRelationInput | VisitorLogOrderByWithRelationInput[]
    cursor?: VisitorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitorLogScalarFieldEnum | VisitorLogScalarFieldEnum[]
  }

  /**
   * User.entregasCriadas
   */
  export type User$entregasCriadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * User.entregasRecebidas
   */
  export type User$entregasRecebidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * User.plantaoNotas
   */
  export type User$plantaoNotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    where?: ShiftNoteWhereInput
    orderBy?: ShiftNoteOrderByWithRelationInput | ShiftNoteOrderByWithRelationInput[]
    cursor?: ShiftNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftNoteScalarFieldEnum | ShiftNoteScalarFieldEnum[]
  }

  /**
   * User.notificacoes
   */
  export type User$notificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.unidade
   */
  export type User$unidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    where?: UnidadeWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AreaComum
   */

  export type AggregateAreaComum = {
    _count: AreaComumCountAggregateOutputType | null
    _min: AreaComumMinAggregateOutputType | null
    _max: AreaComumMaxAggregateOutputType | null
  }

  export type AreaComumMinAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    horarioInicio: string | null
    horarioFim: string | null
    createdAt: Date | null
  }

  export type AreaComumMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    horarioInicio: string | null
    horarioFim: string | null
    createdAt: Date | null
  }

  export type AreaComumCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    horarioInicio: number
    horarioFim: number
    createdAt: number
    _all: number
  }


  export type AreaComumMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    horarioInicio?: true
    horarioFim?: true
    createdAt?: true
  }

  export type AreaComumMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    horarioInicio?: true
    horarioFim?: true
    createdAt?: true
  }

  export type AreaComumCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    horarioInicio?: true
    horarioFim?: true
    createdAt?: true
    _all?: true
  }

  export type AreaComumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaComum to aggregate.
     */
    where?: AreaComumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaComums to fetch.
     */
    orderBy?: AreaComumOrderByWithRelationInput | AreaComumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaComumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaComums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaComums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaComums
    **/
    _count?: true | AreaComumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaComumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaComumMaxAggregateInputType
  }

  export type GetAreaComumAggregateType<T extends AreaComumAggregateArgs> = {
        [P in keyof T & keyof AggregateAreaComum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaComum[P]>
      : GetScalarType<T[P], AggregateAreaComum[P]>
  }




  export type AreaComumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaComumWhereInput
    orderBy?: AreaComumOrderByWithAggregationInput | AreaComumOrderByWithAggregationInput[]
    by: AreaComumScalarFieldEnum[] | AreaComumScalarFieldEnum
    having?: AreaComumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaComumCountAggregateInputType | true
    _min?: AreaComumMinAggregateInputType
    _max?: AreaComumMaxAggregateInputType
  }

  export type AreaComumGroupByOutputType = {
    id: string
    nome: string
    descricao: string | null
    horarioInicio: string | null
    horarioFim: string | null
    createdAt: Date
    _count: AreaComumCountAggregateOutputType | null
    _min: AreaComumMinAggregateOutputType | null
    _max: AreaComumMaxAggregateOutputType | null
  }

  type GetAreaComumGroupByPayload<T extends AreaComumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaComumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaComumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaComumGroupByOutputType[P]>
            : GetScalarType<T[P], AreaComumGroupByOutputType[P]>
        }
      >
    >


  export type AreaComumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    createdAt?: boolean
    reservas?: boolean | AreaComum$reservasArgs<ExtArgs>
    _count?: boolean | AreaComumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areaComum"]>

  export type AreaComumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["areaComum"]>

  export type AreaComumSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    createdAt?: boolean
  }

  export type AreaComumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | AreaComum$reservasArgs<ExtArgs>
    _count?: boolean | AreaComumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaComumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreaComumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AreaComum"
    objects: {
      reservas: Prisma.$ReservaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      descricao: string | null
      horarioInicio: string | null
      horarioFim: string | null
      createdAt: Date
    }, ExtArgs["result"]["areaComum"]>
    composites: {}
  }

  type AreaComumGetPayload<S extends boolean | null | undefined | AreaComumDefaultArgs> = $Result.GetResult<Prisma.$AreaComumPayload, S>

  type AreaComumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaComumFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AreaComumCountAggregateInputType | true
    }

  export interface AreaComumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AreaComum'], meta: { name: 'AreaComum' } }
    /**
     * Find zero or one AreaComum that matches the filter.
     * @param {AreaComumFindUniqueArgs} args - Arguments to find a AreaComum
     * @example
     * // Get one AreaComum
     * const areaComum = await prisma.areaComum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaComumFindUniqueArgs>(args: SelectSubset<T, AreaComumFindUniqueArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AreaComum that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AreaComumFindUniqueOrThrowArgs} args - Arguments to find a AreaComum
     * @example
     * // Get one AreaComum
     * const areaComum = await prisma.areaComum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaComumFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaComumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AreaComum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumFindFirstArgs} args - Arguments to find a AreaComum
     * @example
     * // Get one AreaComum
     * const areaComum = await prisma.areaComum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaComumFindFirstArgs>(args?: SelectSubset<T, AreaComumFindFirstArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AreaComum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumFindFirstOrThrowArgs} args - Arguments to find a AreaComum
     * @example
     * // Get one AreaComum
     * const areaComum = await prisma.areaComum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaComumFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaComumFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AreaComums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaComums
     * const areaComums = await prisma.areaComum.findMany()
     * 
     * // Get first 10 AreaComums
     * const areaComums = await prisma.areaComum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaComumWithIdOnly = await prisma.areaComum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaComumFindManyArgs>(args?: SelectSubset<T, AreaComumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AreaComum.
     * @param {AreaComumCreateArgs} args - Arguments to create a AreaComum.
     * @example
     * // Create one AreaComum
     * const AreaComum = await prisma.areaComum.create({
     *   data: {
     *     // ... data to create a AreaComum
     *   }
     * })
     * 
     */
    create<T extends AreaComumCreateArgs>(args: SelectSubset<T, AreaComumCreateArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AreaComums.
     * @param {AreaComumCreateManyArgs} args - Arguments to create many AreaComums.
     * @example
     * // Create many AreaComums
     * const areaComum = await prisma.areaComum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaComumCreateManyArgs>(args?: SelectSubset<T, AreaComumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AreaComums and returns the data saved in the database.
     * @param {AreaComumCreateManyAndReturnArgs} args - Arguments to create many AreaComums.
     * @example
     * // Create many AreaComums
     * const areaComum = await prisma.areaComum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AreaComums and only return the `id`
     * const areaComumWithIdOnly = await prisma.areaComum.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaComumCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaComumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AreaComum.
     * @param {AreaComumDeleteArgs} args - Arguments to delete one AreaComum.
     * @example
     * // Delete one AreaComum
     * const AreaComum = await prisma.areaComum.delete({
     *   where: {
     *     // ... filter to delete one AreaComum
     *   }
     * })
     * 
     */
    delete<T extends AreaComumDeleteArgs>(args: SelectSubset<T, AreaComumDeleteArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AreaComum.
     * @param {AreaComumUpdateArgs} args - Arguments to update one AreaComum.
     * @example
     * // Update one AreaComum
     * const areaComum = await prisma.areaComum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaComumUpdateArgs>(args: SelectSubset<T, AreaComumUpdateArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AreaComums.
     * @param {AreaComumDeleteManyArgs} args - Arguments to filter AreaComums to delete.
     * @example
     * // Delete a few AreaComums
     * const { count } = await prisma.areaComum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaComumDeleteManyArgs>(args?: SelectSubset<T, AreaComumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaComums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaComums
     * const areaComum = await prisma.areaComum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaComumUpdateManyArgs>(args: SelectSubset<T, AreaComumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AreaComum.
     * @param {AreaComumUpsertArgs} args - Arguments to update or create a AreaComum.
     * @example
     * // Update or create a AreaComum
     * const areaComum = await prisma.areaComum.upsert({
     *   create: {
     *     // ... data to create a AreaComum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaComum we want to update
     *   }
     * })
     */
    upsert<T extends AreaComumUpsertArgs>(args: SelectSubset<T, AreaComumUpsertArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AreaComums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumCountArgs} args - Arguments to filter AreaComums to count.
     * @example
     * // Count the number of AreaComums
     * const count = await prisma.areaComum.count({
     *   where: {
     *     // ... the filter for the AreaComums we want to count
     *   }
     * })
    **/
    count<T extends AreaComumCountArgs>(
      args?: Subset<T, AreaComumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaComumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaComum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaComumAggregateArgs>(args: Subset<T, AreaComumAggregateArgs>): Prisma.PrismaPromise<GetAreaComumAggregateType<T>>

    /**
     * Group by AreaComum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaComumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaComumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaComumGroupByArgs['orderBy'] }
        : { orderBy?: AreaComumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaComumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaComumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AreaComum model
   */
  readonly fields: AreaComumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaComum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaComumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservas<T extends AreaComum$reservasArgs<ExtArgs> = {}>(args?: Subset<T, AreaComum$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AreaComum model
   */ 
  interface AreaComumFieldRefs {
    readonly id: FieldRef<"AreaComum", 'String'>
    readonly nome: FieldRef<"AreaComum", 'String'>
    readonly descricao: FieldRef<"AreaComum", 'String'>
    readonly horarioInicio: FieldRef<"AreaComum", 'String'>
    readonly horarioFim: FieldRef<"AreaComum", 'String'>
    readonly createdAt: FieldRef<"AreaComum", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AreaComum findUnique
   */
  export type AreaComumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * Filter, which AreaComum to fetch.
     */
    where: AreaComumWhereUniqueInput
  }

  /**
   * AreaComum findUniqueOrThrow
   */
  export type AreaComumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * Filter, which AreaComum to fetch.
     */
    where: AreaComumWhereUniqueInput
  }

  /**
   * AreaComum findFirst
   */
  export type AreaComumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * Filter, which AreaComum to fetch.
     */
    where?: AreaComumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaComums to fetch.
     */
    orderBy?: AreaComumOrderByWithRelationInput | AreaComumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaComums.
     */
    cursor?: AreaComumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaComums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaComums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaComums.
     */
    distinct?: AreaComumScalarFieldEnum | AreaComumScalarFieldEnum[]
  }

  /**
   * AreaComum findFirstOrThrow
   */
  export type AreaComumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * Filter, which AreaComum to fetch.
     */
    where?: AreaComumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaComums to fetch.
     */
    orderBy?: AreaComumOrderByWithRelationInput | AreaComumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaComums.
     */
    cursor?: AreaComumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaComums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaComums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaComums.
     */
    distinct?: AreaComumScalarFieldEnum | AreaComumScalarFieldEnum[]
  }

  /**
   * AreaComum findMany
   */
  export type AreaComumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * Filter, which AreaComums to fetch.
     */
    where?: AreaComumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaComums to fetch.
     */
    orderBy?: AreaComumOrderByWithRelationInput | AreaComumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaComums.
     */
    cursor?: AreaComumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaComums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaComums.
     */
    skip?: number
    distinct?: AreaComumScalarFieldEnum | AreaComumScalarFieldEnum[]
  }

  /**
   * AreaComum create
   */
  export type AreaComumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * The data needed to create a AreaComum.
     */
    data: XOR<AreaComumCreateInput, AreaComumUncheckedCreateInput>
  }

  /**
   * AreaComum createMany
   */
  export type AreaComumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AreaComums.
     */
    data: AreaComumCreateManyInput | AreaComumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AreaComum createManyAndReturn
   */
  export type AreaComumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AreaComums.
     */
    data: AreaComumCreateManyInput | AreaComumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AreaComum update
   */
  export type AreaComumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * The data needed to update a AreaComum.
     */
    data: XOR<AreaComumUpdateInput, AreaComumUncheckedUpdateInput>
    /**
     * Choose, which AreaComum to update.
     */
    where: AreaComumWhereUniqueInput
  }

  /**
   * AreaComum updateMany
   */
  export type AreaComumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AreaComums.
     */
    data: XOR<AreaComumUpdateManyMutationInput, AreaComumUncheckedUpdateManyInput>
    /**
     * Filter which AreaComums to update
     */
    where?: AreaComumWhereInput
  }

  /**
   * AreaComum upsert
   */
  export type AreaComumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * The filter to search for the AreaComum to update in case it exists.
     */
    where: AreaComumWhereUniqueInput
    /**
     * In case the AreaComum found by the `where` argument doesn't exist, create a new AreaComum with this data.
     */
    create: XOR<AreaComumCreateInput, AreaComumUncheckedCreateInput>
    /**
     * In case the AreaComum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaComumUpdateInput, AreaComumUncheckedUpdateInput>
  }

  /**
   * AreaComum delete
   */
  export type AreaComumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
    /**
     * Filter which AreaComum to delete.
     */
    where: AreaComumWhereUniqueInput
  }

  /**
   * AreaComum deleteMany
   */
  export type AreaComumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaComums to delete
     */
    where?: AreaComumWhereInput
  }

  /**
   * AreaComum.reservas
   */
  export type AreaComum$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * AreaComum without action
   */
  export type AreaComumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaComum
     */
    select?: AreaComumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaComumInclude<ExtArgs> | null
  }


  /**
   * Model Condominio
   */

  export type AggregateCondominio = {
    _count: CondominioCountAggregateOutputType | null
    _min: CondominioMinAggregateOutputType | null
    _max: CondominioMaxAggregateOutputType | null
  }

  export type CondominioMinAggregateOutputType = {
    id: string | null
    nome: string | null
    cnpj: string | null
    endereco: string | null
    createdAt: Date | null
  }

  export type CondominioMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    cnpj: string | null
    endereco: string | null
    createdAt: Date | null
  }

  export type CondominioCountAggregateOutputType = {
    id: number
    nome: number
    cnpj: number
    endereco: number
    createdAt: number
    _all: number
  }


  export type CondominioMinAggregateInputType = {
    id?: true
    nome?: true
    cnpj?: true
    endereco?: true
    createdAt?: true
  }

  export type CondominioMaxAggregateInputType = {
    id?: true
    nome?: true
    cnpj?: true
    endereco?: true
    createdAt?: true
  }

  export type CondominioCountAggregateInputType = {
    id?: true
    nome?: true
    cnpj?: true
    endereco?: true
    createdAt?: true
    _all?: true
  }

  export type CondominioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Condominio to aggregate.
     */
    where?: CondominioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Condominios to fetch.
     */
    orderBy?: CondominioOrderByWithRelationInput | CondominioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CondominioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Condominios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Condominios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Condominios
    **/
    _count?: true | CondominioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CondominioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CondominioMaxAggregateInputType
  }

  export type GetCondominioAggregateType<T extends CondominioAggregateArgs> = {
        [P in keyof T & keyof AggregateCondominio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCondominio[P]>
      : GetScalarType<T[P], AggregateCondominio[P]>
  }




  export type CondominioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CondominioWhereInput
    orderBy?: CondominioOrderByWithAggregationInput | CondominioOrderByWithAggregationInput[]
    by: CondominioScalarFieldEnum[] | CondominioScalarFieldEnum
    having?: CondominioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CondominioCountAggregateInputType | true
    _min?: CondominioMinAggregateInputType
    _max?: CondominioMaxAggregateInputType
  }

  export type CondominioGroupByOutputType = {
    id: string
    nome: string
    cnpj: string | null
    endereco: string | null
    createdAt: Date
    _count: CondominioCountAggregateOutputType | null
    _min: CondominioMinAggregateOutputType | null
    _max: CondominioMaxAggregateOutputType | null
  }

  type GetCondominioGroupByPayload<T extends CondominioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CondominioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CondominioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CondominioGroupByOutputType[P]>
            : GetScalarType<T[P], CondominioGroupByOutputType[P]>
        }
      >
    >


  export type CondominioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cnpj?: boolean
    endereco?: boolean
    createdAt?: boolean
    blocos?: boolean | Condominio$blocosArgs<ExtArgs>
    configuracoes?: boolean | Condominio$configuracoesArgs<ExtArgs>
    _count?: boolean | CondominioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["condominio"]>

  export type CondominioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cnpj?: boolean
    endereco?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["condominio"]>

  export type CondominioSelectScalar = {
    id?: boolean
    nome?: boolean
    cnpj?: boolean
    endereco?: boolean
    createdAt?: boolean
  }

  export type CondominioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocos?: boolean | Condominio$blocosArgs<ExtArgs>
    configuracoes?: boolean | Condominio$configuracoesArgs<ExtArgs>
    _count?: boolean | CondominioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CondominioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CondominioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Condominio"
    objects: {
      blocos: Prisma.$BlocoPayload<ExtArgs>[]
      configuracoes: Prisma.$ConfigReservaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      cnpj: string | null
      endereco: string | null
      createdAt: Date
    }, ExtArgs["result"]["condominio"]>
    composites: {}
  }

  type CondominioGetPayload<S extends boolean | null | undefined | CondominioDefaultArgs> = $Result.GetResult<Prisma.$CondominioPayload, S>

  type CondominioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CondominioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CondominioCountAggregateInputType | true
    }

  export interface CondominioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Condominio'], meta: { name: 'Condominio' } }
    /**
     * Find zero or one Condominio that matches the filter.
     * @param {CondominioFindUniqueArgs} args - Arguments to find a Condominio
     * @example
     * // Get one Condominio
     * const condominio = await prisma.condominio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CondominioFindUniqueArgs>(args: SelectSubset<T, CondominioFindUniqueArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Condominio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CondominioFindUniqueOrThrowArgs} args - Arguments to find a Condominio
     * @example
     * // Get one Condominio
     * const condominio = await prisma.condominio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CondominioFindUniqueOrThrowArgs>(args: SelectSubset<T, CondominioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Condominio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioFindFirstArgs} args - Arguments to find a Condominio
     * @example
     * // Get one Condominio
     * const condominio = await prisma.condominio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CondominioFindFirstArgs>(args?: SelectSubset<T, CondominioFindFirstArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Condominio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioFindFirstOrThrowArgs} args - Arguments to find a Condominio
     * @example
     * // Get one Condominio
     * const condominio = await prisma.condominio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CondominioFindFirstOrThrowArgs>(args?: SelectSubset<T, CondominioFindFirstOrThrowArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Condominios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Condominios
     * const condominios = await prisma.condominio.findMany()
     * 
     * // Get first 10 Condominios
     * const condominios = await prisma.condominio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const condominioWithIdOnly = await prisma.condominio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CondominioFindManyArgs>(args?: SelectSubset<T, CondominioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Condominio.
     * @param {CondominioCreateArgs} args - Arguments to create a Condominio.
     * @example
     * // Create one Condominio
     * const Condominio = await prisma.condominio.create({
     *   data: {
     *     // ... data to create a Condominio
     *   }
     * })
     * 
     */
    create<T extends CondominioCreateArgs>(args: SelectSubset<T, CondominioCreateArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Condominios.
     * @param {CondominioCreateManyArgs} args - Arguments to create many Condominios.
     * @example
     * // Create many Condominios
     * const condominio = await prisma.condominio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CondominioCreateManyArgs>(args?: SelectSubset<T, CondominioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Condominios and returns the data saved in the database.
     * @param {CondominioCreateManyAndReturnArgs} args - Arguments to create many Condominios.
     * @example
     * // Create many Condominios
     * const condominio = await prisma.condominio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Condominios and only return the `id`
     * const condominioWithIdOnly = await prisma.condominio.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CondominioCreateManyAndReturnArgs>(args?: SelectSubset<T, CondominioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Condominio.
     * @param {CondominioDeleteArgs} args - Arguments to delete one Condominio.
     * @example
     * // Delete one Condominio
     * const Condominio = await prisma.condominio.delete({
     *   where: {
     *     // ... filter to delete one Condominio
     *   }
     * })
     * 
     */
    delete<T extends CondominioDeleteArgs>(args: SelectSubset<T, CondominioDeleteArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Condominio.
     * @param {CondominioUpdateArgs} args - Arguments to update one Condominio.
     * @example
     * // Update one Condominio
     * const condominio = await prisma.condominio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CondominioUpdateArgs>(args: SelectSubset<T, CondominioUpdateArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Condominios.
     * @param {CondominioDeleteManyArgs} args - Arguments to filter Condominios to delete.
     * @example
     * // Delete a few Condominios
     * const { count } = await prisma.condominio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CondominioDeleteManyArgs>(args?: SelectSubset<T, CondominioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Condominios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Condominios
     * const condominio = await prisma.condominio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CondominioUpdateManyArgs>(args: SelectSubset<T, CondominioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Condominio.
     * @param {CondominioUpsertArgs} args - Arguments to update or create a Condominio.
     * @example
     * // Update or create a Condominio
     * const condominio = await prisma.condominio.upsert({
     *   create: {
     *     // ... data to create a Condominio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Condominio we want to update
     *   }
     * })
     */
    upsert<T extends CondominioUpsertArgs>(args: SelectSubset<T, CondominioUpsertArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Condominios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioCountArgs} args - Arguments to filter Condominios to count.
     * @example
     * // Count the number of Condominios
     * const count = await prisma.condominio.count({
     *   where: {
     *     // ... the filter for the Condominios we want to count
     *   }
     * })
    **/
    count<T extends CondominioCountArgs>(
      args?: Subset<T, CondominioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CondominioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Condominio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CondominioAggregateArgs>(args: Subset<T, CondominioAggregateArgs>): Prisma.PrismaPromise<GetCondominioAggregateType<T>>

    /**
     * Group by Condominio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CondominioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CondominioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CondominioGroupByArgs['orderBy'] }
        : { orderBy?: CondominioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CondominioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCondominioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Condominio model
   */
  readonly fields: CondominioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Condominio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CondominioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocos<T extends Condominio$blocosArgs<ExtArgs> = {}>(args?: Subset<T, Condominio$blocosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findMany"> | Null>
    configuracoes<T extends Condominio$configuracoesArgs<ExtArgs> = {}>(args?: Subset<T, Condominio$configuracoesArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Condominio model
   */ 
  interface CondominioFieldRefs {
    readonly id: FieldRef<"Condominio", 'String'>
    readonly nome: FieldRef<"Condominio", 'String'>
    readonly cnpj: FieldRef<"Condominio", 'String'>
    readonly endereco: FieldRef<"Condominio", 'String'>
    readonly createdAt: FieldRef<"Condominio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Condominio findUnique
   */
  export type CondominioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * Filter, which Condominio to fetch.
     */
    where: CondominioWhereUniqueInput
  }

  /**
   * Condominio findUniqueOrThrow
   */
  export type CondominioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * Filter, which Condominio to fetch.
     */
    where: CondominioWhereUniqueInput
  }

  /**
   * Condominio findFirst
   */
  export type CondominioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * Filter, which Condominio to fetch.
     */
    where?: CondominioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Condominios to fetch.
     */
    orderBy?: CondominioOrderByWithRelationInput | CondominioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Condominios.
     */
    cursor?: CondominioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Condominios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Condominios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Condominios.
     */
    distinct?: CondominioScalarFieldEnum | CondominioScalarFieldEnum[]
  }

  /**
   * Condominio findFirstOrThrow
   */
  export type CondominioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * Filter, which Condominio to fetch.
     */
    where?: CondominioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Condominios to fetch.
     */
    orderBy?: CondominioOrderByWithRelationInput | CondominioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Condominios.
     */
    cursor?: CondominioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Condominios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Condominios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Condominios.
     */
    distinct?: CondominioScalarFieldEnum | CondominioScalarFieldEnum[]
  }

  /**
   * Condominio findMany
   */
  export type CondominioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * Filter, which Condominios to fetch.
     */
    where?: CondominioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Condominios to fetch.
     */
    orderBy?: CondominioOrderByWithRelationInput | CondominioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Condominios.
     */
    cursor?: CondominioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Condominios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Condominios.
     */
    skip?: number
    distinct?: CondominioScalarFieldEnum | CondominioScalarFieldEnum[]
  }

  /**
   * Condominio create
   */
  export type CondominioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * The data needed to create a Condominio.
     */
    data: XOR<CondominioCreateInput, CondominioUncheckedCreateInput>
  }

  /**
   * Condominio createMany
   */
  export type CondominioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Condominios.
     */
    data: CondominioCreateManyInput | CondominioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Condominio createManyAndReturn
   */
  export type CondominioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Condominios.
     */
    data: CondominioCreateManyInput | CondominioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Condominio update
   */
  export type CondominioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * The data needed to update a Condominio.
     */
    data: XOR<CondominioUpdateInput, CondominioUncheckedUpdateInput>
    /**
     * Choose, which Condominio to update.
     */
    where: CondominioWhereUniqueInput
  }

  /**
   * Condominio updateMany
   */
  export type CondominioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Condominios.
     */
    data: XOR<CondominioUpdateManyMutationInput, CondominioUncheckedUpdateManyInput>
    /**
     * Filter which Condominios to update
     */
    where?: CondominioWhereInput
  }

  /**
   * Condominio upsert
   */
  export type CondominioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * The filter to search for the Condominio to update in case it exists.
     */
    where: CondominioWhereUniqueInput
    /**
     * In case the Condominio found by the `where` argument doesn't exist, create a new Condominio with this data.
     */
    create: XOR<CondominioCreateInput, CondominioUncheckedCreateInput>
    /**
     * In case the Condominio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CondominioUpdateInput, CondominioUncheckedUpdateInput>
  }

  /**
   * Condominio delete
   */
  export type CondominioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
    /**
     * Filter which Condominio to delete.
     */
    where: CondominioWhereUniqueInput
  }

  /**
   * Condominio deleteMany
   */
  export type CondominioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Condominios to delete
     */
    where?: CondominioWhereInput
  }

  /**
   * Condominio.blocos
   */
  export type Condominio$blocosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    where?: BlocoWhereInput
    orderBy?: BlocoOrderByWithRelationInput | BlocoOrderByWithRelationInput[]
    cursor?: BlocoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocoScalarFieldEnum | BlocoScalarFieldEnum[]
  }

  /**
   * Condominio.configuracoes
   */
  export type Condominio$configuracoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    where?: ConfigReservaWhereInput
  }

  /**
   * Condominio without action
   */
  export type CondominioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condominio
     */
    select?: CondominioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CondominioInclude<ExtArgs> | null
  }


  /**
   * Model Bloco
   */

  export type AggregateBloco = {
    _count: BlocoCountAggregateOutputType | null
    _min: BlocoMinAggregateOutputType | null
    _max: BlocoMaxAggregateOutputType | null
  }

  export type BlocoMinAggregateOutputType = {
    id: string | null
    nome: string | null
    condominioId: string | null
  }

  export type BlocoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    condominioId: string | null
  }

  export type BlocoCountAggregateOutputType = {
    id: number
    nome: number
    condominioId: number
    _all: number
  }


  export type BlocoMinAggregateInputType = {
    id?: true
    nome?: true
    condominioId?: true
  }

  export type BlocoMaxAggregateInputType = {
    id?: true
    nome?: true
    condominioId?: true
  }

  export type BlocoCountAggregateInputType = {
    id?: true
    nome?: true
    condominioId?: true
    _all?: true
  }

  export type BlocoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bloco to aggregate.
     */
    where?: BlocoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocos to fetch.
     */
    orderBy?: BlocoOrderByWithRelationInput | BlocoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlocoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocos
    **/
    _count?: true | BlocoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocoMaxAggregateInputType
  }

  export type GetBlocoAggregateType<T extends BlocoAggregateArgs> = {
        [P in keyof T & keyof AggregateBloco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBloco[P]>
      : GetScalarType<T[P], AggregateBloco[P]>
  }




  export type BlocoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocoWhereInput
    orderBy?: BlocoOrderByWithAggregationInput | BlocoOrderByWithAggregationInput[]
    by: BlocoScalarFieldEnum[] | BlocoScalarFieldEnum
    having?: BlocoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocoCountAggregateInputType | true
    _min?: BlocoMinAggregateInputType
    _max?: BlocoMaxAggregateInputType
  }

  export type BlocoGroupByOutputType = {
    id: string
    nome: string
    condominioId: string
    _count: BlocoCountAggregateOutputType | null
    _min: BlocoMinAggregateOutputType | null
    _max: BlocoMaxAggregateOutputType | null
  }

  type GetBlocoGroupByPayload<T extends BlocoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocoGroupByOutputType[P]>
            : GetScalarType<T[P], BlocoGroupByOutputType[P]>
        }
      >
    >


  export type BlocoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    condominioId?: boolean
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
    unidades?: boolean | Bloco$unidadesArgs<ExtArgs>
    _count?: boolean | BlocoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloco"]>

  export type BlocoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    condominioId?: boolean
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloco"]>

  export type BlocoSelectScalar = {
    id?: boolean
    nome?: boolean
    condominioId?: boolean
  }

  export type BlocoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
    unidades?: boolean | Bloco$unidadesArgs<ExtArgs>
    _count?: boolean | BlocoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlocoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
  }

  export type $BlocoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bloco"
    objects: {
      condominio: Prisma.$CondominioPayload<ExtArgs>
      unidades: Prisma.$UnidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      condominioId: string
    }, ExtArgs["result"]["bloco"]>
    composites: {}
  }

  type BlocoGetPayload<S extends boolean | null | undefined | BlocoDefaultArgs> = $Result.GetResult<Prisma.$BlocoPayload, S>

  type BlocoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlocoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlocoCountAggregateInputType | true
    }

  export interface BlocoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bloco'], meta: { name: 'Bloco' } }
    /**
     * Find zero or one Bloco that matches the filter.
     * @param {BlocoFindUniqueArgs} args - Arguments to find a Bloco
     * @example
     * // Get one Bloco
     * const bloco = await prisma.bloco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlocoFindUniqueArgs>(args: SelectSubset<T, BlocoFindUniqueArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bloco that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlocoFindUniqueOrThrowArgs} args - Arguments to find a Bloco
     * @example
     * // Get one Bloco
     * const bloco = await prisma.bloco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlocoFindUniqueOrThrowArgs>(args: SelectSubset<T, BlocoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bloco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoFindFirstArgs} args - Arguments to find a Bloco
     * @example
     * // Get one Bloco
     * const bloco = await prisma.bloco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlocoFindFirstArgs>(args?: SelectSubset<T, BlocoFindFirstArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bloco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoFindFirstOrThrowArgs} args - Arguments to find a Bloco
     * @example
     * // Get one Bloco
     * const bloco = await prisma.bloco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlocoFindFirstOrThrowArgs>(args?: SelectSubset<T, BlocoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blocos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocos
     * const blocos = await prisma.bloco.findMany()
     * 
     * // Get first 10 Blocos
     * const blocos = await prisma.bloco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blocoWithIdOnly = await prisma.bloco.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlocoFindManyArgs>(args?: SelectSubset<T, BlocoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bloco.
     * @param {BlocoCreateArgs} args - Arguments to create a Bloco.
     * @example
     * // Create one Bloco
     * const Bloco = await prisma.bloco.create({
     *   data: {
     *     // ... data to create a Bloco
     *   }
     * })
     * 
     */
    create<T extends BlocoCreateArgs>(args: SelectSubset<T, BlocoCreateArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blocos.
     * @param {BlocoCreateManyArgs} args - Arguments to create many Blocos.
     * @example
     * // Create many Blocos
     * const bloco = await prisma.bloco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlocoCreateManyArgs>(args?: SelectSubset<T, BlocoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocos and returns the data saved in the database.
     * @param {BlocoCreateManyAndReturnArgs} args - Arguments to create many Blocos.
     * @example
     * // Create many Blocos
     * const bloco = await prisma.bloco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocos and only return the `id`
     * const blocoWithIdOnly = await prisma.bloco.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlocoCreateManyAndReturnArgs>(args?: SelectSubset<T, BlocoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bloco.
     * @param {BlocoDeleteArgs} args - Arguments to delete one Bloco.
     * @example
     * // Delete one Bloco
     * const Bloco = await prisma.bloco.delete({
     *   where: {
     *     // ... filter to delete one Bloco
     *   }
     * })
     * 
     */
    delete<T extends BlocoDeleteArgs>(args: SelectSubset<T, BlocoDeleteArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bloco.
     * @param {BlocoUpdateArgs} args - Arguments to update one Bloco.
     * @example
     * // Update one Bloco
     * const bloco = await prisma.bloco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlocoUpdateArgs>(args: SelectSubset<T, BlocoUpdateArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blocos.
     * @param {BlocoDeleteManyArgs} args - Arguments to filter Blocos to delete.
     * @example
     * // Delete a few Blocos
     * const { count } = await prisma.bloco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlocoDeleteManyArgs>(args?: SelectSubset<T, BlocoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocos
     * const bloco = await prisma.bloco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlocoUpdateManyArgs>(args: SelectSubset<T, BlocoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bloco.
     * @param {BlocoUpsertArgs} args - Arguments to update or create a Bloco.
     * @example
     * // Update or create a Bloco
     * const bloco = await prisma.bloco.upsert({
     *   create: {
     *     // ... data to create a Bloco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bloco we want to update
     *   }
     * })
     */
    upsert<T extends BlocoUpsertArgs>(args: SelectSubset<T, BlocoUpsertArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blocos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoCountArgs} args - Arguments to filter Blocos to count.
     * @example
     * // Count the number of Blocos
     * const count = await prisma.bloco.count({
     *   where: {
     *     // ... the filter for the Blocos we want to count
     *   }
     * })
    **/
    count<T extends BlocoCountArgs>(
      args?: Subset<T, BlocoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bloco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocoAggregateArgs>(args: Subset<T, BlocoAggregateArgs>): Prisma.PrismaPromise<GetBlocoAggregateType<T>>

    /**
     * Group by Bloco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlocoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlocoGroupByArgs['orderBy'] }
        : { orderBy?: BlocoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlocoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bloco model
   */
  readonly fields: BlocoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bloco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlocoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    condominio<T extends CondominioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CondominioDefaultArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unidades<T extends Bloco$unidadesArgs<ExtArgs> = {}>(args?: Subset<T, Bloco$unidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bloco model
   */ 
  interface BlocoFieldRefs {
    readonly id: FieldRef<"Bloco", 'String'>
    readonly nome: FieldRef<"Bloco", 'String'>
    readonly condominioId: FieldRef<"Bloco", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Bloco findUnique
   */
  export type BlocoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * Filter, which Bloco to fetch.
     */
    where: BlocoWhereUniqueInput
  }

  /**
   * Bloco findUniqueOrThrow
   */
  export type BlocoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * Filter, which Bloco to fetch.
     */
    where: BlocoWhereUniqueInput
  }

  /**
   * Bloco findFirst
   */
  export type BlocoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * Filter, which Bloco to fetch.
     */
    where?: BlocoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocos to fetch.
     */
    orderBy?: BlocoOrderByWithRelationInput | BlocoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocos.
     */
    cursor?: BlocoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocos.
     */
    distinct?: BlocoScalarFieldEnum | BlocoScalarFieldEnum[]
  }

  /**
   * Bloco findFirstOrThrow
   */
  export type BlocoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * Filter, which Bloco to fetch.
     */
    where?: BlocoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocos to fetch.
     */
    orderBy?: BlocoOrderByWithRelationInput | BlocoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocos.
     */
    cursor?: BlocoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocos.
     */
    distinct?: BlocoScalarFieldEnum | BlocoScalarFieldEnum[]
  }

  /**
   * Bloco findMany
   */
  export type BlocoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * Filter, which Blocos to fetch.
     */
    where?: BlocoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocos to fetch.
     */
    orderBy?: BlocoOrderByWithRelationInput | BlocoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocos.
     */
    cursor?: BlocoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocos.
     */
    skip?: number
    distinct?: BlocoScalarFieldEnum | BlocoScalarFieldEnum[]
  }

  /**
   * Bloco create
   */
  export type BlocoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * The data needed to create a Bloco.
     */
    data: XOR<BlocoCreateInput, BlocoUncheckedCreateInput>
  }

  /**
   * Bloco createMany
   */
  export type BlocoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocos.
     */
    data: BlocoCreateManyInput | BlocoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bloco createManyAndReturn
   */
  export type BlocoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Blocos.
     */
    data: BlocoCreateManyInput | BlocoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bloco update
   */
  export type BlocoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * The data needed to update a Bloco.
     */
    data: XOR<BlocoUpdateInput, BlocoUncheckedUpdateInput>
    /**
     * Choose, which Bloco to update.
     */
    where: BlocoWhereUniqueInput
  }

  /**
   * Bloco updateMany
   */
  export type BlocoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocos.
     */
    data: XOR<BlocoUpdateManyMutationInput, BlocoUncheckedUpdateManyInput>
    /**
     * Filter which Blocos to update
     */
    where?: BlocoWhereInput
  }

  /**
   * Bloco upsert
   */
  export type BlocoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * The filter to search for the Bloco to update in case it exists.
     */
    where: BlocoWhereUniqueInput
    /**
     * In case the Bloco found by the `where` argument doesn't exist, create a new Bloco with this data.
     */
    create: XOR<BlocoCreateInput, BlocoUncheckedCreateInput>
    /**
     * In case the Bloco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlocoUpdateInput, BlocoUncheckedUpdateInput>
  }

  /**
   * Bloco delete
   */
  export type BlocoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
    /**
     * Filter which Bloco to delete.
     */
    where: BlocoWhereUniqueInput
  }

  /**
   * Bloco deleteMany
   */
  export type BlocoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocos to delete
     */
    where?: BlocoWhereInput
  }

  /**
   * Bloco.unidades
   */
  export type Bloco$unidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    where?: UnidadeWhereInput
    orderBy?: UnidadeOrderByWithRelationInput | UnidadeOrderByWithRelationInput[]
    cursor?: UnidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnidadeScalarFieldEnum | UnidadeScalarFieldEnum[]
  }

  /**
   * Bloco without action
   */
  export type BlocoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloco
     */
    select?: BlocoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoInclude<ExtArgs> | null
  }


  /**
   * Model Unidade
   */

  export type AggregateUnidade = {
    _count: UnidadeCountAggregateOutputType | null
    _min: UnidadeMinAggregateOutputType | null
    _max: UnidadeMaxAggregateOutputType | null
  }

  export type UnidadeMinAggregateOutputType = {
    id: string | null
    numero: string | null
    blocoId: string | null
    createdAt: Date | null
  }

  export type UnidadeMaxAggregateOutputType = {
    id: string | null
    numero: string | null
    blocoId: string | null
    createdAt: Date | null
  }

  export type UnidadeCountAggregateOutputType = {
    id: number
    numero: number
    blocoId: number
    createdAt: number
    _all: number
  }


  export type UnidadeMinAggregateInputType = {
    id?: true
    numero?: true
    blocoId?: true
    createdAt?: true
  }

  export type UnidadeMaxAggregateInputType = {
    id?: true
    numero?: true
    blocoId?: true
    createdAt?: true
  }

  export type UnidadeCountAggregateInputType = {
    id?: true
    numero?: true
    blocoId?: true
    createdAt?: true
    _all?: true
  }

  export type UnidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unidade to aggregate.
     */
    where?: UnidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unidades to fetch.
     */
    orderBy?: UnidadeOrderByWithRelationInput | UnidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Unidades
    **/
    _count?: true | UnidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnidadeMaxAggregateInputType
  }

  export type GetUnidadeAggregateType<T extends UnidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnidade[P]>
      : GetScalarType<T[P], AggregateUnidade[P]>
  }




  export type UnidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnidadeWhereInput
    orderBy?: UnidadeOrderByWithAggregationInput | UnidadeOrderByWithAggregationInput[]
    by: UnidadeScalarFieldEnum[] | UnidadeScalarFieldEnum
    having?: UnidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnidadeCountAggregateInputType | true
    _min?: UnidadeMinAggregateInputType
    _max?: UnidadeMaxAggregateInputType
  }

  export type UnidadeGroupByOutputType = {
    id: string
    numero: string
    blocoId: string
    createdAt: Date
    _count: UnidadeCountAggregateOutputType | null
    _min: UnidadeMinAggregateOutputType | null
    _max: UnidadeMaxAggregateOutputType | null
  }

  type GetUnidadeGroupByPayload<T extends UnidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnidadeGroupByOutputType[P]>
            : GetScalarType<T[P], UnidadeGroupByOutputType[P]>
        }
      >
    >


  export type UnidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    blocoId?: boolean
    createdAt?: boolean
    bloco?: boolean | BlocoDefaultArgs<ExtArgs>
    moradores?: boolean | Unidade$moradoresArgs<ExtArgs>
    cobrancas?: boolean | Unidade$cobrancasArgs<ExtArgs>
    _count?: boolean | UnidadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unidade"]>

  export type UnidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    blocoId?: boolean
    createdAt?: boolean
    bloco?: boolean | BlocoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unidade"]>

  export type UnidadeSelectScalar = {
    id?: boolean
    numero?: boolean
    blocoId?: boolean
    createdAt?: boolean
  }

  export type UnidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bloco?: boolean | BlocoDefaultArgs<ExtArgs>
    moradores?: boolean | Unidade$moradoresArgs<ExtArgs>
    cobrancas?: boolean | Unidade$cobrancasArgs<ExtArgs>
    _count?: boolean | UnidadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bloco?: boolean | BlocoDefaultArgs<ExtArgs>
  }

  export type $UnidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unidade"
    objects: {
      bloco: Prisma.$BlocoPayload<ExtArgs>
      moradores: Prisma.$UserPayload<ExtArgs>[]
      cobrancas: Prisma.$CobrancaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numero: string
      blocoId: string
      createdAt: Date
    }, ExtArgs["result"]["unidade"]>
    composites: {}
  }

  type UnidadeGetPayload<S extends boolean | null | undefined | UnidadeDefaultArgs> = $Result.GetResult<Prisma.$UnidadePayload, S>

  type UnidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnidadeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnidadeCountAggregateInputType | true
    }

  export interface UnidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unidade'], meta: { name: 'Unidade' } }
    /**
     * Find zero or one Unidade that matches the filter.
     * @param {UnidadeFindUniqueArgs} args - Arguments to find a Unidade
     * @example
     * // Get one Unidade
     * const unidade = await prisma.unidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnidadeFindUniqueArgs>(args: SelectSubset<T, UnidadeFindUniqueArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unidade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnidadeFindUniqueOrThrowArgs} args - Arguments to find a Unidade
     * @example
     * // Get one Unidade
     * const unidade = await prisma.unidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, UnidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFindFirstArgs} args - Arguments to find a Unidade
     * @example
     * // Get one Unidade
     * const unidade = await prisma.unidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnidadeFindFirstArgs>(args?: SelectSubset<T, UnidadeFindFirstArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFindFirstOrThrowArgs} args - Arguments to find a Unidade
     * @example
     * // Get one Unidade
     * const unidade = await prisma.unidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, UnidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Unidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unidades
     * const unidades = await prisma.unidade.findMany()
     * 
     * // Get first 10 Unidades
     * const unidades = await prisma.unidade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unidadeWithIdOnly = await prisma.unidade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnidadeFindManyArgs>(args?: SelectSubset<T, UnidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unidade.
     * @param {UnidadeCreateArgs} args - Arguments to create a Unidade.
     * @example
     * // Create one Unidade
     * const Unidade = await prisma.unidade.create({
     *   data: {
     *     // ... data to create a Unidade
     *   }
     * })
     * 
     */
    create<T extends UnidadeCreateArgs>(args: SelectSubset<T, UnidadeCreateArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Unidades.
     * @param {UnidadeCreateManyArgs} args - Arguments to create many Unidades.
     * @example
     * // Create many Unidades
     * const unidade = await prisma.unidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnidadeCreateManyArgs>(args?: SelectSubset<T, UnidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Unidades and returns the data saved in the database.
     * @param {UnidadeCreateManyAndReturnArgs} args - Arguments to create many Unidades.
     * @example
     * // Create many Unidades
     * const unidade = await prisma.unidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Unidades and only return the `id`
     * const unidadeWithIdOnly = await prisma.unidade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, UnidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unidade.
     * @param {UnidadeDeleteArgs} args - Arguments to delete one Unidade.
     * @example
     * // Delete one Unidade
     * const Unidade = await prisma.unidade.delete({
     *   where: {
     *     // ... filter to delete one Unidade
     *   }
     * })
     * 
     */
    delete<T extends UnidadeDeleteArgs>(args: SelectSubset<T, UnidadeDeleteArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unidade.
     * @param {UnidadeUpdateArgs} args - Arguments to update one Unidade.
     * @example
     * // Update one Unidade
     * const unidade = await prisma.unidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnidadeUpdateArgs>(args: SelectSubset<T, UnidadeUpdateArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Unidades.
     * @param {UnidadeDeleteManyArgs} args - Arguments to filter Unidades to delete.
     * @example
     * // Delete a few Unidades
     * const { count } = await prisma.unidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnidadeDeleteManyArgs>(args?: SelectSubset<T, UnidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unidades
     * const unidade = await prisma.unidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnidadeUpdateManyArgs>(args: SelectSubset<T, UnidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unidade.
     * @param {UnidadeUpsertArgs} args - Arguments to update or create a Unidade.
     * @example
     * // Update or create a Unidade
     * const unidade = await prisma.unidade.upsert({
     *   create: {
     *     // ... data to create a Unidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unidade we want to update
     *   }
     * })
     */
    upsert<T extends UnidadeUpsertArgs>(args: SelectSubset<T, UnidadeUpsertArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Unidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeCountArgs} args - Arguments to filter Unidades to count.
     * @example
     * // Count the number of Unidades
     * const count = await prisma.unidade.count({
     *   where: {
     *     // ... the filter for the Unidades we want to count
     *   }
     * })
    **/
    count<T extends UnidadeCountArgs>(
      args?: Subset<T, UnidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnidadeAggregateArgs>(args: Subset<T, UnidadeAggregateArgs>): Prisma.PrismaPromise<GetUnidadeAggregateType<T>>

    /**
     * Group by Unidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnidadeGroupByArgs['orderBy'] }
        : { orderBy?: UnidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unidade model
   */
  readonly fields: UnidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bloco<T extends BlocoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlocoDefaultArgs<ExtArgs>>): Prisma__BlocoClient<$Result.GetResult<Prisma.$BlocoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    moradores<T extends Unidade$moradoresArgs<ExtArgs> = {}>(args?: Subset<T, Unidade$moradoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    cobrancas<T extends Unidade$cobrancasArgs<ExtArgs> = {}>(args?: Subset<T, Unidade$cobrancasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unidade model
   */ 
  interface UnidadeFieldRefs {
    readonly id: FieldRef<"Unidade", 'String'>
    readonly numero: FieldRef<"Unidade", 'String'>
    readonly blocoId: FieldRef<"Unidade", 'String'>
    readonly createdAt: FieldRef<"Unidade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unidade findUnique
   */
  export type UnidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * Filter, which Unidade to fetch.
     */
    where: UnidadeWhereUniqueInput
  }

  /**
   * Unidade findUniqueOrThrow
   */
  export type UnidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * Filter, which Unidade to fetch.
     */
    where: UnidadeWhereUniqueInput
  }

  /**
   * Unidade findFirst
   */
  export type UnidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * Filter, which Unidade to fetch.
     */
    where?: UnidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unidades to fetch.
     */
    orderBy?: UnidadeOrderByWithRelationInput | UnidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unidades.
     */
    cursor?: UnidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unidades.
     */
    distinct?: UnidadeScalarFieldEnum | UnidadeScalarFieldEnum[]
  }

  /**
   * Unidade findFirstOrThrow
   */
  export type UnidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * Filter, which Unidade to fetch.
     */
    where?: UnidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unidades to fetch.
     */
    orderBy?: UnidadeOrderByWithRelationInput | UnidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Unidades.
     */
    cursor?: UnidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Unidades.
     */
    distinct?: UnidadeScalarFieldEnum | UnidadeScalarFieldEnum[]
  }

  /**
   * Unidade findMany
   */
  export type UnidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * Filter, which Unidades to fetch.
     */
    where?: UnidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Unidades to fetch.
     */
    orderBy?: UnidadeOrderByWithRelationInput | UnidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Unidades.
     */
    cursor?: UnidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Unidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Unidades.
     */
    skip?: number
    distinct?: UnidadeScalarFieldEnum | UnidadeScalarFieldEnum[]
  }

  /**
   * Unidade create
   */
  export type UnidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a Unidade.
     */
    data: XOR<UnidadeCreateInput, UnidadeUncheckedCreateInput>
  }

  /**
   * Unidade createMany
   */
  export type UnidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Unidades.
     */
    data: UnidadeCreateManyInput | UnidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unidade createManyAndReturn
   */
  export type UnidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Unidades.
     */
    data: UnidadeCreateManyInput | UnidadeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unidade update
   */
  export type UnidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a Unidade.
     */
    data: XOR<UnidadeUpdateInput, UnidadeUncheckedUpdateInput>
    /**
     * Choose, which Unidade to update.
     */
    where: UnidadeWhereUniqueInput
  }

  /**
   * Unidade updateMany
   */
  export type UnidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Unidades.
     */
    data: XOR<UnidadeUpdateManyMutationInput, UnidadeUncheckedUpdateManyInput>
    /**
     * Filter which Unidades to update
     */
    where?: UnidadeWhereInput
  }

  /**
   * Unidade upsert
   */
  export type UnidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the Unidade to update in case it exists.
     */
    where: UnidadeWhereUniqueInput
    /**
     * In case the Unidade found by the `where` argument doesn't exist, create a new Unidade with this data.
     */
    create: XOR<UnidadeCreateInput, UnidadeUncheckedCreateInput>
    /**
     * In case the Unidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnidadeUpdateInput, UnidadeUncheckedUpdateInput>
  }

  /**
   * Unidade delete
   */
  export type UnidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
    /**
     * Filter which Unidade to delete.
     */
    where: UnidadeWhereUniqueInput
  }

  /**
   * Unidade deleteMany
   */
  export type UnidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unidades to delete
     */
    where?: UnidadeWhereInput
  }

  /**
   * Unidade.moradores
   */
  export type Unidade$moradoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Unidade.cobrancas
   */
  export type Unidade$cobrancasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    where?: CobrancaWhereInput
    orderBy?: CobrancaOrderByWithRelationInput | CobrancaOrderByWithRelationInput[]
    cursor?: CobrancaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CobrancaScalarFieldEnum | CobrancaScalarFieldEnum[]
  }

  /**
   * Unidade without action
   */
  export type UnidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unidade
     */
    select?: UnidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeInclude<ExtArgs> | null
  }


  /**
   * Model ConfigReserva
   */

  export type AggregateConfigReserva = {
    _count: ConfigReservaCountAggregateOutputType | null
    _avg: ConfigReservaAvgAggregateOutputType | null
    _sum: ConfigReservaSumAggregateOutputType | null
    _min: ConfigReservaMinAggregateOutputType | null
    _max: ConfigReservaMaxAggregateOutputType | null
  }

  export type ConfigReservaAvgAggregateOutputType = {
    limitePorMes: number | null
    antecedenciaDias: number | null
  }

  export type ConfigReservaSumAggregateOutputType = {
    limitePorMes: number | null
    antecedenciaDias: number | null
  }

  export type ConfigReservaMinAggregateOutputType = {
    id: string | null
    condominioId: string | null
    limitePorMes: number | null
    antecedenciaDias: number | null
    horarioInicio: string | null
    horarioFim: string | null
  }

  export type ConfigReservaMaxAggregateOutputType = {
    id: string | null
    condominioId: string | null
    limitePorMes: number | null
    antecedenciaDias: number | null
    horarioInicio: string | null
    horarioFim: string | null
  }

  export type ConfigReservaCountAggregateOutputType = {
    id: number
    condominioId: number
    limitePorMes: number
    antecedenciaDias: number
    horarioInicio: number
    horarioFim: number
    _all: number
  }


  export type ConfigReservaAvgAggregateInputType = {
    limitePorMes?: true
    antecedenciaDias?: true
  }

  export type ConfigReservaSumAggregateInputType = {
    limitePorMes?: true
    antecedenciaDias?: true
  }

  export type ConfigReservaMinAggregateInputType = {
    id?: true
    condominioId?: true
    limitePorMes?: true
    antecedenciaDias?: true
    horarioInicio?: true
    horarioFim?: true
  }

  export type ConfigReservaMaxAggregateInputType = {
    id?: true
    condominioId?: true
    limitePorMes?: true
    antecedenciaDias?: true
    horarioInicio?: true
    horarioFim?: true
  }

  export type ConfigReservaCountAggregateInputType = {
    id?: true
    condominioId?: true
    limitePorMes?: true
    antecedenciaDias?: true
    horarioInicio?: true
    horarioFim?: true
    _all?: true
  }

  export type ConfigReservaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigReserva to aggregate.
     */
    where?: ConfigReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigReservas to fetch.
     */
    orderBy?: ConfigReservaOrderByWithRelationInput | ConfigReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigReservas
    **/
    _count?: true | ConfigReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigReservaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigReservaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigReservaMaxAggregateInputType
  }

  export type GetConfigReservaAggregateType<T extends ConfigReservaAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigReserva[P]>
      : GetScalarType<T[P], AggregateConfigReserva[P]>
  }




  export type ConfigReservaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigReservaWhereInput
    orderBy?: ConfigReservaOrderByWithAggregationInput | ConfigReservaOrderByWithAggregationInput[]
    by: ConfigReservaScalarFieldEnum[] | ConfigReservaScalarFieldEnum
    having?: ConfigReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigReservaCountAggregateInputType | true
    _avg?: ConfigReservaAvgAggregateInputType
    _sum?: ConfigReservaSumAggregateInputType
    _min?: ConfigReservaMinAggregateInputType
    _max?: ConfigReservaMaxAggregateInputType
  }

  export type ConfigReservaGroupByOutputType = {
    id: string
    condominioId: string
    limitePorMes: number
    antecedenciaDias: number
    horarioInicio: string | null
    horarioFim: string | null
    _count: ConfigReservaCountAggregateOutputType | null
    _avg: ConfigReservaAvgAggregateOutputType | null
    _sum: ConfigReservaSumAggregateOutputType | null
    _min: ConfigReservaMinAggregateOutputType | null
    _max: ConfigReservaMaxAggregateOutputType | null
  }

  type GetConfigReservaGroupByPayload<T extends ConfigReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigReservaGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigReservaGroupByOutputType[P]>
        }
      >
    >


  export type ConfigReservaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    condominioId?: boolean
    limitePorMes?: boolean
    antecedenciaDias?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configReserva"]>

  export type ConfigReservaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    condominioId?: boolean
    limitePorMes?: boolean
    antecedenciaDias?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configReserva"]>

  export type ConfigReservaSelectScalar = {
    id?: boolean
    condominioId?: boolean
    limitePorMes?: boolean
    antecedenciaDias?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
  }

  export type ConfigReservaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
  }
  export type ConfigReservaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condominio?: boolean | CondominioDefaultArgs<ExtArgs>
  }

  export type $ConfigReservaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigReserva"
    objects: {
      condominio: Prisma.$CondominioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      condominioId: string
      limitePorMes: number
      antecedenciaDias: number
      horarioInicio: string | null
      horarioFim: string | null
    }, ExtArgs["result"]["configReserva"]>
    composites: {}
  }

  type ConfigReservaGetPayload<S extends boolean | null | undefined | ConfigReservaDefaultArgs> = $Result.GetResult<Prisma.$ConfigReservaPayload, S>

  type ConfigReservaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigReservaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigReservaCountAggregateInputType | true
    }

  export interface ConfigReservaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigReserva'], meta: { name: 'ConfigReserva' } }
    /**
     * Find zero or one ConfigReserva that matches the filter.
     * @param {ConfigReservaFindUniqueArgs} args - Arguments to find a ConfigReserva
     * @example
     * // Get one ConfigReserva
     * const configReserva = await prisma.configReserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigReservaFindUniqueArgs>(args: SelectSubset<T, ConfigReservaFindUniqueArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfigReserva that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigReservaFindUniqueOrThrowArgs} args - Arguments to find a ConfigReserva
     * @example
     * // Get one ConfigReserva
     * const configReserva = await prisma.configReserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigReservaFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigReservaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfigReserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaFindFirstArgs} args - Arguments to find a ConfigReserva
     * @example
     * // Get one ConfigReserva
     * const configReserva = await prisma.configReserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigReservaFindFirstArgs>(args?: SelectSubset<T, ConfigReservaFindFirstArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfigReserva that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaFindFirstOrThrowArgs} args - Arguments to find a ConfigReserva
     * @example
     * // Get one ConfigReserva
     * const configReserva = await prisma.configReserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigReservaFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigReservaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfigReservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigReservas
     * const configReservas = await prisma.configReserva.findMany()
     * 
     * // Get first 10 ConfigReservas
     * const configReservas = await prisma.configReserva.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configReservaWithIdOnly = await prisma.configReserva.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigReservaFindManyArgs>(args?: SelectSubset<T, ConfigReservaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfigReserva.
     * @param {ConfigReservaCreateArgs} args - Arguments to create a ConfigReserva.
     * @example
     * // Create one ConfigReserva
     * const ConfigReserva = await prisma.configReserva.create({
     *   data: {
     *     // ... data to create a ConfigReserva
     *   }
     * })
     * 
     */
    create<T extends ConfigReservaCreateArgs>(args: SelectSubset<T, ConfigReservaCreateArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfigReservas.
     * @param {ConfigReservaCreateManyArgs} args - Arguments to create many ConfigReservas.
     * @example
     * // Create many ConfigReservas
     * const configReserva = await prisma.configReserva.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigReservaCreateManyArgs>(args?: SelectSubset<T, ConfigReservaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigReservas and returns the data saved in the database.
     * @param {ConfigReservaCreateManyAndReturnArgs} args - Arguments to create many ConfigReservas.
     * @example
     * // Create many ConfigReservas
     * const configReserva = await prisma.configReserva.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigReservas and only return the `id`
     * const configReservaWithIdOnly = await prisma.configReserva.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigReservaCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigReservaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfigReserva.
     * @param {ConfigReservaDeleteArgs} args - Arguments to delete one ConfigReserva.
     * @example
     * // Delete one ConfigReserva
     * const ConfigReserva = await prisma.configReserva.delete({
     *   where: {
     *     // ... filter to delete one ConfigReserva
     *   }
     * })
     * 
     */
    delete<T extends ConfigReservaDeleteArgs>(args: SelectSubset<T, ConfigReservaDeleteArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfigReserva.
     * @param {ConfigReservaUpdateArgs} args - Arguments to update one ConfigReserva.
     * @example
     * // Update one ConfigReserva
     * const configReserva = await prisma.configReserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigReservaUpdateArgs>(args: SelectSubset<T, ConfigReservaUpdateArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfigReservas.
     * @param {ConfigReservaDeleteManyArgs} args - Arguments to filter ConfigReservas to delete.
     * @example
     * // Delete a few ConfigReservas
     * const { count } = await prisma.configReserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigReservaDeleteManyArgs>(args?: SelectSubset<T, ConfigReservaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigReservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigReservas
     * const configReserva = await prisma.configReserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigReservaUpdateManyArgs>(args: SelectSubset<T, ConfigReservaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigReserva.
     * @param {ConfigReservaUpsertArgs} args - Arguments to update or create a ConfigReserva.
     * @example
     * // Update or create a ConfigReserva
     * const configReserva = await prisma.configReserva.upsert({
     *   create: {
     *     // ... data to create a ConfigReserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigReserva we want to update
     *   }
     * })
     */
    upsert<T extends ConfigReservaUpsertArgs>(args: SelectSubset<T, ConfigReservaUpsertArgs<ExtArgs>>): Prisma__ConfigReservaClient<$Result.GetResult<Prisma.$ConfigReservaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfigReservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaCountArgs} args - Arguments to filter ConfigReservas to count.
     * @example
     * // Count the number of ConfigReservas
     * const count = await prisma.configReserva.count({
     *   where: {
     *     // ... the filter for the ConfigReservas we want to count
     *   }
     * })
    **/
    count<T extends ConfigReservaCountArgs>(
      args?: Subset<T, ConfigReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigReserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigReservaAggregateArgs>(args: Subset<T, ConfigReservaAggregateArgs>): Prisma.PrismaPromise<GetConfigReservaAggregateType<T>>

    /**
     * Group by ConfigReserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigReservaGroupByArgs['orderBy'] }
        : { orderBy?: ConfigReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigReserva model
   */
  readonly fields: ConfigReservaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigReserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigReservaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    condominio<T extends CondominioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CondominioDefaultArgs<ExtArgs>>): Prisma__CondominioClient<$Result.GetResult<Prisma.$CondominioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigReserva model
   */ 
  interface ConfigReservaFieldRefs {
    readonly id: FieldRef<"ConfigReserva", 'String'>
    readonly condominioId: FieldRef<"ConfigReserva", 'String'>
    readonly limitePorMes: FieldRef<"ConfigReserva", 'Int'>
    readonly antecedenciaDias: FieldRef<"ConfigReserva", 'Int'>
    readonly horarioInicio: FieldRef<"ConfigReserva", 'String'>
    readonly horarioFim: FieldRef<"ConfigReserva", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConfigReserva findUnique
   */
  export type ConfigReservaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * Filter, which ConfigReserva to fetch.
     */
    where: ConfigReservaWhereUniqueInput
  }

  /**
   * ConfigReserva findUniqueOrThrow
   */
  export type ConfigReservaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * Filter, which ConfigReserva to fetch.
     */
    where: ConfigReservaWhereUniqueInput
  }

  /**
   * ConfigReserva findFirst
   */
  export type ConfigReservaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * Filter, which ConfigReserva to fetch.
     */
    where?: ConfigReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigReservas to fetch.
     */
    orderBy?: ConfigReservaOrderByWithRelationInput | ConfigReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigReservas.
     */
    cursor?: ConfigReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigReservas.
     */
    distinct?: ConfigReservaScalarFieldEnum | ConfigReservaScalarFieldEnum[]
  }

  /**
   * ConfigReserva findFirstOrThrow
   */
  export type ConfigReservaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * Filter, which ConfigReserva to fetch.
     */
    where?: ConfigReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigReservas to fetch.
     */
    orderBy?: ConfigReservaOrderByWithRelationInput | ConfigReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigReservas.
     */
    cursor?: ConfigReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigReservas.
     */
    distinct?: ConfigReservaScalarFieldEnum | ConfigReservaScalarFieldEnum[]
  }

  /**
   * ConfigReserva findMany
   */
  export type ConfigReservaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * Filter, which ConfigReservas to fetch.
     */
    where?: ConfigReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigReservas to fetch.
     */
    orderBy?: ConfigReservaOrderByWithRelationInput | ConfigReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigReservas.
     */
    cursor?: ConfigReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigReservas.
     */
    skip?: number
    distinct?: ConfigReservaScalarFieldEnum | ConfigReservaScalarFieldEnum[]
  }

  /**
   * ConfigReserva create
   */
  export type ConfigReservaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigReserva.
     */
    data: XOR<ConfigReservaCreateInput, ConfigReservaUncheckedCreateInput>
  }

  /**
   * ConfigReserva createMany
   */
  export type ConfigReservaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigReservas.
     */
    data: ConfigReservaCreateManyInput | ConfigReservaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigReserva createManyAndReturn
   */
  export type ConfigReservaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfigReservas.
     */
    data: ConfigReservaCreateManyInput | ConfigReservaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigReserva update
   */
  export type ConfigReservaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigReserva.
     */
    data: XOR<ConfigReservaUpdateInput, ConfigReservaUncheckedUpdateInput>
    /**
     * Choose, which ConfigReserva to update.
     */
    where: ConfigReservaWhereUniqueInput
  }

  /**
   * ConfigReserva updateMany
   */
  export type ConfigReservaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigReservas.
     */
    data: XOR<ConfigReservaUpdateManyMutationInput, ConfigReservaUncheckedUpdateManyInput>
    /**
     * Filter which ConfigReservas to update
     */
    where?: ConfigReservaWhereInput
  }

  /**
   * ConfigReserva upsert
   */
  export type ConfigReservaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigReserva to update in case it exists.
     */
    where: ConfigReservaWhereUniqueInput
    /**
     * In case the ConfigReserva found by the `where` argument doesn't exist, create a new ConfigReserva with this data.
     */
    create: XOR<ConfigReservaCreateInput, ConfigReservaUncheckedCreateInput>
    /**
     * In case the ConfigReserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigReservaUpdateInput, ConfigReservaUncheckedUpdateInput>
  }

  /**
   * ConfigReserva delete
   */
  export type ConfigReservaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
    /**
     * Filter which ConfigReserva to delete.
     */
    where: ConfigReservaWhereUniqueInput
  }

  /**
   * ConfigReserva deleteMany
   */
  export type ConfigReservaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigReservas to delete
     */
    where?: ConfigReservaWhereInput
  }

  /**
   * ConfigReserva without action
   */
  export type ConfigReservaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigReserva
     */
    select?: ConfigReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigReservaInclude<ExtArgs> | null
  }


  /**
   * Model Cobranca
   */

  export type AggregateCobranca = {
    _count: CobrancaCountAggregateOutputType | null
    _avg: CobrancaAvgAggregateOutputType | null
    _sum: CobrancaSumAggregateOutputType | null
    _min: CobrancaMinAggregateOutputType | null
    _max: CobrancaMaxAggregateOutputType | null
  }

  export type CobrancaAvgAggregateOutputType = {
    valor: Decimal | null
  }

  export type CobrancaSumAggregateOutputType = {
    valor: Decimal | null
  }

  export type CobrancaMinAggregateOutputType = {
    id: string | null
    unidadeId: string | null
    mesRef: string | null
    valor: Decimal | null
    status: string | null
    vencimento: Date | null
    boletoUrl: string | null
    linhaDigitavel: string | null
    createdAt: Date | null
  }

  export type CobrancaMaxAggregateOutputType = {
    id: string | null
    unidadeId: string | null
    mesRef: string | null
    valor: Decimal | null
    status: string | null
    vencimento: Date | null
    boletoUrl: string | null
    linhaDigitavel: string | null
    createdAt: Date | null
  }

  export type CobrancaCountAggregateOutputType = {
    id: number
    unidadeId: number
    mesRef: number
    valor: number
    status: number
    vencimento: number
    boletoUrl: number
    linhaDigitavel: number
    createdAt: number
    _all: number
  }


  export type CobrancaAvgAggregateInputType = {
    valor?: true
  }

  export type CobrancaSumAggregateInputType = {
    valor?: true
  }

  export type CobrancaMinAggregateInputType = {
    id?: true
    unidadeId?: true
    mesRef?: true
    valor?: true
    status?: true
    vencimento?: true
    boletoUrl?: true
    linhaDigitavel?: true
    createdAt?: true
  }

  export type CobrancaMaxAggregateInputType = {
    id?: true
    unidadeId?: true
    mesRef?: true
    valor?: true
    status?: true
    vencimento?: true
    boletoUrl?: true
    linhaDigitavel?: true
    createdAt?: true
  }

  export type CobrancaCountAggregateInputType = {
    id?: true
    unidadeId?: true
    mesRef?: true
    valor?: true
    status?: true
    vencimento?: true
    boletoUrl?: true
    linhaDigitavel?: true
    createdAt?: true
    _all?: true
  }

  export type CobrancaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cobranca to aggregate.
     */
    where?: CobrancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cobrancas to fetch.
     */
    orderBy?: CobrancaOrderByWithRelationInput | CobrancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CobrancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cobrancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cobrancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cobrancas
    **/
    _count?: true | CobrancaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CobrancaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CobrancaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CobrancaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CobrancaMaxAggregateInputType
  }

  export type GetCobrancaAggregateType<T extends CobrancaAggregateArgs> = {
        [P in keyof T & keyof AggregateCobranca]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCobranca[P]>
      : GetScalarType<T[P], AggregateCobranca[P]>
  }




  export type CobrancaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CobrancaWhereInput
    orderBy?: CobrancaOrderByWithAggregationInput | CobrancaOrderByWithAggregationInput[]
    by: CobrancaScalarFieldEnum[] | CobrancaScalarFieldEnum
    having?: CobrancaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CobrancaCountAggregateInputType | true
    _avg?: CobrancaAvgAggregateInputType
    _sum?: CobrancaSumAggregateInputType
    _min?: CobrancaMinAggregateInputType
    _max?: CobrancaMaxAggregateInputType
  }

  export type CobrancaGroupByOutputType = {
    id: string
    unidadeId: string
    mesRef: string
    valor: Decimal
    status: string
    vencimento: Date
    boletoUrl: string | null
    linhaDigitavel: string | null
    createdAt: Date
    _count: CobrancaCountAggregateOutputType | null
    _avg: CobrancaAvgAggregateOutputType | null
    _sum: CobrancaSumAggregateOutputType | null
    _min: CobrancaMinAggregateOutputType | null
    _max: CobrancaMaxAggregateOutputType | null
  }

  type GetCobrancaGroupByPayload<T extends CobrancaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CobrancaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CobrancaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CobrancaGroupByOutputType[P]>
            : GetScalarType<T[P], CobrancaGroupByOutputType[P]>
        }
      >
    >


  export type CobrancaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unidadeId?: boolean
    mesRef?: boolean
    valor?: boolean
    status?: boolean
    vencimento?: boolean
    boletoUrl?: boolean
    linhaDigitavel?: boolean
    createdAt?: boolean
    unidade?: boolean | UnidadeDefaultArgs<ExtArgs>
    pagamentos?: boolean | Cobranca$pagamentosArgs<ExtArgs>
    _count?: boolean | CobrancaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cobranca"]>

  export type CobrancaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unidadeId?: boolean
    mesRef?: boolean
    valor?: boolean
    status?: boolean
    vencimento?: boolean
    boletoUrl?: boolean
    linhaDigitavel?: boolean
    createdAt?: boolean
    unidade?: boolean | UnidadeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cobranca"]>

  export type CobrancaSelectScalar = {
    id?: boolean
    unidadeId?: boolean
    mesRef?: boolean
    valor?: boolean
    status?: boolean
    vencimento?: boolean
    boletoUrl?: boolean
    linhaDigitavel?: boolean
    createdAt?: boolean
  }

  export type CobrancaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidade?: boolean | UnidadeDefaultArgs<ExtArgs>
    pagamentos?: boolean | Cobranca$pagamentosArgs<ExtArgs>
    _count?: boolean | CobrancaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CobrancaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidade?: boolean | UnidadeDefaultArgs<ExtArgs>
  }

  export type $CobrancaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cobranca"
    objects: {
      unidade: Prisma.$UnidadePayload<ExtArgs>
      pagamentos: Prisma.$PagamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unidadeId: string
      mesRef: string
      valor: Prisma.Decimal
      status: string
      vencimento: Date
      boletoUrl: string | null
      linhaDigitavel: string | null
      createdAt: Date
    }, ExtArgs["result"]["cobranca"]>
    composites: {}
  }

  type CobrancaGetPayload<S extends boolean | null | undefined | CobrancaDefaultArgs> = $Result.GetResult<Prisma.$CobrancaPayload, S>

  type CobrancaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CobrancaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CobrancaCountAggregateInputType | true
    }

  export interface CobrancaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cobranca'], meta: { name: 'Cobranca' } }
    /**
     * Find zero or one Cobranca that matches the filter.
     * @param {CobrancaFindUniqueArgs} args - Arguments to find a Cobranca
     * @example
     * // Get one Cobranca
     * const cobranca = await prisma.cobranca.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CobrancaFindUniqueArgs>(args: SelectSubset<T, CobrancaFindUniqueArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cobranca that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CobrancaFindUniqueOrThrowArgs} args - Arguments to find a Cobranca
     * @example
     * // Get one Cobranca
     * const cobranca = await prisma.cobranca.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CobrancaFindUniqueOrThrowArgs>(args: SelectSubset<T, CobrancaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cobranca that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaFindFirstArgs} args - Arguments to find a Cobranca
     * @example
     * // Get one Cobranca
     * const cobranca = await prisma.cobranca.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CobrancaFindFirstArgs>(args?: SelectSubset<T, CobrancaFindFirstArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cobranca that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaFindFirstOrThrowArgs} args - Arguments to find a Cobranca
     * @example
     * // Get one Cobranca
     * const cobranca = await prisma.cobranca.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CobrancaFindFirstOrThrowArgs>(args?: SelectSubset<T, CobrancaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cobrancas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cobrancas
     * const cobrancas = await prisma.cobranca.findMany()
     * 
     * // Get first 10 Cobrancas
     * const cobrancas = await prisma.cobranca.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cobrancaWithIdOnly = await prisma.cobranca.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CobrancaFindManyArgs>(args?: SelectSubset<T, CobrancaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cobranca.
     * @param {CobrancaCreateArgs} args - Arguments to create a Cobranca.
     * @example
     * // Create one Cobranca
     * const Cobranca = await prisma.cobranca.create({
     *   data: {
     *     // ... data to create a Cobranca
     *   }
     * })
     * 
     */
    create<T extends CobrancaCreateArgs>(args: SelectSubset<T, CobrancaCreateArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cobrancas.
     * @param {CobrancaCreateManyArgs} args - Arguments to create many Cobrancas.
     * @example
     * // Create many Cobrancas
     * const cobranca = await prisma.cobranca.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CobrancaCreateManyArgs>(args?: SelectSubset<T, CobrancaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cobrancas and returns the data saved in the database.
     * @param {CobrancaCreateManyAndReturnArgs} args - Arguments to create many Cobrancas.
     * @example
     * // Create many Cobrancas
     * const cobranca = await prisma.cobranca.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cobrancas and only return the `id`
     * const cobrancaWithIdOnly = await prisma.cobranca.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CobrancaCreateManyAndReturnArgs>(args?: SelectSubset<T, CobrancaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cobranca.
     * @param {CobrancaDeleteArgs} args - Arguments to delete one Cobranca.
     * @example
     * // Delete one Cobranca
     * const Cobranca = await prisma.cobranca.delete({
     *   where: {
     *     // ... filter to delete one Cobranca
     *   }
     * })
     * 
     */
    delete<T extends CobrancaDeleteArgs>(args: SelectSubset<T, CobrancaDeleteArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cobranca.
     * @param {CobrancaUpdateArgs} args - Arguments to update one Cobranca.
     * @example
     * // Update one Cobranca
     * const cobranca = await prisma.cobranca.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CobrancaUpdateArgs>(args: SelectSubset<T, CobrancaUpdateArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cobrancas.
     * @param {CobrancaDeleteManyArgs} args - Arguments to filter Cobrancas to delete.
     * @example
     * // Delete a few Cobrancas
     * const { count } = await prisma.cobranca.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CobrancaDeleteManyArgs>(args?: SelectSubset<T, CobrancaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cobrancas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cobrancas
     * const cobranca = await prisma.cobranca.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CobrancaUpdateManyArgs>(args: SelectSubset<T, CobrancaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cobranca.
     * @param {CobrancaUpsertArgs} args - Arguments to update or create a Cobranca.
     * @example
     * // Update or create a Cobranca
     * const cobranca = await prisma.cobranca.upsert({
     *   create: {
     *     // ... data to create a Cobranca
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cobranca we want to update
     *   }
     * })
     */
    upsert<T extends CobrancaUpsertArgs>(args: SelectSubset<T, CobrancaUpsertArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cobrancas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaCountArgs} args - Arguments to filter Cobrancas to count.
     * @example
     * // Count the number of Cobrancas
     * const count = await prisma.cobranca.count({
     *   where: {
     *     // ... the filter for the Cobrancas we want to count
     *   }
     * })
    **/
    count<T extends CobrancaCountArgs>(
      args?: Subset<T, CobrancaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CobrancaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cobranca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CobrancaAggregateArgs>(args: Subset<T, CobrancaAggregateArgs>): Prisma.PrismaPromise<GetCobrancaAggregateType<T>>

    /**
     * Group by Cobranca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CobrancaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CobrancaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CobrancaGroupByArgs['orderBy'] }
        : { orderBy?: CobrancaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CobrancaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCobrancaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cobranca model
   */
  readonly fields: CobrancaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cobranca.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CobrancaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unidade<T extends UnidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnidadeDefaultArgs<ExtArgs>>): Prisma__UnidadeClient<$Result.GetResult<Prisma.$UnidadePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pagamentos<T extends Cobranca$pagamentosArgs<ExtArgs> = {}>(args?: Subset<T, Cobranca$pagamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cobranca model
   */ 
  interface CobrancaFieldRefs {
    readonly id: FieldRef<"Cobranca", 'String'>
    readonly unidadeId: FieldRef<"Cobranca", 'String'>
    readonly mesRef: FieldRef<"Cobranca", 'String'>
    readonly valor: FieldRef<"Cobranca", 'Decimal'>
    readonly status: FieldRef<"Cobranca", 'String'>
    readonly vencimento: FieldRef<"Cobranca", 'DateTime'>
    readonly boletoUrl: FieldRef<"Cobranca", 'String'>
    readonly linhaDigitavel: FieldRef<"Cobranca", 'String'>
    readonly createdAt: FieldRef<"Cobranca", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cobranca findUnique
   */
  export type CobrancaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * Filter, which Cobranca to fetch.
     */
    where: CobrancaWhereUniqueInput
  }

  /**
   * Cobranca findUniqueOrThrow
   */
  export type CobrancaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * Filter, which Cobranca to fetch.
     */
    where: CobrancaWhereUniqueInput
  }

  /**
   * Cobranca findFirst
   */
  export type CobrancaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * Filter, which Cobranca to fetch.
     */
    where?: CobrancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cobrancas to fetch.
     */
    orderBy?: CobrancaOrderByWithRelationInput | CobrancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cobrancas.
     */
    cursor?: CobrancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cobrancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cobrancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cobrancas.
     */
    distinct?: CobrancaScalarFieldEnum | CobrancaScalarFieldEnum[]
  }

  /**
   * Cobranca findFirstOrThrow
   */
  export type CobrancaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * Filter, which Cobranca to fetch.
     */
    where?: CobrancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cobrancas to fetch.
     */
    orderBy?: CobrancaOrderByWithRelationInput | CobrancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cobrancas.
     */
    cursor?: CobrancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cobrancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cobrancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cobrancas.
     */
    distinct?: CobrancaScalarFieldEnum | CobrancaScalarFieldEnum[]
  }

  /**
   * Cobranca findMany
   */
  export type CobrancaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * Filter, which Cobrancas to fetch.
     */
    where?: CobrancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cobrancas to fetch.
     */
    orderBy?: CobrancaOrderByWithRelationInput | CobrancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cobrancas.
     */
    cursor?: CobrancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cobrancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cobrancas.
     */
    skip?: number
    distinct?: CobrancaScalarFieldEnum | CobrancaScalarFieldEnum[]
  }

  /**
   * Cobranca create
   */
  export type CobrancaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * The data needed to create a Cobranca.
     */
    data: XOR<CobrancaCreateInput, CobrancaUncheckedCreateInput>
  }

  /**
   * Cobranca createMany
   */
  export type CobrancaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cobrancas.
     */
    data: CobrancaCreateManyInput | CobrancaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cobranca createManyAndReturn
   */
  export type CobrancaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cobrancas.
     */
    data: CobrancaCreateManyInput | CobrancaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cobranca update
   */
  export type CobrancaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * The data needed to update a Cobranca.
     */
    data: XOR<CobrancaUpdateInput, CobrancaUncheckedUpdateInput>
    /**
     * Choose, which Cobranca to update.
     */
    where: CobrancaWhereUniqueInput
  }

  /**
   * Cobranca updateMany
   */
  export type CobrancaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cobrancas.
     */
    data: XOR<CobrancaUpdateManyMutationInput, CobrancaUncheckedUpdateManyInput>
    /**
     * Filter which Cobrancas to update
     */
    where?: CobrancaWhereInput
  }

  /**
   * Cobranca upsert
   */
  export type CobrancaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * The filter to search for the Cobranca to update in case it exists.
     */
    where: CobrancaWhereUniqueInput
    /**
     * In case the Cobranca found by the `where` argument doesn't exist, create a new Cobranca with this data.
     */
    create: XOR<CobrancaCreateInput, CobrancaUncheckedCreateInput>
    /**
     * In case the Cobranca was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CobrancaUpdateInput, CobrancaUncheckedUpdateInput>
  }

  /**
   * Cobranca delete
   */
  export type CobrancaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
    /**
     * Filter which Cobranca to delete.
     */
    where: CobrancaWhereUniqueInput
  }

  /**
   * Cobranca deleteMany
   */
  export type CobrancaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cobrancas to delete
     */
    where?: CobrancaWhereInput
  }

  /**
   * Cobranca.pagamentos
   */
  export type Cobranca$pagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Cobranca without action
   */
  export type CobrancaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cobranca
     */
    select?: CobrancaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CobrancaInclude<ExtArgs> | null
  }


  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    valor: Decimal | null
  }

  export type PagamentoSumAggregateOutputType = {
    valor: Decimal | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: string | null
    cobrancaId: string | null
    valor: Decimal | null
    pagoEm: Date | null
    comprovanteUrl: string | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: string | null
    cobrancaId: string | null
    valor: Decimal | null
    pagoEm: Date | null
    comprovanteUrl: string | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    cobrancaId: number
    valor: number
    pagoEm: number
    comprovanteUrl: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    valor?: true
  }

  export type PagamentoSumAggregateInputType = {
    valor?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    cobrancaId?: true
    valor?: true
    pagoEm?: true
    comprovanteUrl?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    cobrancaId?: true
    valor?: true
    pagoEm?: true
    comprovanteUrl?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    cobrancaId?: true
    valor?: true
    pagoEm?: true
    comprovanteUrl?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: string
    cobrancaId: string
    valor: Decimal
    pagoEm: Date
    comprovanteUrl: string | null
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cobrancaId?: boolean
    valor?: boolean
    pagoEm?: boolean
    comprovanteUrl?: boolean
    cobranca?: boolean | CobrancaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cobrancaId?: boolean
    valor?: boolean
    pagoEm?: boolean
    comprovanteUrl?: boolean
    cobranca?: boolean | CobrancaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectScalar = {
    id?: boolean
    cobrancaId?: boolean
    valor?: boolean
    pagoEm?: boolean
    comprovanteUrl?: boolean
  }

  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cobranca?: boolean | CobrancaDefaultArgs<ExtArgs>
  }
  export type PagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cobranca?: boolean | CobrancaDefaultArgs<ExtArgs>
  }

  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      cobranca: Prisma.$CobrancaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cobrancaId: string
      valor: Prisma.Decimal
      pagoEm: Date
      comprovanteUrl: string | null
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }

  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagamentoFindUniqueArgs>(args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pagamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagamentoFindFirstArgs>(args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagamentoFindManyArgs>(args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
     */
    create<T extends PagamentoCreateArgs>(args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagamentos.
     * @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagamentoCreateManyArgs>(args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagamentos and returns the data saved in the database.
     * @param {PagamentoCreateManyAndReturnArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagamentos and only return the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
     */
    delete<T extends PagamentoDeleteArgs>(args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagamentoUpdateArgs>(args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagamentoDeleteManyArgs>(args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagamentoUpdateManyArgs>(args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
     */
    upsert<T extends PagamentoUpsertArgs>(args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cobranca<T extends CobrancaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CobrancaDefaultArgs<ExtArgs>>): Prisma__CobrancaClient<$Result.GetResult<Prisma.$CobrancaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagamento model
   */ 
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'String'>
    readonly cobrancaId: FieldRef<"Pagamento", 'String'>
    readonly valor: FieldRef<"Pagamento", 'Decimal'>
    readonly pagoEm: FieldRef<"Pagamento", 'DateTime'>
    readonly comprovanteUrl: FieldRef<"Pagamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }

  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento createManyAndReturn
   */
  export type PagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }

  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
  }


  /**
   * Model LogAuditoria
   */

  export type AggregateLogAuditoria = {
    _count: LogAuditoriaCountAggregateOutputType | null
    _min: LogAuditoriaMinAggregateOutputType | null
    _max: LogAuditoriaMaxAggregateOutputType | null
  }

  export type LogAuditoriaMinAggregateOutputType = {
    id: string | null
    acao: string | null
    entidade: string | null
    entidadeId: string | null
    before: string | null
    after: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LogAuditoriaMaxAggregateOutputType = {
    id: string | null
    acao: string | null
    entidade: string | null
    entidadeId: string | null
    before: string | null
    after: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LogAuditoriaCountAggregateOutputType = {
    id: number
    acao: number
    entidade: number
    entidadeId: number
    before: number
    after: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LogAuditoriaMinAggregateInputType = {
    id?: true
    acao?: true
    entidade?: true
    entidadeId?: true
    before?: true
    after?: true
    userId?: true
    createdAt?: true
  }

  export type LogAuditoriaMaxAggregateInputType = {
    id?: true
    acao?: true
    entidade?: true
    entidadeId?: true
    before?: true
    after?: true
    userId?: true
    createdAt?: true
  }

  export type LogAuditoriaCountAggregateInputType = {
    id?: true
    acao?: true
    entidade?: true
    entidadeId?: true
    before?: true
    after?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LogAuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogAuditoria to aggregate.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogAuditorias
    **/
    _count?: true | LogAuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogAuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogAuditoriaMaxAggregateInputType
  }

  export type GetLogAuditoriaAggregateType<T extends LogAuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateLogAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogAuditoria[P]>
      : GetScalarType<T[P], AggregateLogAuditoria[P]>
  }




  export type LogAuditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogAuditoriaWhereInput
    orderBy?: LogAuditoriaOrderByWithAggregationInput | LogAuditoriaOrderByWithAggregationInput[]
    by: LogAuditoriaScalarFieldEnum[] | LogAuditoriaScalarFieldEnum
    having?: LogAuditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogAuditoriaCountAggregateInputType | true
    _min?: LogAuditoriaMinAggregateInputType
    _max?: LogAuditoriaMaxAggregateInputType
  }

  export type LogAuditoriaGroupByOutputType = {
    id: string
    acao: string
    entidade: string
    entidadeId: string | null
    before: string | null
    after: string | null
    userId: string | null
    createdAt: Date
    _count: LogAuditoriaCountAggregateOutputType | null
    _min: LogAuditoriaMinAggregateOutputType | null
    _max: LogAuditoriaMaxAggregateOutputType | null
  }

  type GetLogAuditoriaGroupByPayload<T extends LogAuditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogAuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogAuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogAuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], LogAuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type LogAuditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acao?: boolean
    entidade?: boolean
    entidadeId?: boolean
    before?: boolean
    after?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["logAuditoria"]>

  export type LogAuditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acao?: boolean
    entidade?: boolean
    entidadeId?: boolean
    before?: boolean
    after?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["logAuditoria"]>

  export type LogAuditoriaSelectScalar = {
    id?: boolean
    acao?: boolean
    entidade?: boolean
    entidadeId?: boolean
    before?: boolean
    after?: boolean
    userId?: boolean
    createdAt?: boolean
  }


  export type $LogAuditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogAuditoria"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      acao: string
      entidade: string
      entidadeId: string | null
      before: string | null
      after: string | null
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["logAuditoria"]>
    composites: {}
  }

  type LogAuditoriaGetPayload<S extends boolean | null | undefined | LogAuditoriaDefaultArgs> = $Result.GetResult<Prisma.$LogAuditoriaPayload, S>

  type LogAuditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogAuditoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogAuditoriaCountAggregateInputType | true
    }

  export interface LogAuditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogAuditoria'], meta: { name: 'LogAuditoria' } }
    /**
     * Find zero or one LogAuditoria that matches the filter.
     * @param {LogAuditoriaFindUniqueArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogAuditoriaFindUniqueArgs>(args: SelectSubset<T, LogAuditoriaFindUniqueArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogAuditoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogAuditoriaFindUniqueOrThrowArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogAuditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, LogAuditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogAuditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaFindFirstArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogAuditoriaFindFirstArgs>(args?: SelectSubset<T, LogAuditoriaFindFirstArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogAuditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaFindFirstOrThrowArgs} args - Arguments to find a LogAuditoria
     * @example
     * // Get one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogAuditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, LogAuditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogAuditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogAuditorias
     * const logAuditorias = await prisma.logAuditoria.findMany()
     * 
     * // Get first 10 LogAuditorias
     * const logAuditorias = await prisma.logAuditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logAuditoriaWithIdOnly = await prisma.logAuditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogAuditoriaFindManyArgs>(args?: SelectSubset<T, LogAuditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogAuditoria.
     * @param {LogAuditoriaCreateArgs} args - Arguments to create a LogAuditoria.
     * @example
     * // Create one LogAuditoria
     * const LogAuditoria = await prisma.logAuditoria.create({
     *   data: {
     *     // ... data to create a LogAuditoria
     *   }
     * })
     * 
     */
    create<T extends LogAuditoriaCreateArgs>(args: SelectSubset<T, LogAuditoriaCreateArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogAuditorias.
     * @param {LogAuditoriaCreateManyArgs} args - Arguments to create many LogAuditorias.
     * @example
     * // Create many LogAuditorias
     * const logAuditoria = await prisma.logAuditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogAuditoriaCreateManyArgs>(args?: SelectSubset<T, LogAuditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogAuditorias and returns the data saved in the database.
     * @param {LogAuditoriaCreateManyAndReturnArgs} args - Arguments to create many LogAuditorias.
     * @example
     * // Create many LogAuditorias
     * const logAuditoria = await prisma.logAuditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogAuditorias and only return the `id`
     * const logAuditoriaWithIdOnly = await prisma.logAuditoria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogAuditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, LogAuditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogAuditoria.
     * @param {LogAuditoriaDeleteArgs} args - Arguments to delete one LogAuditoria.
     * @example
     * // Delete one LogAuditoria
     * const LogAuditoria = await prisma.logAuditoria.delete({
     *   where: {
     *     // ... filter to delete one LogAuditoria
     *   }
     * })
     * 
     */
    delete<T extends LogAuditoriaDeleteArgs>(args: SelectSubset<T, LogAuditoriaDeleteArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogAuditoria.
     * @param {LogAuditoriaUpdateArgs} args - Arguments to update one LogAuditoria.
     * @example
     * // Update one LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogAuditoriaUpdateArgs>(args: SelectSubset<T, LogAuditoriaUpdateArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogAuditorias.
     * @param {LogAuditoriaDeleteManyArgs} args - Arguments to filter LogAuditorias to delete.
     * @example
     * // Delete a few LogAuditorias
     * const { count } = await prisma.logAuditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogAuditoriaDeleteManyArgs>(args?: SelectSubset<T, LogAuditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogAuditorias
     * const logAuditoria = await prisma.logAuditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogAuditoriaUpdateManyArgs>(args: SelectSubset<T, LogAuditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogAuditoria.
     * @param {LogAuditoriaUpsertArgs} args - Arguments to update or create a LogAuditoria.
     * @example
     * // Update or create a LogAuditoria
     * const logAuditoria = await prisma.logAuditoria.upsert({
     *   create: {
     *     // ... data to create a LogAuditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogAuditoria we want to update
     *   }
     * })
     */
    upsert<T extends LogAuditoriaUpsertArgs>(args: SelectSubset<T, LogAuditoriaUpsertArgs<ExtArgs>>): Prisma__LogAuditoriaClient<$Result.GetResult<Prisma.$LogAuditoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaCountArgs} args - Arguments to filter LogAuditorias to count.
     * @example
     * // Count the number of LogAuditorias
     * const count = await prisma.logAuditoria.count({
     *   where: {
     *     // ... the filter for the LogAuditorias we want to count
     *   }
     * })
    **/
    count<T extends LogAuditoriaCountArgs>(
      args?: Subset<T, LogAuditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogAuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAuditoriaAggregateArgs>(args: Subset<T, LogAuditoriaAggregateArgs>): Prisma.PrismaPromise<GetLogAuditoriaAggregateType<T>>

    /**
     * Group by LogAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogAuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogAuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: LogAuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogAuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogAuditoria model
   */
  readonly fields: LogAuditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogAuditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogAuditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogAuditoria model
   */ 
  interface LogAuditoriaFieldRefs {
    readonly id: FieldRef<"LogAuditoria", 'String'>
    readonly acao: FieldRef<"LogAuditoria", 'String'>
    readonly entidade: FieldRef<"LogAuditoria", 'String'>
    readonly entidadeId: FieldRef<"LogAuditoria", 'String'>
    readonly before: FieldRef<"LogAuditoria", 'String'>
    readonly after: FieldRef<"LogAuditoria", 'String'>
    readonly userId: FieldRef<"LogAuditoria", 'String'>
    readonly createdAt: FieldRef<"LogAuditoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogAuditoria findUnique
   */
  export type LogAuditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria findUniqueOrThrow
   */
  export type LogAuditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria findFirst
   */
  export type LogAuditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogAuditorias.
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogAuditorias.
     */
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * LogAuditoria findFirstOrThrow
   */
  export type LogAuditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Filter, which LogAuditoria to fetch.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogAuditorias.
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogAuditorias.
     */
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * LogAuditoria findMany
   */
  export type LogAuditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Filter, which LogAuditorias to fetch.
     */
    where?: LogAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogAuditorias to fetch.
     */
    orderBy?: LogAuditoriaOrderByWithRelationInput | LogAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogAuditorias.
     */
    cursor?: LogAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogAuditorias.
     */
    skip?: number
    distinct?: LogAuditoriaScalarFieldEnum | LogAuditoriaScalarFieldEnum[]
  }

  /**
   * LogAuditoria create
   */
  export type LogAuditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * The data needed to create a LogAuditoria.
     */
    data: XOR<LogAuditoriaCreateInput, LogAuditoriaUncheckedCreateInput>
  }

  /**
   * LogAuditoria createMany
   */
  export type LogAuditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogAuditorias.
     */
    data: LogAuditoriaCreateManyInput | LogAuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogAuditoria createManyAndReturn
   */
  export type LogAuditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogAuditorias.
     */
    data: LogAuditoriaCreateManyInput | LogAuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogAuditoria update
   */
  export type LogAuditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * The data needed to update a LogAuditoria.
     */
    data: XOR<LogAuditoriaUpdateInput, LogAuditoriaUncheckedUpdateInput>
    /**
     * Choose, which LogAuditoria to update.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria updateMany
   */
  export type LogAuditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogAuditorias.
     */
    data: XOR<LogAuditoriaUpdateManyMutationInput, LogAuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which LogAuditorias to update
     */
    where?: LogAuditoriaWhereInput
  }

  /**
   * LogAuditoria upsert
   */
  export type LogAuditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * The filter to search for the LogAuditoria to update in case it exists.
     */
    where: LogAuditoriaWhereUniqueInput
    /**
     * In case the LogAuditoria found by the `where` argument doesn't exist, create a new LogAuditoria with this data.
     */
    create: XOR<LogAuditoriaCreateInput, LogAuditoriaUncheckedCreateInput>
    /**
     * In case the LogAuditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogAuditoriaUpdateInput, LogAuditoriaUncheckedUpdateInput>
  }

  /**
   * LogAuditoria delete
   */
  export type LogAuditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
    /**
     * Filter which LogAuditoria to delete.
     */
    where: LogAuditoriaWhereUniqueInput
  }

  /**
   * LogAuditoria deleteMany
   */
  export type LogAuditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogAuditorias to delete
     */
    where?: LogAuditoriaWhereInput
  }

  /**
   * LogAuditoria without action
   */
  export type LogAuditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogAuditoria
     */
    select?: LogAuditoriaSelect<ExtArgs> | null
  }


  /**
   * Model Reserva
   */

  export type AggregateReserva = {
    _count: ReservaCountAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  export type ReservaMinAggregateOutputType = {
    id: string | null
    data: Date | null
    horarioInicio: string | null
    horarioFim: string | null
    status: string | null
    cancelReason: string | null
    cancelledById: string | null
    createdAt: Date | null
    areaId: string | null
    moradorId: string | null
  }

  export type ReservaMaxAggregateOutputType = {
    id: string | null
    data: Date | null
    horarioInicio: string | null
    horarioFim: string | null
    status: string | null
    cancelReason: string | null
    cancelledById: string | null
    createdAt: Date | null
    areaId: string | null
    moradorId: string | null
  }

  export type ReservaCountAggregateOutputType = {
    id: number
    data: number
    horarioInicio: number
    horarioFim: number
    status: number
    cancelReason: number
    cancelledById: number
    createdAt: number
    areaId: number
    moradorId: number
    _all: number
  }


  export type ReservaMinAggregateInputType = {
    id?: true
    data?: true
    horarioInicio?: true
    horarioFim?: true
    status?: true
    cancelReason?: true
    cancelledById?: true
    createdAt?: true
    areaId?: true
    moradorId?: true
  }

  export type ReservaMaxAggregateInputType = {
    id?: true
    data?: true
    horarioInicio?: true
    horarioFim?: true
    status?: true
    cancelReason?: true
    cancelledById?: true
    createdAt?: true
    areaId?: true
    moradorId?: true
  }

  export type ReservaCountAggregateInputType = {
    id?: true
    data?: true
    horarioInicio?: true
    horarioFim?: true
    status?: true
    cancelReason?: true
    cancelledById?: true
    createdAt?: true
    areaId?: true
    moradorId?: true
    _all?: true
  }

  export type ReservaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reserva to aggregate.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservas
    **/
    _count?: true | ReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservaMaxAggregateInputType
  }

  export type GetReservaAggregateType<T extends ReservaAggregateArgs> = {
        [P in keyof T & keyof AggregateReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReserva[P]>
      : GetScalarType<T[P], AggregateReserva[P]>
  }




  export type ReservaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithAggregationInput | ReservaOrderByWithAggregationInput[]
    by: ReservaScalarFieldEnum[] | ReservaScalarFieldEnum
    having?: ReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservaCountAggregateInputType | true
    _min?: ReservaMinAggregateInputType
    _max?: ReservaMaxAggregateInputType
  }

  export type ReservaGroupByOutputType = {
    id: string
    data: Date
    horarioInicio: string
    horarioFim: string
    status: string
    cancelReason: string | null
    cancelledById: string | null
    createdAt: Date
    areaId: string
    moradorId: string
    _count: ReservaCountAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  type GetReservaGroupByPayload<T extends ReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservaGroupByOutputType[P]>
            : GetScalarType<T[P], ReservaGroupByOutputType[P]>
        }
      >
    >


  export type ReservaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    status?: boolean
    cancelReason?: boolean
    cancelledById?: boolean
    createdAt?: boolean
    areaId?: boolean
    moradorId?: boolean
    area?: boolean | AreaComumDefaultArgs<ExtArgs>
    morador?: boolean | UserDefaultArgs<ExtArgs>
    cancelledBy?: boolean | Reserva$cancelledByArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    status?: boolean
    cancelReason?: boolean
    cancelledById?: boolean
    createdAt?: boolean
    areaId?: boolean
    moradorId?: boolean
    area?: boolean | AreaComumDefaultArgs<ExtArgs>
    morador?: boolean | UserDefaultArgs<ExtArgs>
    cancelledBy?: boolean | Reserva$cancelledByArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectScalar = {
    id?: boolean
    data?: boolean
    horarioInicio?: boolean
    horarioFim?: boolean
    status?: boolean
    cancelReason?: boolean
    cancelledById?: boolean
    createdAt?: boolean
    areaId?: boolean
    moradorId?: boolean
  }

  export type ReservaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaComumDefaultArgs<ExtArgs>
    morador?: boolean | UserDefaultArgs<ExtArgs>
    cancelledBy?: boolean | Reserva$cancelledByArgs<ExtArgs>
  }
  export type ReservaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaComumDefaultArgs<ExtArgs>
    morador?: boolean | UserDefaultArgs<ExtArgs>
    cancelledBy?: boolean | Reserva$cancelledByArgs<ExtArgs>
  }

  export type $ReservaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reserva"
    objects: {
      area: Prisma.$AreaComumPayload<ExtArgs>
      morador: Prisma.$UserPayload<ExtArgs>
      cancelledBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Date
      horarioInicio: string
      horarioFim: string
      status: string
      cancelReason: string | null
      cancelledById: string | null
      createdAt: Date
      areaId: string
      moradorId: string
    }, ExtArgs["result"]["reserva"]>
    composites: {}
  }

  type ReservaGetPayload<S extends boolean | null | undefined | ReservaDefaultArgs> = $Result.GetResult<Prisma.$ReservaPayload, S>

  type ReservaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservaCountAggregateInputType | true
    }

  export interface ReservaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reserva'], meta: { name: 'Reserva' } }
    /**
     * Find zero or one Reserva that matches the filter.
     * @param {ReservaFindUniqueArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservaFindUniqueArgs>(args: SelectSubset<T, ReservaFindUniqueArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reserva that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservaFindUniqueOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservaFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservaFindFirstArgs>(args?: SelectSubset<T, ReservaFindFirstArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reserva that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservaFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservas
     * const reservas = await prisma.reserva.findMany()
     * 
     * // Get first 10 Reservas
     * const reservas = await prisma.reserva.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservaWithIdOnly = await prisma.reserva.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservaFindManyArgs>(args?: SelectSubset<T, ReservaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reserva.
     * @param {ReservaCreateArgs} args - Arguments to create a Reserva.
     * @example
     * // Create one Reserva
     * const Reserva = await prisma.reserva.create({
     *   data: {
     *     // ... data to create a Reserva
     *   }
     * })
     * 
     */
    create<T extends ReservaCreateArgs>(args: SelectSubset<T, ReservaCreateArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservas.
     * @param {ReservaCreateManyArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reserva = await prisma.reserva.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservaCreateManyArgs>(args?: SelectSubset<T, ReservaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservas and returns the data saved in the database.
     * @param {ReservaCreateManyAndReturnArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reserva = await prisma.reserva.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservas and only return the `id`
     * const reservaWithIdOnly = await prisma.reserva.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservaCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reserva.
     * @param {ReservaDeleteArgs} args - Arguments to delete one Reserva.
     * @example
     * // Delete one Reserva
     * const Reserva = await prisma.reserva.delete({
     *   where: {
     *     // ... filter to delete one Reserva
     *   }
     * })
     * 
     */
    delete<T extends ReservaDeleteArgs>(args: SelectSubset<T, ReservaDeleteArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reserva.
     * @param {ReservaUpdateArgs} args - Arguments to update one Reserva.
     * @example
     * // Update one Reserva
     * const reserva = await prisma.reserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservaUpdateArgs>(args: SelectSubset<T, ReservaUpdateArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservas.
     * @param {ReservaDeleteManyArgs} args - Arguments to filter Reservas to delete.
     * @example
     * // Delete a few Reservas
     * const { count } = await prisma.reserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservaDeleteManyArgs>(args?: SelectSubset<T, ReservaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservas
     * const reserva = await prisma.reserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservaUpdateManyArgs>(args: SelectSubset<T, ReservaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reserva.
     * @param {ReservaUpsertArgs} args - Arguments to update or create a Reserva.
     * @example
     * // Update or create a Reserva
     * const reserva = await prisma.reserva.upsert({
     *   create: {
     *     // ... data to create a Reserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reserva we want to update
     *   }
     * })
     */
    upsert<T extends ReservaUpsertArgs>(args: SelectSubset<T, ReservaUpsertArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaCountArgs} args - Arguments to filter Reservas to count.
     * @example
     * // Count the number of Reservas
     * const count = await prisma.reserva.count({
     *   where: {
     *     // ... the filter for the Reservas we want to count
     *   }
     * })
    **/
    count<T extends ReservaCountArgs>(
      args?: Subset<T, ReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservaAggregateArgs>(args: Subset<T, ReservaAggregateArgs>): Prisma.PrismaPromise<GetReservaAggregateType<T>>

    /**
     * Group by Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservaGroupByArgs['orderBy'] }
        : { orderBy?: ReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reserva model
   */
  readonly fields: ReservaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaComumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaComumDefaultArgs<ExtArgs>>): Prisma__AreaComumClient<$Result.GetResult<Prisma.$AreaComumPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    morador<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cancelledBy<T extends Reserva$cancelledByArgs<ExtArgs> = {}>(args?: Subset<T, Reserva$cancelledByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reserva model
   */ 
  interface ReservaFieldRefs {
    readonly id: FieldRef<"Reserva", 'String'>
    readonly data: FieldRef<"Reserva", 'DateTime'>
    readonly horarioInicio: FieldRef<"Reserva", 'String'>
    readonly horarioFim: FieldRef<"Reserva", 'String'>
    readonly status: FieldRef<"Reserva", 'String'>
    readonly cancelReason: FieldRef<"Reserva", 'String'>
    readonly cancelledById: FieldRef<"Reserva", 'String'>
    readonly createdAt: FieldRef<"Reserva", 'DateTime'>
    readonly areaId: FieldRef<"Reserva", 'String'>
    readonly moradorId: FieldRef<"Reserva", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Reserva findUnique
   */
  export type ReservaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findUniqueOrThrow
   */
  export type ReservaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findFirst
   */
  export type ReservaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva findFirstOrThrow
   */
  export type ReservaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva findMany
   */
  export type ReservaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reservas to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva create
   */
  export type ReservaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The data needed to create a Reserva.
     */
    data: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
  }

  /**
   * Reserva createMany
   */
  export type ReservaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservas.
     */
    data: ReservaCreateManyInput | ReservaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reserva createManyAndReturn
   */
  export type ReservaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reservas.
     */
    data: ReservaCreateManyInput | ReservaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reserva update
   */
  export type ReservaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The data needed to update a Reserva.
     */
    data: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
    /**
     * Choose, which Reserva to update.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva updateMany
   */
  export type ReservaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservas.
     */
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyInput>
    /**
     * Filter which Reservas to update
     */
    where?: ReservaWhereInput
  }

  /**
   * Reserva upsert
   */
  export type ReservaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The filter to search for the Reserva to update in case it exists.
     */
    where: ReservaWhereUniqueInput
    /**
     * In case the Reserva found by the `where` argument doesn't exist, create a new Reserva with this data.
     */
    create: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
    /**
     * In case the Reserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
  }

  /**
   * Reserva delete
   */
  export type ReservaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter which Reserva to delete.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva deleteMany
   */
  export type ReservaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservas to delete
     */
    where?: ReservaWhereInput
  }

  /**
   * Reserva.cancelledBy
   */
  export type Reserva$cancelledByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Reserva without action
   */
  export type ReservaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
  }


  /**
   * Model VisitorLog
   */

  export type AggregateVisitorLog = {
    _count: VisitorLogCountAggregateOutputType | null
    _min: VisitorLogMinAggregateOutputType | null
    _max: VisitorLogMaxAggregateOutputType | null
  }

  export type VisitorLogMinAggregateOutputType = {
    id: string | null
    nome: string | null
    documento: string | null
    apartamento: string | null
    bloco: string | null
    dataEntrada: Date | null
    dataSaida: Date | null
    createdAt: Date | null
    createdById: string | null
  }

  export type VisitorLogMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    documento: string | null
    apartamento: string | null
    bloco: string | null
    dataEntrada: Date | null
    dataSaida: Date | null
    createdAt: Date | null
    createdById: string | null
  }

  export type VisitorLogCountAggregateOutputType = {
    id: number
    nome: number
    documento: number
    apartamento: number
    bloco: number
    dataEntrada: number
    dataSaida: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type VisitorLogMinAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    apartamento?: true
    bloco?: true
    dataEntrada?: true
    dataSaida?: true
    createdAt?: true
    createdById?: true
  }

  export type VisitorLogMaxAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    apartamento?: true
    bloco?: true
    dataEntrada?: true
    dataSaida?: true
    createdAt?: true
    createdById?: true
  }

  export type VisitorLogCountAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    apartamento?: true
    bloco?: true
    dataEntrada?: true
    dataSaida?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type VisitorLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitorLog to aggregate.
     */
    where?: VisitorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitorLogs to fetch.
     */
    orderBy?: VisitorLogOrderByWithRelationInput | VisitorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitorLogs
    **/
    _count?: true | VisitorLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorLogMaxAggregateInputType
  }

  export type GetVisitorLogAggregateType<T extends VisitorLogAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitorLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitorLog[P]>
      : GetScalarType<T[P], AggregateVisitorLog[P]>
  }




  export type VisitorLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorLogWhereInput
    orderBy?: VisitorLogOrderByWithAggregationInput | VisitorLogOrderByWithAggregationInput[]
    by: VisitorLogScalarFieldEnum[] | VisitorLogScalarFieldEnum
    having?: VisitorLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorLogCountAggregateInputType | true
    _min?: VisitorLogMinAggregateInputType
    _max?: VisitorLogMaxAggregateInputType
  }

  export type VisitorLogGroupByOutputType = {
    id: string
    nome: string
    documento: string | null
    apartamento: string | null
    bloco: string | null
    dataEntrada: Date
    dataSaida: Date | null
    createdAt: Date
    createdById: string
    _count: VisitorLogCountAggregateOutputType | null
    _min: VisitorLogMinAggregateOutputType | null
    _max: VisitorLogMaxAggregateOutputType | null
  }

  type GetVisitorLogGroupByPayload<T extends VisitorLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorLogGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorLogGroupByOutputType[P]>
        }
      >
    >


  export type VisitorLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    documento?: boolean
    apartamento?: boolean
    bloco?: boolean
    dataEntrada?: boolean
    dataSaida?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitorLog"]>

  export type VisitorLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    documento?: boolean
    apartamento?: boolean
    bloco?: boolean
    dataEntrada?: boolean
    dataSaida?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitorLog"]>

  export type VisitorLogSelectScalar = {
    id?: boolean
    nome?: boolean
    documento?: boolean
    apartamento?: boolean
    bloco?: boolean
    dataEntrada?: boolean
    dataSaida?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type VisitorLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VisitorLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VisitorLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitorLog"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      documento: string | null
      apartamento: string | null
      bloco: string | null
      dataEntrada: Date
      dataSaida: Date | null
      createdAt: Date
      createdById: string
    }, ExtArgs["result"]["visitorLog"]>
    composites: {}
  }

  type VisitorLogGetPayload<S extends boolean | null | undefined | VisitorLogDefaultArgs> = $Result.GetResult<Prisma.$VisitorLogPayload, S>

  type VisitorLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitorLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitorLogCountAggregateInputType | true
    }

  export interface VisitorLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitorLog'], meta: { name: 'VisitorLog' } }
    /**
     * Find zero or one VisitorLog that matches the filter.
     * @param {VisitorLogFindUniqueArgs} args - Arguments to find a VisitorLog
     * @example
     * // Get one VisitorLog
     * const visitorLog = await prisma.visitorLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorLogFindUniqueArgs>(args: SelectSubset<T, VisitorLogFindUniqueArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitorLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitorLogFindUniqueOrThrowArgs} args - Arguments to find a VisitorLog
     * @example
     * // Get one VisitorLog
     * const visitorLog = await prisma.visitorLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorLogFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitorLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogFindFirstArgs} args - Arguments to find a VisitorLog
     * @example
     * // Get one VisitorLog
     * const visitorLog = await prisma.visitorLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorLogFindFirstArgs>(args?: SelectSubset<T, VisitorLogFindFirstArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitorLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogFindFirstOrThrowArgs} args - Arguments to find a VisitorLog
     * @example
     * // Get one VisitorLog
     * const visitorLog = await prisma.visitorLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorLogFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitorLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitorLogs
     * const visitorLogs = await prisma.visitorLog.findMany()
     * 
     * // Get first 10 VisitorLogs
     * const visitorLogs = await prisma.visitorLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorLogWithIdOnly = await prisma.visitorLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorLogFindManyArgs>(args?: SelectSubset<T, VisitorLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitorLog.
     * @param {VisitorLogCreateArgs} args - Arguments to create a VisitorLog.
     * @example
     * // Create one VisitorLog
     * const VisitorLog = await prisma.visitorLog.create({
     *   data: {
     *     // ... data to create a VisitorLog
     *   }
     * })
     * 
     */
    create<T extends VisitorLogCreateArgs>(args: SelectSubset<T, VisitorLogCreateArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitorLogs.
     * @param {VisitorLogCreateManyArgs} args - Arguments to create many VisitorLogs.
     * @example
     * // Create many VisitorLogs
     * const visitorLog = await prisma.visitorLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorLogCreateManyArgs>(args?: SelectSubset<T, VisitorLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitorLogs and returns the data saved in the database.
     * @param {VisitorLogCreateManyAndReturnArgs} args - Arguments to create many VisitorLogs.
     * @example
     * // Create many VisitorLogs
     * const visitorLog = await prisma.visitorLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitorLogs and only return the `id`
     * const visitorLogWithIdOnly = await prisma.visitorLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitorLogCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitorLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitorLog.
     * @param {VisitorLogDeleteArgs} args - Arguments to delete one VisitorLog.
     * @example
     * // Delete one VisitorLog
     * const VisitorLog = await prisma.visitorLog.delete({
     *   where: {
     *     // ... filter to delete one VisitorLog
     *   }
     * })
     * 
     */
    delete<T extends VisitorLogDeleteArgs>(args: SelectSubset<T, VisitorLogDeleteArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitorLog.
     * @param {VisitorLogUpdateArgs} args - Arguments to update one VisitorLog.
     * @example
     * // Update one VisitorLog
     * const visitorLog = await prisma.visitorLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorLogUpdateArgs>(args: SelectSubset<T, VisitorLogUpdateArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitorLogs.
     * @param {VisitorLogDeleteManyArgs} args - Arguments to filter VisitorLogs to delete.
     * @example
     * // Delete a few VisitorLogs
     * const { count } = await prisma.visitorLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorLogDeleteManyArgs>(args?: SelectSubset<T, VisitorLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitorLogs
     * const visitorLog = await prisma.visitorLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorLogUpdateManyArgs>(args: SelectSubset<T, VisitorLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitorLog.
     * @param {VisitorLogUpsertArgs} args - Arguments to update or create a VisitorLog.
     * @example
     * // Update or create a VisitorLog
     * const visitorLog = await prisma.visitorLog.upsert({
     *   create: {
     *     // ... data to create a VisitorLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitorLog we want to update
     *   }
     * })
     */
    upsert<T extends VisitorLogUpsertArgs>(args: SelectSubset<T, VisitorLogUpsertArgs<ExtArgs>>): Prisma__VisitorLogClient<$Result.GetResult<Prisma.$VisitorLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogCountArgs} args - Arguments to filter VisitorLogs to count.
     * @example
     * // Count the number of VisitorLogs
     * const count = await prisma.visitorLog.count({
     *   where: {
     *     // ... the filter for the VisitorLogs we want to count
     *   }
     * })
    **/
    count<T extends VisitorLogCountArgs>(
      args?: Subset<T, VisitorLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorLogAggregateArgs>(args: Subset<T, VisitorLogAggregateArgs>): Prisma.PrismaPromise<GetVisitorLogAggregateType<T>>

    /**
     * Group by VisitorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorLogGroupByArgs['orderBy'] }
        : { orderBy?: VisitorLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitorLog model
   */
  readonly fields: VisitorLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitorLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitorLog model
   */ 
  interface VisitorLogFieldRefs {
    readonly id: FieldRef<"VisitorLog", 'String'>
    readonly nome: FieldRef<"VisitorLog", 'String'>
    readonly documento: FieldRef<"VisitorLog", 'String'>
    readonly apartamento: FieldRef<"VisitorLog", 'String'>
    readonly bloco: FieldRef<"VisitorLog", 'String'>
    readonly dataEntrada: FieldRef<"VisitorLog", 'DateTime'>
    readonly dataSaida: FieldRef<"VisitorLog", 'DateTime'>
    readonly createdAt: FieldRef<"VisitorLog", 'DateTime'>
    readonly createdById: FieldRef<"VisitorLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisitorLog findUnique
   */
  export type VisitorLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitorLog to fetch.
     */
    where: VisitorLogWhereUniqueInput
  }

  /**
   * VisitorLog findUniqueOrThrow
   */
  export type VisitorLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitorLog to fetch.
     */
    where: VisitorLogWhereUniqueInput
  }

  /**
   * VisitorLog findFirst
   */
  export type VisitorLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitorLog to fetch.
     */
    where?: VisitorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitorLogs to fetch.
     */
    orderBy?: VisitorLogOrderByWithRelationInput | VisitorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitorLogs.
     */
    cursor?: VisitorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitorLogs.
     */
    distinct?: VisitorLogScalarFieldEnum | VisitorLogScalarFieldEnum[]
  }

  /**
   * VisitorLog findFirstOrThrow
   */
  export type VisitorLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitorLog to fetch.
     */
    where?: VisitorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitorLogs to fetch.
     */
    orderBy?: VisitorLogOrderByWithRelationInput | VisitorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitorLogs.
     */
    cursor?: VisitorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitorLogs.
     */
    distinct?: VisitorLogScalarFieldEnum | VisitorLogScalarFieldEnum[]
  }

  /**
   * VisitorLog findMany
   */
  export type VisitorLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * Filter, which VisitorLogs to fetch.
     */
    where?: VisitorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitorLogs to fetch.
     */
    orderBy?: VisitorLogOrderByWithRelationInput | VisitorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitorLogs.
     */
    cursor?: VisitorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitorLogs.
     */
    skip?: number
    distinct?: VisitorLogScalarFieldEnum | VisitorLogScalarFieldEnum[]
  }

  /**
   * VisitorLog create
   */
  export type VisitorLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitorLog.
     */
    data: XOR<VisitorLogCreateInput, VisitorLogUncheckedCreateInput>
  }

  /**
   * VisitorLog createMany
   */
  export type VisitorLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitorLogs.
     */
    data: VisitorLogCreateManyInput | VisitorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitorLog createManyAndReturn
   */
  export type VisitorLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitorLogs.
     */
    data: VisitorLogCreateManyInput | VisitorLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitorLog update
   */
  export type VisitorLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitorLog.
     */
    data: XOR<VisitorLogUpdateInput, VisitorLogUncheckedUpdateInput>
    /**
     * Choose, which VisitorLog to update.
     */
    where: VisitorLogWhereUniqueInput
  }

  /**
   * VisitorLog updateMany
   */
  export type VisitorLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitorLogs.
     */
    data: XOR<VisitorLogUpdateManyMutationInput, VisitorLogUncheckedUpdateManyInput>
    /**
     * Filter which VisitorLogs to update
     */
    where?: VisitorLogWhereInput
  }

  /**
   * VisitorLog upsert
   */
  export type VisitorLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitorLog to update in case it exists.
     */
    where: VisitorLogWhereUniqueInput
    /**
     * In case the VisitorLog found by the `where` argument doesn't exist, create a new VisitorLog with this data.
     */
    create: XOR<VisitorLogCreateInput, VisitorLogUncheckedCreateInput>
    /**
     * In case the VisitorLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorLogUpdateInput, VisitorLogUncheckedUpdateInput>
  }

  /**
   * VisitorLog delete
   */
  export type VisitorLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
    /**
     * Filter which VisitorLog to delete.
     */
    where: VisitorLogWhereUniqueInput
  }

  /**
   * VisitorLog deleteMany
   */
  export type VisitorLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitorLogs to delete
     */
    where?: VisitorLogWhereInput
  }

  /**
   * VisitorLog without action
   */
  export type VisitorLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitorLog
     */
    select?: VisitorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitorLogInclude<ExtArgs> | null
  }


  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    descricao: string | null
    destinatarioEmail: string | null
    fotoUrl: string | null
    assinaturaUrl: string | null
    status: string | null
    chegouEm: Date | null
    entregueEm: Date | null
    createdById: string | null
    destinatarioId: string | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    descricao: string | null
    destinatarioEmail: string | null
    fotoUrl: string | null
    assinaturaUrl: string | null
    status: string | null
    chegouEm: Date | null
    entregueEm: Date | null
    createdById: string | null
    destinatarioId: string | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    descricao: number
    destinatarioEmail: number
    fotoUrl: number
    assinaturaUrl: number
    status: number
    chegouEm: number
    entregueEm: number
    createdById: number
    destinatarioId: number
    _all: number
  }


  export type DeliveryMinAggregateInputType = {
    id?: true
    descricao?: true
    destinatarioEmail?: true
    fotoUrl?: true
    assinaturaUrl?: true
    status?: true
    chegouEm?: true
    entregueEm?: true
    createdById?: true
    destinatarioId?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    descricao?: true
    destinatarioEmail?: true
    fotoUrl?: true
    assinaturaUrl?: true
    status?: true
    chegouEm?: true
    entregueEm?: true
    createdById?: true
    destinatarioId?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    descricao?: true
    destinatarioEmail?: true
    fotoUrl?: true
    assinaturaUrl?: true
    status?: true
    chegouEm?: true
    entregueEm?: true
    createdById?: true
    destinatarioId?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: string
    descricao: string
    destinatarioEmail: string | null
    fotoUrl: string | null
    assinaturaUrl: string | null
    status: string
    chegouEm: Date
    entregueEm: Date | null
    createdById: string
    destinatarioId: string | null
    _count: DeliveryCountAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    destinatarioEmail?: boolean
    fotoUrl?: boolean
    assinaturaUrl?: boolean
    status?: boolean
    chegouEm?: boolean
    entregueEm?: boolean
    createdById?: boolean
    destinatarioId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    destinatario?: boolean | Delivery$destinatarioArgs<ExtArgs>
    notificacoes?: boolean | Delivery$notificacoesArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    destinatarioEmail?: boolean
    fotoUrl?: boolean
    assinaturaUrl?: boolean
    status?: boolean
    chegouEm?: boolean
    entregueEm?: boolean
    createdById?: boolean
    destinatarioId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    destinatario?: boolean | Delivery$destinatarioArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    descricao?: boolean
    destinatarioEmail?: boolean
    fotoUrl?: boolean
    assinaturaUrl?: boolean
    status?: boolean
    chegouEm?: boolean
    entregueEm?: boolean
    createdById?: boolean
    destinatarioId?: boolean
  }

  export type DeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    destinatario?: boolean | Delivery$destinatarioArgs<ExtArgs>
    notificacoes?: boolean | Delivery$notificacoesArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    destinatario?: boolean | Delivery$destinatarioArgs<ExtArgs>
  }

  export type $DeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      destinatario: Prisma.$UserPayload<ExtArgs> | null
      notificacoes: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      descricao: string
      destinatarioEmail: string | null
      fotoUrl: string | null
      assinaturaUrl: string | null
      status: string
      chegouEm: Date
      entregueEm: Date | null
      createdById: string
      destinatarioId: string | null
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }

  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFindUniqueArgs>(args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Delivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFindFirstArgs>(args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFindManyArgs>(args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
     */
    create<T extends DeliveryCreateArgs>(args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deliveries.
     * @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryCreateManyArgs>(args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveries and returns the data saved in the database.
     * @param {DeliveryCreateManyAndReturnArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
     */
    delete<T extends DeliveryDeleteArgs>(args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryUpdateArgs>(args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryDeleteManyArgs>(args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryUpdateManyArgs>(args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryUpsertArgs>(args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    destinatario<T extends Delivery$destinatarioArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$destinatarioArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notificacoes<T extends Delivery$notificacoesArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$notificacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delivery model
   */ 
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'String'>
    readonly descricao: FieldRef<"Delivery", 'String'>
    readonly destinatarioEmail: FieldRef<"Delivery", 'String'>
    readonly fotoUrl: FieldRef<"Delivery", 'String'>
    readonly assinaturaUrl: FieldRef<"Delivery", 'String'>
    readonly status: FieldRef<"Delivery", 'String'>
    readonly chegouEm: FieldRef<"Delivery", 'DateTime'>
    readonly entregueEm: FieldRef<"Delivery", 'DateTime'>
    readonly createdById: FieldRef<"Delivery", 'String'>
    readonly destinatarioId: FieldRef<"Delivery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }

  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delivery createManyAndReturn
   */
  export type DeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
  }

  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }

  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
  }

  /**
   * Delivery.destinatario
   */
  export type Delivery$destinatarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Delivery.notificacoes
   */
  export type Delivery$notificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
  }


  /**
   * Model ShiftNote
   */

  export type AggregateShiftNote = {
    _count: ShiftNoteCountAggregateOutputType | null
    _min: ShiftNoteMinAggregateOutputType | null
    _max: ShiftNoteMaxAggregateOutputType | null
  }

  export type ShiftNoteMinAggregateOutputType = {
    id: string | null
    texto: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type ShiftNoteMaxAggregateOutputType = {
    id: string | null
    texto: string | null
    createdAt: Date | null
    createdById: string | null
  }

  export type ShiftNoteCountAggregateOutputType = {
    id: number
    texto: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type ShiftNoteMinAggregateInputType = {
    id?: true
    texto?: true
    createdAt?: true
    createdById?: true
  }

  export type ShiftNoteMaxAggregateInputType = {
    id?: true
    texto?: true
    createdAt?: true
    createdById?: true
  }

  export type ShiftNoteCountAggregateInputType = {
    id?: true
    texto?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type ShiftNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftNote to aggregate.
     */
    where?: ShiftNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftNotes to fetch.
     */
    orderBy?: ShiftNoteOrderByWithRelationInput | ShiftNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftNotes
    **/
    _count?: true | ShiftNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftNoteMaxAggregateInputType
  }

  export type GetShiftNoteAggregateType<T extends ShiftNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftNote[P]>
      : GetScalarType<T[P], AggregateShiftNote[P]>
  }




  export type ShiftNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftNoteWhereInput
    orderBy?: ShiftNoteOrderByWithAggregationInput | ShiftNoteOrderByWithAggregationInput[]
    by: ShiftNoteScalarFieldEnum[] | ShiftNoteScalarFieldEnum
    having?: ShiftNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftNoteCountAggregateInputType | true
    _min?: ShiftNoteMinAggregateInputType
    _max?: ShiftNoteMaxAggregateInputType
  }

  export type ShiftNoteGroupByOutputType = {
    id: string
    texto: string
    createdAt: Date
    createdById: string
    _count: ShiftNoteCountAggregateOutputType | null
    _min: ShiftNoteMinAggregateOutputType | null
    _max: ShiftNoteMaxAggregateOutputType | null
  }

  type GetShiftNoteGroupByPayload<T extends ShiftNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftNoteGroupByOutputType[P]>
        }
      >
    >


  export type ShiftNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftNote"]>

  export type ShiftNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    createdAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftNote"]>

  export type ShiftNoteSelectScalar = {
    id?: boolean
    texto?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type ShiftNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ShiftNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ShiftNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftNote"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      texto: string
      createdAt: Date
      createdById: string
    }, ExtArgs["result"]["shiftNote"]>
    composites: {}
  }

  type ShiftNoteGetPayload<S extends boolean | null | undefined | ShiftNoteDefaultArgs> = $Result.GetResult<Prisma.$ShiftNotePayload, S>

  type ShiftNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftNoteCountAggregateInputType | true
    }

  export interface ShiftNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftNote'], meta: { name: 'ShiftNote' } }
    /**
     * Find zero or one ShiftNote that matches the filter.
     * @param {ShiftNoteFindUniqueArgs} args - Arguments to find a ShiftNote
     * @example
     * // Get one ShiftNote
     * const shiftNote = await prisma.shiftNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftNoteFindUniqueArgs>(args: SelectSubset<T, ShiftNoteFindUniqueArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShiftNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftNoteFindUniqueOrThrowArgs} args - Arguments to find a ShiftNote
     * @example
     * // Get one ShiftNote
     * const shiftNote = await prisma.shiftNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShiftNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteFindFirstArgs} args - Arguments to find a ShiftNote
     * @example
     * // Get one ShiftNote
     * const shiftNote = await prisma.shiftNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftNoteFindFirstArgs>(args?: SelectSubset<T, ShiftNoteFindFirstArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShiftNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteFindFirstOrThrowArgs} args - Arguments to find a ShiftNote
     * @example
     * // Get one ShiftNote
     * const shiftNote = await prisma.shiftNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShiftNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftNotes
     * const shiftNotes = await prisma.shiftNote.findMany()
     * 
     * // Get first 10 ShiftNotes
     * const shiftNotes = await prisma.shiftNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftNoteWithIdOnly = await prisma.shiftNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftNoteFindManyArgs>(args?: SelectSubset<T, ShiftNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShiftNote.
     * @param {ShiftNoteCreateArgs} args - Arguments to create a ShiftNote.
     * @example
     * // Create one ShiftNote
     * const ShiftNote = await prisma.shiftNote.create({
     *   data: {
     *     // ... data to create a ShiftNote
     *   }
     * })
     * 
     */
    create<T extends ShiftNoteCreateArgs>(args: SelectSubset<T, ShiftNoteCreateArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShiftNotes.
     * @param {ShiftNoteCreateManyArgs} args - Arguments to create many ShiftNotes.
     * @example
     * // Create many ShiftNotes
     * const shiftNote = await prisma.shiftNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftNoteCreateManyArgs>(args?: SelectSubset<T, ShiftNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftNotes and returns the data saved in the database.
     * @param {ShiftNoteCreateManyAndReturnArgs} args - Arguments to create many ShiftNotes.
     * @example
     * // Create many ShiftNotes
     * const shiftNote = await prisma.shiftNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftNotes and only return the `id`
     * const shiftNoteWithIdOnly = await prisma.shiftNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShiftNote.
     * @param {ShiftNoteDeleteArgs} args - Arguments to delete one ShiftNote.
     * @example
     * // Delete one ShiftNote
     * const ShiftNote = await prisma.shiftNote.delete({
     *   where: {
     *     // ... filter to delete one ShiftNote
     *   }
     * })
     * 
     */
    delete<T extends ShiftNoteDeleteArgs>(args: SelectSubset<T, ShiftNoteDeleteArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShiftNote.
     * @param {ShiftNoteUpdateArgs} args - Arguments to update one ShiftNote.
     * @example
     * // Update one ShiftNote
     * const shiftNote = await prisma.shiftNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftNoteUpdateArgs>(args: SelectSubset<T, ShiftNoteUpdateArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShiftNotes.
     * @param {ShiftNoteDeleteManyArgs} args - Arguments to filter ShiftNotes to delete.
     * @example
     * // Delete a few ShiftNotes
     * const { count } = await prisma.shiftNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftNoteDeleteManyArgs>(args?: SelectSubset<T, ShiftNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftNotes
     * const shiftNote = await prisma.shiftNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftNoteUpdateManyArgs>(args: SelectSubset<T, ShiftNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShiftNote.
     * @param {ShiftNoteUpsertArgs} args - Arguments to update or create a ShiftNote.
     * @example
     * // Update or create a ShiftNote
     * const shiftNote = await prisma.shiftNote.upsert({
     *   create: {
     *     // ... data to create a ShiftNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftNote we want to update
     *   }
     * })
     */
    upsert<T extends ShiftNoteUpsertArgs>(args: SelectSubset<T, ShiftNoteUpsertArgs<ExtArgs>>): Prisma__ShiftNoteClient<$Result.GetResult<Prisma.$ShiftNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShiftNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteCountArgs} args - Arguments to filter ShiftNotes to count.
     * @example
     * // Count the number of ShiftNotes
     * const count = await prisma.shiftNote.count({
     *   where: {
     *     // ... the filter for the ShiftNotes we want to count
     *   }
     * })
    **/
    count<T extends ShiftNoteCountArgs>(
      args?: Subset<T, ShiftNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftNoteAggregateArgs>(args: Subset<T, ShiftNoteAggregateArgs>): Prisma.PrismaPromise<GetShiftNoteAggregateType<T>>

    /**
     * Group by ShiftNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftNoteGroupByArgs['orderBy'] }
        : { orderBy?: ShiftNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftNote model
   */
  readonly fields: ShiftNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftNote model
   */ 
  interface ShiftNoteFieldRefs {
    readonly id: FieldRef<"ShiftNote", 'String'>
    readonly texto: FieldRef<"ShiftNote", 'String'>
    readonly createdAt: FieldRef<"ShiftNote", 'DateTime'>
    readonly createdById: FieldRef<"ShiftNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShiftNote findUnique
   */
  export type ShiftNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * Filter, which ShiftNote to fetch.
     */
    where: ShiftNoteWhereUniqueInput
  }

  /**
   * ShiftNote findUniqueOrThrow
   */
  export type ShiftNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * Filter, which ShiftNote to fetch.
     */
    where: ShiftNoteWhereUniqueInput
  }

  /**
   * ShiftNote findFirst
   */
  export type ShiftNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * Filter, which ShiftNote to fetch.
     */
    where?: ShiftNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftNotes to fetch.
     */
    orderBy?: ShiftNoteOrderByWithRelationInput | ShiftNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftNotes.
     */
    cursor?: ShiftNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftNotes.
     */
    distinct?: ShiftNoteScalarFieldEnum | ShiftNoteScalarFieldEnum[]
  }

  /**
   * ShiftNote findFirstOrThrow
   */
  export type ShiftNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * Filter, which ShiftNote to fetch.
     */
    where?: ShiftNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftNotes to fetch.
     */
    orderBy?: ShiftNoteOrderByWithRelationInput | ShiftNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftNotes.
     */
    cursor?: ShiftNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftNotes.
     */
    distinct?: ShiftNoteScalarFieldEnum | ShiftNoteScalarFieldEnum[]
  }

  /**
   * ShiftNote findMany
   */
  export type ShiftNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * Filter, which ShiftNotes to fetch.
     */
    where?: ShiftNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftNotes to fetch.
     */
    orderBy?: ShiftNoteOrderByWithRelationInput | ShiftNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftNotes.
     */
    cursor?: ShiftNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftNotes.
     */
    skip?: number
    distinct?: ShiftNoteScalarFieldEnum | ShiftNoteScalarFieldEnum[]
  }

  /**
   * ShiftNote create
   */
  export type ShiftNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftNote.
     */
    data: XOR<ShiftNoteCreateInput, ShiftNoteUncheckedCreateInput>
  }

  /**
   * ShiftNote createMany
   */
  export type ShiftNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftNotes.
     */
    data: ShiftNoteCreateManyInput | ShiftNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftNote createManyAndReturn
   */
  export type ShiftNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShiftNotes.
     */
    data: ShiftNoteCreateManyInput | ShiftNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftNote update
   */
  export type ShiftNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftNote.
     */
    data: XOR<ShiftNoteUpdateInput, ShiftNoteUncheckedUpdateInput>
    /**
     * Choose, which ShiftNote to update.
     */
    where: ShiftNoteWhereUniqueInput
  }

  /**
   * ShiftNote updateMany
   */
  export type ShiftNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftNotes.
     */
    data: XOR<ShiftNoteUpdateManyMutationInput, ShiftNoteUncheckedUpdateManyInput>
    /**
     * Filter which ShiftNotes to update
     */
    where?: ShiftNoteWhereInput
  }

  /**
   * ShiftNote upsert
   */
  export type ShiftNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftNote to update in case it exists.
     */
    where: ShiftNoteWhereUniqueInput
    /**
     * In case the ShiftNote found by the `where` argument doesn't exist, create a new ShiftNote with this data.
     */
    create: XOR<ShiftNoteCreateInput, ShiftNoteUncheckedCreateInput>
    /**
     * In case the ShiftNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftNoteUpdateInput, ShiftNoteUncheckedUpdateInput>
  }

  /**
   * ShiftNote delete
   */
  export type ShiftNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
    /**
     * Filter which ShiftNote to delete.
     */
    where: ShiftNoteWhereUniqueInput
  }

  /**
   * ShiftNote deleteMany
   */
  export type ShiftNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftNotes to delete
     */
    where?: ShiftNoteWhereInput
  }

  /**
   * ShiftNote without action
   */
  export type ShiftNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftNote
     */
    select?: ShiftNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftNoteInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    mensagem: string | null
    imageUrl: string | null
    lida: boolean | null
    createdAt: Date | null
    userId: string | null
    deliveryId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    mensagem: string | null
    imageUrl: string | null
    lida: boolean | null
    createdAt: Date | null
    userId: string | null
    deliveryId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    titulo: number
    mensagem: number
    imageUrl: number
    lida: number
    createdAt: number
    userId: number
    deliveryId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    titulo?: true
    mensagem?: true
    imageUrl?: true
    lida?: true
    createdAt?: true
    userId?: true
    deliveryId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    titulo?: true
    mensagem?: true
    imageUrl?: true
    lida?: true
    createdAt?: true
    userId?: true
    deliveryId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    titulo?: true
    mensagem?: true
    imageUrl?: true
    lida?: true
    createdAt?: true
    userId?: true
    deliveryId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    titulo: string
    mensagem: string
    imageUrl: string | null
    lida: boolean
    createdAt: Date
    userId: string
    deliveryId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    mensagem?: boolean
    imageUrl?: boolean
    lida?: boolean
    createdAt?: boolean
    userId?: boolean
    deliveryId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    delivery?: boolean | Notification$deliveryArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    mensagem?: boolean
    imageUrl?: boolean
    lida?: boolean
    createdAt?: boolean
    userId?: boolean
    deliveryId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    delivery?: boolean | Notification$deliveryArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    titulo?: boolean
    mensagem?: boolean
    imageUrl?: boolean
    lida?: boolean
    createdAt?: boolean
    userId?: boolean
    deliveryId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    delivery?: boolean | Notification$deliveryArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    delivery?: boolean | Notification$deliveryArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      delivery: Prisma.$DeliveryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      mensagem: string
      imageUrl: string | null
      lida: boolean
      createdAt: Date
      userId: string
      deliveryId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    delivery<T extends Notification$deliveryArgs<ExtArgs> = {}>(args?: Subset<T, Notification$deliveryArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly titulo: FieldRef<"Notification", 'String'>
    readonly mensagem: FieldRef<"Notification", 'String'>
    readonly imageUrl: FieldRef<"Notification", 'String'>
    readonly lida: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly deliveryId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.delivery
   */
  export type Notification$deliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Aviso
   */

  export type AggregateAviso = {
    _count: AvisoCountAggregateOutputType | null
    _min: AvisoMinAggregateOutputType | null
    _max: AvisoMaxAggregateOutputType | null
  }

  export type AvisoMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    conteudo: string | null
    createdAt: Date | null
  }

  export type AvisoMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    conteudo: string | null
    createdAt: Date | null
  }

  export type AvisoCountAggregateOutputType = {
    id: number
    titulo: number
    conteudo: number
    createdAt: number
    _all: number
  }


  export type AvisoMinAggregateInputType = {
    id?: true
    titulo?: true
    conteudo?: true
    createdAt?: true
  }

  export type AvisoMaxAggregateInputType = {
    id?: true
    titulo?: true
    conteudo?: true
    createdAt?: true
  }

  export type AvisoCountAggregateInputType = {
    id?: true
    titulo?: true
    conteudo?: true
    createdAt?: true
    _all?: true
  }

  export type AvisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Aviso to aggregate.
     */
    where?: AvisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avisos to fetch.
     */
    orderBy?: AvisoOrderByWithRelationInput | AvisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avisos
    **/
    _count?: true | AvisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvisoMaxAggregateInputType
  }

  export type GetAvisoAggregateType<T extends AvisoAggregateArgs> = {
        [P in keyof T & keyof AggregateAviso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAviso[P]>
      : GetScalarType<T[P], AggregateAviso[P]>
  }




  export type AvisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvisoWhereInput
    orderBy?: AvisoOrderByWithAggregationInput | AvisoOrderByWithAggregationInput[]
    by: AvisoScalarFieldEnum[] | AvisoScalarFieldEnum
    having?: AvisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvisoCountAggregateInputType | true
    _min?: AvisoMinAggregateInputType
    _max?: AvisoMaxAggregateInputType
  }

  export type AvisoGroupByOutputType = {
    id: string
    titulo: string
    conteudo: string
    createdAt: Date
    _count: AvisoCountAggregateOutputType | null
    _min: AvisoMinAggregateOutputType | null
    _max: AvisoMaxAggregateOutputType | null
  }

  type GetAvisoGroupByPayload<T extends AvisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvisoGroupByOutputType[P]>
            : GetScalarType<T[P], AvisoGroupByOutputType[P]>
        }
      >
    >


  export type AvisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    conteudo?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aviso"]>

  export type AvisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    conteudo?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aviso"]>

  export type AvisoSelectScalar = {
    id?: boolean
    titulo?: boolean
    conteudo?: boolean
    createdAt?: boolean
  }


  export type $AvisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Aviso"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      conteudo: string
      createdAt: Date
    }, ExtArgs["result"]["aviso"]>
    composites: {}
  }

  type AvisoGetPayload<S extends boolean | null | undefined | AvisoDefaultArgs> = $Result.GetResult<Prisma.$AvisoPayload, S>

  type AvisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AvisoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvisoCountAggregateInputType | true
    }

  export interface AvisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Aviso'], meta: { name: 'Aviso' } }
    /**
     * Find zero or one Aviso that matches the filter.
     * @param {AvisoFindUniqueArgs} args - Arguments to find a Aviso
     * @example
     * // Get one Aviso
     * const aviso = await prisma.aviso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvisoFindUniqueArgs>(args: SelectSubset<T, AvisoFindUniqueArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Aviso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AvisoFindUniqueOrThrowArgs} args - Arguments to find a Aviso
     * @example
     * // Get one Aviso
     * const aviso = await prisma.aviso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvisoFindUniqueOrThrowArgs>(args: SelectSubset<T, AvisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Aviso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoFindFirstArgs} args - Arguments to find a Aviso
     * @example
     * // Get one Aviso
     * const aviso = await prisma.aviso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvisoFindFirstArgs>(args?: SelectSubset<T, AvisoFindFirstArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Aviso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoFindFirstOrThrowArgs} args - Arguments to find a Aviso
     * @example
     * // Get one Aviso
     * const aviso = await prisma.aviso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvisoFindFirstOrThrowArgs>(args?: SelectSubset<T, AvisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Avisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avisos
     * const avisos = await prisma.aviso.findMany()
     * 
     * // Get first 10 Avisos
     * const avisos = await prisma.aviso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avisoWithIdOnly = await prisma.aviso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvisoFindManyArgs>(args?: SelectSubset<T, AvisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Aviso.
     * @param {AvisoCreateArgs} args - Arguments to create a Aviso.
     * @example
     * // Create one Aviso
     * const Aviso = await prisma.aviso.create({
     *   data: {
     *     // ... data to create a Aviso
     *   }
     * })
     * 
     */
    create<T extends AvisoCreateArgs>(args: SelectSubset<T, AvisoCreateArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Avisos.
     * @param {AvisoCreateManyArgs} args - Arguments to create many Avisos.
     * @example
     * // Create many Avisos
     * const aviso = await prisma.aviso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvisoCreateManyArgs>(args?: SelectSubset<T, AvisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avisos and returns the data saved in the database.
     * @param {AvisoCreateManyAndReturnArgs} args - Arguments to create many Avisos.
     * @example
     * // Create many Avisos
     * const aviso = await prisma.aviso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avisos and only return the `id`
     * const avisoWithIdOnly = await prisma.aviso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvisoCreateManyAndReturnArgs>(args?: SelectSubset<T, AvisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Aviso.
     * @param {AvisoDeleteArgs} args - Arguments to delete one Aviso.
     * @example
     * // Delete one Aviso
     * const Aviso = await prisma.aviso.delete({
     *   where: {
     *     // ... filter to delete one Aviso
     *   }
     * })
     * 
     */
    delete<T extends AvisoDeleteArgs>(args: SelectSubset<T, AvisoDeleteArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Aviso.
     * @param {AvisoUpdateArgs} args - Arguments to update one Aviso.
     * @example
     * // Update one Aviso
     * const aviso = await prisma.aviso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvisoUpdateArgs>(args: SelectSubset<T, AvisoUpdateArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Avisos.
     * @param {AvisoDeleteManyArgs} args - Arguments to filter Avisos to delete.
     * @example
     * // Delete a few Avisos
     * const { count } = await prisma.aviso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvisoDeleteManyArgs>(args?: SelectSubset<T, AvisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avisos
     * const aviso = await prisma.aviso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvisoUpdateManyArgs>(args: SelectSubset<T, AvisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aviso.
     * @param {AvisoUpsertArgs} args - Arguments to update or create a Aviso.
     * @example
     * // Update or create a Aviso
     * const aviso = await prisma.aviso.upsert({
     *   create: {
     *     // ... data to create a Aviso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aviso we want to update
     *   }
     * })
     */
    upsert<T extends AvisoUpsertArgs>(args: SelectSubset<T, AvisoUpsertArgs<ExtArgs>>): Prisma__AvisoClient<$Result.GetResult<Prisma.$AvisoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Avisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoCountArgs} args - Arguments to filter Avisos to count.
     * @example
     * // Count the number of Avisos
     * const count = await prisma.aviso.count({
     *   where: {
     *     // ... the filter for the Avisos we want to count
     *   }
     * })
    **/
    count<T extends AvisoCountArgs>(
      args?: Subset<T, AvisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aviso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvisoAggregateArgs>(args: Subset<T, AvisoAggregateArgs>): Prisma.PrismaPromise<GetAvisoAggregateType<T>>

    /**
     * Group by Aviso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvisoGroupByArgs['orderBy'] }
        : { orderBy?: AvisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Aviso model
   */
  readonly fields: AvisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Aviso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Aviso model
   */ 
  interface AvisoFieldRefs {
    readonly id: FieldRef<"Aviso", 'String'>
    readonly titulo: FieldRef<"Aviso", 'String'>
    readonly conteudo: FieldRef<"Aviso", 'String'>
    readonly createdAt: FieldRef<"Aviso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Aviso findUnique
   */
  export type AvisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * Filter, which Aviso to fetch.
     */
    where: AvisoWhereUniqueInput
  }

  /**
   * Aviso findUniqueOrThrow
   */
  export type AvisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * Filter, which Aviso to fetch.
     */
    where: AvisoWhereUniqueInput
  }

  /**
   * Aviso findFirst
   */
  export type AvisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * Filter, which Aviso to fetch.
     */
    where?: AvisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avisos to fetch.
     */
    orderBy?: AvisoOrderByWithRelationInput | AvisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avisos.
     */
    cursor?: AvisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avisos.
     */
    distinct?: AvisoScalarFieldEnum | AvisoScalarFieldEnum[]
  }

  /**
   * Aviso findFirstOrThrow
   */
  export type AvisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * Filter, which Aviso to fetch.
     */
    where?: AvisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avisos to fetch.
     */
    orderBy?: AvisoOrderByWithRelationInput | AvisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avisos.
     */
    cursor?: AvisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avisos.
     */
    distinct?: AvisoScalarFieldEnum | AvisoScalarFieldEnum[]
  }

  /**
   * Aviso findMany
   */
  export type AvisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * Filter, which Avisos to fetch.
     */
    where?: AvisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avisos to fetch.
     */
    orderBy?: AvisoOrderByWithRelationInput | AvisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avisos.
     */
    cursor?: AvisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avisos.
     */
    skip?: number
    distinct?: AvisoScalarFieldEnum | AvisoScalarFieldEnum[]
  }

  /**
   * Aviso create
   */
  export type AvisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * The data needed to create a Aviso.
     */
    data: XOR<AvisoCreateInput, AvisoUncheckedCreateInput>
  }

  /**
   * Aviso createMany
   */
  export type AvisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avisos.
     */
    data: AvisoCreateManyInput | AvisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Aviso createManyAndReturn
   */
  export type AvisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Avisos.
     */
    data: AvisoCreateManyInput | AvisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Aviso update
   */
  export type AvisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * The data needed to update a Aviso.
     */
    data: XOR<AvisoUpdateInput, AvisoUncheckedUpdateInput>
    /**
     * Choose, which Aviso to update.
     */
    where: AvisoWhereUniqueInput
  }

  /**
   * Aviso updateMany
   */
  export type AvisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avisos.
     */
    data: XOR<AvisoUpdateManyMutationInput, AvisoUncheckedUpdateManyInput>
    /**
     * Filter which Avisos to update
     */
    where?: AvisoWhereInput
  }

  /**
   * Aviso upsert
   */
  export type AvisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * The filter to search for the Aviso to update in case it exists.
     */
    where: AvisoWhereUniqueInput
    /**
     * In case the Aviso found by the `where` argument doesn't exist, create a new Aviso with this data.
     */
    create: XOR<AvisoCreateInput, AvisoUncheckedCreateInput>
    /**
     * In case the Aviso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvisoUpdateInput, AvisoUncheckedUpdateInput>
  }

  /**
   * Aviso delete
   */
  export type AvisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
    /**
     * Filter which Aviso to delete.
     */
    where: AvisoWhereUniqueInput
  }

  /**
   * Aviso deleteMany
   */
  export type AvisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avisos to delete
     */
    where?: AvisoWhereInput
  }

  /**
   * Aviso without action
   */
  export type AvisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aviso
     */
    select?: AvisoSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senhaHash: 'senhaHash',
    role: 'role',
    apartamento: 'apartamento',
    bloco: 'bloco',
    unidadeId: 'unidadeId',
    ativo: 'ativo',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AreaComumScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao',
    horarioInicio: 'horarioInicio',
    horarioFim: 'horarioFim',
    createdAt: 'createdAt'
  };

  export type AreaComumScalarFieldEnum = (typeof AreaComumScalarFieldEnum)[keyof typeof AreaComumScalarFieldEnum]


  export const CondominioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cnpj: 'cnpj',
    endereco: 'endereco',
    createdAt: 'createdAt'
  };

  export type CondominioScalarFieldEnum = (typeof CondominioScalarFieldEnum)[keyof typeof CondominioScalarFieldEnum]


  export const BlocoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    condominioId: 'condominioId'
  };

  export type BlocoScalarFieldEnum = (typeof BlocoScalarFieldEnum)[keyof typeof BlocoScalarFieldEnum]


  export const UnidadeScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    blocoId: 'blocoId',
    createdAt: 'createdAt'
  };

  export type UnidadeScalarFieldEnum = (typeof UnidadeScalarFieldEnum)[keyof typeof UnidadeScalarFieldEnum]


  export const ConfigReservaScalarFieldEnum: {
    id: 'id',
    condominioId: 'condominioId',
    limitePorMes: 'limitePorMes',
    antecedenciaDias: 'antecedenciaDias',
    horarioInicio: 'horarioInicio',
    horarioFim: 'horarioFim'
  };

  export type ConfigReservaScalarFieldEnum = (typeof ConfigReservaScalarFieldEnum)[keyof typeof ConfigReservaScalarFieldEnum]


  export const CobrancaScalarFieldEnum: {
    id: 'id',
    unidadeId: 'unidadeId',
    mesRef: 'mesRef',
    valor: 'valor',
    status: 'status',
    vencimento: 'vencimento',
    boletoUrl: 'boletoUrl',
    linhaDigitavel: 'linhaDigitavel',
    createdAt: 'createdAt'
  };

  export type CobrancaScalarFieldEnum = (typeof CobrancaScalarFieldEnum)[keyof typeof CobrancaScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    cobrancaId: 'cobrancaId',
    valor: 'valor',
    pagoEm: 'pagoEm',
    comprovanteUrl: 'comprovanteUrl'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const LogAuditoriaScalarFieldEnum: {
    id: 'id',
    acao: 'acao',
    entidade: 'entidade',
    entidadeId: 'entidadeId',
    before: 'before',
    after: 'after',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LogAuditoriaScalarFieldEnum = (typeof LogAuditoriaScalarFieldEnum)[keyof typeof LogAuditoriaScalarFieldEnum]


  export const ReservaScalarFieldEnum: {
    id: 'id',
    data: 'data',
    horarioInicio: 'horarioInicio',
    horarioFim: 'horarioFim',
    status: 'status',
    cancelReason: 'cancelReason',
    cancelledById: 'cancelledById',
    createdAt: 'createdAt',
    areaId: 'areaId',
    moradorId: 'moradorId'
  };

  export type ReservaScalarFieldEnum = (typeof ReservaScalarFieldEnum)[keyof typeof ReservaScalarFieldEnum]


  export const VisitorLogScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    documento: 'documento',
    apartamento: 'apartamento',
    bloco: 'bloco',
    dataEntrada: 'dataEntrada',
    dataSaida: 'dataSaida',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type VisitorLogScalarFieldEnum = (typeof VisitorLogScalarFieldEnum)[keyof typeof VisitorLogScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    destinatarioEmail: 'destinatarioEmail',
    fotoUrl: 'fotoUrl',
    assinaturaUrl: 'assinaturaUrl',
    status: 'status',
    chegouEm: 'chegouEm',
    entregueEm: 'entregueEm',
    createdById: 'createdById',
    destinatarioId: 'destinatarioId'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const ShiftNoteScalarFieldEnum: {
    id: 'id',
    texto: 'texto',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type ShiftNoteScalarFieldEnum = (typeof ShiftNoteScalarFieldEnum)[keyof typeof ShiftNoteScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    mensagem: 'mensagem',
    imageUrl: 'imageUrl',
    lida: 'lida',
    createdAt: 'createdAt',
    userId: 'userId',
    deliveryId: 'deliveryId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AvisoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    conteudo: 'conteudo',
    createdAt: 'createdAt'
  };

  export type AvisoScalarFieldEnum = (typeof AvisoScalarFieldEnum)[keyof typeof AvisoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    senhaHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    apartamento?: StringNullableFilter<"User"> | string | null
    bloco?: StringNullableFilter<"User"> | string | null
    unidadeId?: StringNullableFilter<"User"> | string | null
    ativo?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    reservas?: ReservaListRelationFilter
    cancelacoes?: ReservaListRelationFilter
    visitanteRegistros?: VisitorLogListRelationFilter
    entregasCriadas?: DeliveryListRelationFilter
    entregasRecebidas?: DeliveryListRelationFilter
    plantaoNotas?: ShiftNoteListRelationFilter
    notificacoes?: NotificationListRelationFilter
    unidade?: XOR<UnidadeNullableRelationFilter, UnidadeWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    apartamento?: SortOrderInput | SortOrder
    bloco?: SortOrderInput | SortOrder
    unidadeId?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    reservas?: ReservaOrderByRelationAggregateInput
    cancelacoes?: ReservaOrderByRelationAggregateInput
    visitanteRegistros?: VisitorLogOrderByRelationAggregateInput
    entregasCriadas?: DeliveryOrderByRelationAggregateInput
    entregasRecebidas?: DeliveryOrderByRelationAggregateInput
    plantaoNotas?: ShiftNoteOrderByRelationAggregateInput
    notificacoes?: NotificationOrderByRelationAggregateInput
    unidade?: UnidadeOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nome?: StringFilter<"User"> | string
    senhaHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    apartamento?: StringNullableFilter<"User"> | string | null
    bloco?: StringNullableFilter<"User"> | string | null
    unidadeId?: StringNullableFilter<"User"> | string | null
    ativo?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    reservas?: ReservaListRelationFilter
    cancelacoes?: ReservaListRelationFilter
    visitanteRegistros?: VisitorLogListRelationFilter
    entregasCriadas?: DeliveryListRelationFilter
    entregasRecebidas?: DeliveryListRelationFilter
    plantaoNotas?: ShiftNoteListRelationFilter
    notificacoes?: NotificationListRelationFilter
    unidade?: XOR<UnidadeNullableRelationFilter, UnidadeWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    apartamento?: SortOrderInput | SortOrder
    bloco?: SortOrderInput | SortOrder
    unidadeId?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    nome?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    senhaHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    apartamento?: StringNullableWithAggregatesFilter<"User"> | string | null
    bloco?: StringNullableWithAggregatesFilter<"User"> | string | null
    unidadeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    ativo?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AreaComumWhereInput = {
    AND?: AreaComumWhereInput | AreaComumWhereInput[]
    OR?: AreaComumWhereInput[]
    NOT?: AreaComumWhereInput | AreaComumWhereInput[]
    id?: StringFilter<"AreaComum"> | string
    nome?: StringFilter<"AreaComum"> | string
    descricao?: StringNullableFilter<"AreaComum"> | string | null
    horarioInicio?: StringNullableFilter<"AreaComum"> | string | null
    horarioFim?: StringNullableFilter<"AreaComum"> | string | null
    createdAt?: DateTimeFilter<"AreaComum"> | Date | string
    reservas?: ReservaListRelationFilter
  }

  export type AreaComumOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    horarioInicio?: SortOrderInput | SortOrder
    horarioFim?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reservas?: ReservaOrderByRelationAggregateInput
  }

  export type AreaComumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AreaComumWhereInput | AreaComumWhereInput[]
    OR?: AreaComumWhereInput[]
    NOT?: AreaComumWhereInput | AreaComumWhereInput[]
    nome?: StringFilter<"AreaComum"> | string
    descricao?: StringNullableFilter<"AreaComum"> | string | null
    horarioInicio?: StringNullableFilter<"AreaComum"> | string | null
    horarioFim?: StringNullableFilter<"AreaComum"> | string | null
    createdAt?: DateTimeFilter<"AreaComum"> | Date | string
    reservas?: ReservaListRelationFilter
  }, "id">

  export type AreaComumOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    horarioInicio?: SortOrderInput | SortOrder
    horarioFim?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AreaComumCountOrderByAggregateInput
    _max?: AreaComumMaxOrderByAggregateInput
    _min?: AreaComumMinOrderByAggregateInput
  }

  export type AreaComumScalarWhereWithAggregatesInput = {
    AND?: AreaComumScalarWhereWithAggregatesInput | AreaComumScalarWhereWithAggregatesInput[]
    OR?: AreaComumScalarWhereWithAggregatesInput[]
    NOT?: AreaComumScalarWhereWithAggregatesInput | AreaComumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AreaComum"> | string
    nome?: StringWithAggregatesFilter<"AreaComum"> | string
    descricao?: StringNullableWithAggregatesFilter<"AreaComum"> | string | null
    horarioInicio?: StringNullableWithAggregatesFilter<"AreaComum"> | string | null
    horarioFim?: StringNullableWithAggregatesFilter<"AreaComum"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AreaComum"> | Date | string
  }

  export type CondominioWhereInput = {
    AND?: CondominioWhereInput | CondominioWhereInput[]
    OR?: CondominioWhereInput[]
    NOT?: CondominioWhereInput | CondominioWhereInput[]
    id?: StringFilter<"Condominio"> | string
    nome?: StringFilter<"Condominio"> | string
    cnpj?: StringNullableFilter<"Condominio"> | string | null
    endereco?: StringNullableFilter<"Condominio"> | string | null
    createdAt?: DateTimeFilter<"Condominio"> | Date | string
    blocos?: BlocoListRelationFilter
    configuracoes?: XOR<ConfigReservaNullableRelationFilter, ConfigReservaWhereInput> | null
  }

  export type CondominioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    blocos?: BlocoOrderByRelationAggregateInput
    configuracoes?: ConfigReservaOrderByWithRelationInput
  }

  export type CondominioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CondominioWhereInput | CondominioWhereInput[]
    OR?: CondominioWhereInput[]
    NOT?: CondominioWhereInput | CondominioWhereInput[]
    nome?: StringFilter<"Condominio"> | string
    cnpj?: StringNullableFilter<"Condominio"> | string | null
    endereco?: StringNullableFilter<"Condominio"> | string | null
    createdAt?: DateTimeFilter<"Condominio"> | Date | string
    blocos?: BlocoListRelationFilter
    configuracoes?: XOR<ConfigReservaNullableRelationFilter, ConfigReservaWhereInput> | null
  }, "id">

  export type CondominioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CondominioCountOrderByAggregateInput
    _max?: CondominioMaxOrderByAggregateInput
    _min?: CondominioMinOrderByAggregateInput
  }

  export type CondominioScalarWhereWithAggregatesInput = {
    AND?: CondominioScalarWhereWithAggregatesInput | CondominioScalarWhereWithAggregatesInput[]
    OR?: CondominioScalarWhereWithAggregatesInput[]
    NOT?: CondominioScalarWhereWithAggregatesInput | CondominioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Condominio"> | string
    nome?: StringWithAggregatesFilter<"Condominio"> | string
    cnpj?: StringNullableWithAggregatesFilter<"Condominio"> | string | null
    endereco?: StringNullableWithAggregatesFilter<"Condominio"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Condominio"> | Date | string
  }

  export type BlocoWhereInput = {
    AND?: BlocoWhereInput | BlocoWhereInput[]
    OR?: BlocoWhereInput[]
    NOT?: BlocoWhereInput | BlocoWhereInput[]
    id?: StringFilter<"Bloco"> | string
    nome?: StringFilter<"Bloco"> | string
    condominioId?: StringFilter<"Bloco"> | string
    condominio?: XOR<CondominioRelationFilter, CondominioWhereInput>
    unidades?: UnidadeListRelationFilter
  }

  export type BlocoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    condominioId?: SortOrder
    condominio?: CondominioOrderByWithRelationInput
    unidades?: UnidadeOrderByRelationAggregateInput
  }

  export type BlocoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlocoWhereInput | BlocoWhereInput[]
    OR?: BlocoWhereInput[]
    NOT?: BlocoWhereInput | BlocoWhereInput[]
    nome?: StringFilter<"Bloco"> | string
    condominioId?: StringFilter<"Bloco"> | string
    condominio?: XOR<CondominioRelationFilter, CondominioWhereInput>
    unidades?: UnidadeListRelationFilter
  }, "id">

  export type BlocoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    condominioId?: SortOrder
    _count?: BlocoCountOrderByAggregateInput
    _max?: BlocoMaxOrderByAggregateInput
    _min?: BlocoMinOrderByAggregateInput
  }

  export type BlocoScalarWhereWithAggregatesInput = {
    AND?: BlocoScalarWhereWithAggregatesInput | BlocoScalarWhereWithAggregatesInput[]
    OR?: BlocoScalarWhereWithAggregatesInput[]
    NOT?: BlocoScalarWhereWithAggregatesInput | BlocoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bloco"> | string
    nome?: StringWithAggregatesFilter<"Bloco"> | string
    condominioId?: StringWithAggregatesFilter<"Bloco"> | string
  }

  export type UnidadeWhereInput = {
    AND?: UnidadeWhereInput | UnidadeWhereInput[]
    OR?: UnidadeWhereInput[]
    NOT?: UnidadeWhereInput | UnidadeWhereInput[]
    id?: StringFilter<"Unidade"> | string
    numero?: StringFilter<"Unidade"> | string
    blocoId?: StringFilter<"Unidade"> | string
    createdAt?: DateTimeFilter<"Unidade"> | Date | string
    bloco?: XOR<BlocoRelationFilter, BlocoWhereInput>
    moradores?: UserListRelationFilter
    cobrancas?: CobrancaListRelationFilter
  }

  export type UnidadeOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    blocoId?: SortOrder
    createdAt?: SortOrder
    bloco?: BlocoOrderByWithRelationInput
    moradores?: UserOrderByRelationAggregateInput
    cobrancas?: CobrancaOrderByRelationAggregateInput
  }

  export type UnidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnidadeWhereInput | UnidadeWhereInput[]
    OR?: UnidadeWhereInput[]
    NOT?: UnidadeWhereInput | UnidadeWhereInput[]
    numero?: StringFilter<"Unidade"> | string
    blocoId?: StringFilter<"Unidade"> | string
    createdAt?: DateTimeFilter<"Unidade"> | Date | string
    bloco?: XOR<BlocoRelationFilter, BlocoWhereInput>
    moradores?: UserListRelationFilter
    cobrancas?: CobrancaListRelationFilter
  }, "id">

  export type UnidadeOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    blocoId?: SortOrder
    createdAt?: SortOrder
    _count?: UnidadeCountOrderByAggregateInput
    _max?: UnidadeMaxOrderByAggregateInput
    _min?: UnidadeMinOrderByAggregateInput
  }

  export type UnidadeScalarWhereWithAggregatesInput = {
    AND?: UnidadeScalarWhereWithAggregatesInput | UnidadeScalarWhereWithAggregatesInput[]
    OR?: UnidadeScalarWhereWithAggregatesInput[]
    NOT?: UnidadeScalarWhereWithAggregatesInput | UnidadeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unidade"> | string
    numero?: StringWithAggregatesFilter<"Unidade"> | string
    blocoId?: StringWithAggregatesFilter<"Unidade"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Unidade"> | Date | string
  }

  export type ConfigReservaWhereInput = {
    AND?: ConfigReservaWhereInput | ConfigReservaWhereInput[]
    OR?: ConfigReservaWhereInput[]
    NOT?: ConfigReservaWhereInput | ConfigReservaWhereInput[]
    id?: StringFilter<"ConfigReserva"> | string
    condominioId?: StringFilter<"ConfigReserva"> | string
    limitePorMes?: IntFilter<"ConfigReserva"> | number
    antecedenciaDias?: IntFilter<"ConfigReserva"> | number
    horarioInicio?: StringNullableFilter<"ConfigReserva"> | string | null
    horarioFim?: StringNullableFilter<"ConfigReserva"> | string | null
    condominio?: XOR<CondominioRelationFilter, CondominioWhereInput>
  }

  export type ConfigReservaOrderByWithRelationInput = {
    id?: SortOrder
    condominioId?: SortOrder
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
    horarioInicio?: SortOrderInput | SortOrder
    horarioFim?: SortOrderInput | SortOrder
    condominio?: CondominioOrderByWithRelationInput
  }

  export type ConfigReservaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    condominioId?: string
    AND?: ConfigReservaWhereInput | ConfigReservaWhereInput[]
    OR?: ConfigReservaWhereInput[]
    NOT?: ConfigReservaWhereInput | ConfigReservaWhereInput[]
    limitePorMes?: IntFilter<"ConfigReserva"> | number
    antecedenciaDias?: IntFilter<"ConfigReserva"> | number
    horarioInicio?: StringNullableFilter<"ConfigReserva"> | string | null
    horarioFim?: StringNullableFilter<"ConfigReserva"> | string | null
    condominio?: XOR<CondominioRelationFilter, CondominioWhereInput>
  }, "id" | "condominioId">

  export type ConfigReservaOrderByWithAggregationInput = {
    id?: SortOrder
    condominioId?: SortOrder
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
    horarioInicio?: SortOrderInput | SortOrder
    horarioFim?: SortOrderInput | SortOrder
    _count?: ConfigReservaCountOrderByAggregateInput
    _avg?: ConfigReservaAvgOrderByAggregateInput
    _max?: ConfigReservaMaxOrderByAggregateInput
    _min?: ConfigReservaMinOrderByAggregateInput
    _sum?: ConfigReservaSumOrderByAggregateInput
  }

  export type ConfigReservaScalarWhereWithAggregatesInput = {
    AND?: ConfigReservaScalarWhereWithAggregatesInput | ConfigReservaScalarWhereWithAggregatesInput[]
    OR?: ConfigReservaScalarWhereWithAggregatesInput[]
    NOT?: ConfigReservaScalarWhereWithAggregatesInput | ConfigReservaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfigReserva"> | string
    condominioId?: StringWithAggregatesFilter<"ConfigReserva"> | string
    limitePorMes?: IntWithAggregatesFilter<"ConfigReserva"> | number
    antecedenciaDias?: IntWithAggregatesFilter<"ConfigReserva"> | number
    horarioInicio?: StringNullableWithAggregatesFilter<"ConfigReserva"> | string | null
    horarioFim?: StringNullableWithAggregatesFilter<"ConfigReserva"> | string | null
  }

  export type CobrancaWhereInput = {
    AND?: CobrancaWhereInput | CobrancaWhereInput[]
    OR?: CobrancaWhereInput[]
    NOT?: CobrancaWhereInput | CobrancaWhereInput[]
    id?: StringFilter<"Cobranca"> | string
    unidadeId?: StringFilter<"Cobranca"> | string
    mesRef?: StringFilter<"Cobranca"> | string
    valor?: DecimalFilter<"Cobranca"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Cobranca"> | string
    vencimento?: DateTimeFilter<"Cobranca"> | Date | string
    boletoUrl?: StringNullableFilter<"Cobranca"> | string | null
    linhaDigitavel?: StringNullableFilter<"Cobranca"> | string | null
    createdAt?: DateTimeFilter<"Cobranca"> | Date | string
    unidade?: XOR<UnidadeRelationFilter, UnidadeWhereInput>
    pagamentos?: PagamentoListRelationFilter
  }

  export type CobrancaOrderByWithRelationInput = {
    id?: SortOrder
    unidadeId?: SortOrder
    mesRef?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    vencimento?: SortOrder
    boletoUrl?: SortOrderInput | SortOrder
    linhaDigitavel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    unidade?: UnidadeOrderByWithRelationInput
    pagamentos?: PagamentoOrderByRelationAggregateInput
  }

  export type CobrancaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CobrancaWhereInput | CobrancaWhereInput[]
    OR?: CobrancaWhereInput[]
    NOT?: CobrancaWhereInput | CobrancaWhereInput[]
    unidadeId?: StringFilter<"Cobranca"> | string
    mesRef?: StringFilter<"Cobranca"> | string
    valor?: DecimalFilter<"Cobranca"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Cobranca"> | string
    vencimento?: DateTimeFilter<"Cobranca"> | Date | string
    boletoUrl?: StringNullableFilter<"Cobranca"> | string | null
    linhaDigitavel?: StringNullableFilter<"Cobranca"> | string | null
    createdAt?: DateTimeFilter<"Cobranca"> | Date | string
    unidade?: XOR<UnidadeRelationFilter, UnidadeWhereInput>
    pagamentos?: PagamentoListRelationFilter
  }, "id">

  export type CobrancaOrderByWithAggregationInput = {
    id?: SortOrder
    unidadeId?: SortOrder
    mesRef?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    vencimento?: SortOrder
    boletoUrl?: SortOrderInput | SortOrder
    linhaDigitavel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CobrancaCountOrderByAggregateInput
    _avg?: CobrancaAvgOrderByAggregateInput
    _max?: CobrancaMaxOrderByAggregateInput
    _min?: CobrancaMinOrderByAggregateInput
    _sum?: CobrancaSumOrderByAggregateInput
  }

  export type CobrancaScalarWhereWithAggregatesInput = {
    AND?: CobrancaScalarWhereWithAggregatesInput | CobrancaScalarWhereWithAggregatesInput[]
    OR?: CobrancaScalarWhereWithAggregatesInput[]
    NOT?: CobrancaScalarWhereWithAggregatesInput | CobrancaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cobranca"> | string
    unidadeId?: StringWithAggregatesFilter<"Cobranca"> | string
    mesRef?: StringWithAggregatesFilter<"Cobranca"> | string
    valor?: DecimalWithAggregatesFilter<"Cobranca"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Cobranca"> | string
    vencimento?: DateTimeWithAggregatesFilter<"Cobranca"> | Date | string
    boletoUrl?: StringNullableWithAggregatesFilter<"Cobranca"> | string | null
    linhaDigitavel?: StringNullableWithAggregatesFilter<"Cobranca"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cobranca"> | Date | string
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: StringFilter<"Pagamento"> | string
    cobrancaId?: StringFilter<"Pagamento"> | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFilter<"Pagamento"> | Date | string
    comprovanteUrl?: StringNullableFilter<"Pagamento"> | string | null
    cobranca?: XOR<CobrancaRelationFilter, CobrancaWhereInput>
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    cobrancaId?: SortOrder
    valor?: SortOrder
    pagoEm?: SortOrder
    comprovanteUrl?: SortOrderInput | SortOrder
    cobranca?: CobrancaOrderByWithRelationInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    cobrancaId?: StringFilter<"Pagamento"> | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFilter<"Pagamento"> | Date | string
    comprovanteUrl?: StringNullableFilter<"Pagamento"> | string | null
    cobranca?: XOR<CobrancaRelationFilter, CobrancaWhereInput>
  }, "id">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    cobrancaId?: SortOrder
    valor?: SortOrder
    pagoEm?: SortOrder
    comprovanteUrl?: SortOrderInput | SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pagamento"> | string
    cobrancaId?: StringWithAggregatesFilter<"Pagamento"> | string
    valor?: DecimalWithAggregatesFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    comprovanteUrl?: StringNullableWithAggregatesFilter<"Pagamento"> | string | null
  }

  export type LogAuditoriaWhereInput = {
    AND?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    OR?: LogAuditoriaWhereInput[]
    NOT?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    id?: StringFilter<"LogAuditoria"> | string
    acao?: StringFilter<"LogAuditoria"> | string
    entidade?: StringFilter<"LogAuditoria"> | string
    entidadeId?: StringNullableFilter<"LogAuditoria"> | string | null
    before?: StringNullableFilter<"LogAuditoria"> | string | null
    after?: StringNullableFilter<"LogAuditoria"> | string | null
    userId?: StringNullableFilter<"LogAuditoria"> | string | null
    createdAt?: DateTimeFilter<"LogAuditoria"> | Date | string
  }

  export type LogAuditoriaOrderByWithRelationInput = {
    id?: SortOrder
    acao?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type LogAuditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    OR?: LogAuditoriaWhereInput[]
    NOT?: LogAuditoriaWhereInput | LogAuditoriaWhereInput[]
    acao?: StringFilter<"LogAuditoria"> | string
    entidade?: StringFilter<"LogAuditoria"> | string
    entidadeId?: StringNullableFilter<"LogAuditoria"> | string | null
    before?: StringNullableFilter<"LogAuditoria"> | string | null
    after?: StringNullableFilter<"LogAuditoria"> | string | null
    userId?: StringNullableFilter<"LogAuditoria"> | string | null
    createdAt?: DateTimeFilter<"LogAuditoria"> | Date | string
  }, "id">

  export type LogAuditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    acao?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LogAuditoriaCountOrderByAggregateInput
    _max?: LogAuditoriaMaxOrderByAggregateInput
    _min?: LogAuditoriaMinOrderByAggregateInput
  }

  export type LogAuditoriaScalarWhereWithAggregatesInput = {
    AND?: LogAuditoriaScalarWhereWithAggregatesInput | LogAuditoriaScalarWhereWithAggregatesInput[]
    OR?: LogAuditoriaScalarWhereWithAggregatesInput[]
    NOT?: LogAuditoriaScalarWhereWithAggregatesInput | LogAuditoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogAuditoria"> | string
    acao?: StringWithAggregatesFilter<"LogAuditoria"> | string
    entidade?: StringWithAggregatesFilter<"LogAuditoria"> | string
    entidadeId?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    before?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    after?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    userId?: StringNullableWithAggregatesFilter<"LogAuditoria"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LogAuditoria"> | Date | string
  }

  export type ReservaWhereInput = {
    AND?: ReservaWhereInput | ReservaWhereInput[]
    OR?: ReservaWhereInput[]
    NOT?: ReservaWhereInput | ReservaWhereInput[]
    id?: StringFilter<"Reserva"> | string
    data?: DateTimeFilter<"Reserva"> | Date | string
    horarioInicio?: StringFilter<"Reserva"> | string
    horarioFim?: StringFilter<"Reserva"> | string
    status?: StringFilter<"Reserva"> | string
    cancelReason?: StringNullableFilter<"Reserva"> | string | null
    cancelledById?: StringNullableFilter<"Reserva"> | string | null
    createdAt?: DateTimeFilter<"Reserva"> | Date | string
    areaId?: StringFilter<"Reserva"> | string
    moradorId?: StringFilter<"Reserva"> | string
    area?: XOR<AreaComumRelationFilter, AreaComumWhereInput>
    morador?: XOR<UserRelationFilter, UserWhereInput>
    cancelledBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ReservaOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrderInput | SortOrder
    cancelledById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    moradorId?: SortOrder
    area?: AreaComumOrderByWithRelationInput
    morador?: UserOrderByWithRelationInput
    cancelledBy?: UserOrderByWithRelationInput
  }

  export type ReservaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservaWhereInput | ReservaWhereInput[]
    OR?: ReservaWhereInput[]
    NOT?: ReservaWhereInput | ReservaWhereInput[]
    data?: DateTimeFilter<"Reserva"> | Date | string
    horarioInicio?: StringFilter<"Reserva"> | string
    horarioFim?: StringFilter<"Reserva"> | string
    status?: StringFilter<"Reserva"> | string
    cancelReason?: StringNullableFilter<"Reserva"> | string | null
    cancelledById?: StringNullableFilter<"Reserva"> | string | null
    createdAt?: DateTimeFilter<"Reserva"> | Date | string
    areaId?: StringFilter<"Reserva"> | string
    moradorId?: StringFilter<"Reserva"> | string
    area?: XOR<AreaComumRelationFilter, AreaComumWhereInput>
    morador?: XOR<UserRelationFilter, UserWhereInput>
    cancelledBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReservaOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrderInput | SortOrder
    cancelledById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    moradorId?: SortOrder
    _count?: ReservaCountOrderByAggregateInput
    _max?: ReservaMaxOrderByAggregateInput
    _min?: ReservaMinOrderByAggregateInput
  }

  export type ReservaScalarWhereWithAggregatesInput = {
    AND?: ReservaScalarWhereWithAggregatesInput | ReservaScalarWhereWithAggregatesInput[]
    OR?: ReservaScalarWhereWithAggregatesInput[]
    NOT?: ReservaScalarWhereWithAggregatesInput | ReservaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reserva"> | string
    data?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    horarioInicio?: StringWithAggregatesFilter<"Reserva"> | string
    horarioFim?: StringWithAggregatesFilter<"Reserva"> | string
    status?: StringWithAggregatesFilter<"Reserva"> | string
    cancelReason?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
    cancelledById?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    areaId?: StringWithAggregatesFilter<"Reserva"> | string
    moradorId?: StringWithAggregatesFilter<"Reserva"> | string
  }

  export type VisitorLogWhereInput = {
    AND?: VisitorLogWhereInput | VisitorLogWhereInput[]
    OR?: VisitorLogWhereInput[]
    NOT?: VisitorLogWhereInput | VisitorLogWhereInput[]
    id?: StringFilter<"VisitorLog"> | string
    nome?: StringFilter<"VisitorLog"> | string
    documento?: StringNullableFilter<"VisitorLog"> | string | null
    apartamento?: StringNullableFilter<"VisitorLog"> | string | null
    bloco?: StringNullableFilter<"VisitorLog"> | string | null
    dataEntrada?: DateTimeFilter<"VisitorLog"> | Date | string
    dataSaida?: DateTimeNullableFilter<"VisitorLog"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitorLog"> | Date | string
    createdById?: StringFilter<"VisitorLog"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VisitorLogOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrderInput | SortOrder
    apartamento?: SortOrderInput | SortOrder
    bloco?: SortOrderInput | SortOrder
    dataEntrada?: SortOrder
    dataSaida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type VisitorLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitorLogWhereInput | VisitorLogWhereInput[]
    OR?: VisitorLogWhereInput[]
    NOT?: VisitorLogWhereInput | VisitorLogWhereInput[]
    nome?: StringFilter<"VisitorLog"> | string
    documento?: StringNullableFilter<"VisitorLog"> | string | null
    apartamento?: StringNullableFilter<"VisitorLog"> | string | null
    bloco?: StringNullableFilter<"VisitorLog"> | string | null
    dataEntrada?: DateTimeFilter<"VisitorLog"> | Date | string
    dataSaida?: DateTimeNullableFilter<"VisitorLog"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitorLog"> | Date | string
    createdById?: StringFilter<"VisitorLog"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VisitorLogOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrderInput | SortOrder
    apartamento?: SortOrderInput | SortOrder
    bloco?: SortOrderInput | SortOrder
    dataEntrada?: SortOrder
    dataSaida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    _count?: VisitorLogCountOrderByAggregateInput
    _max?: VisitorLogMaxOrderByAggregateInput
    _min?: VisitorLogMinOrderByAggregateInput
  }

  export type VisitorLogScalarWhereWithAggregatesInput = {
    AND?: VisitorLogScalarWhereWithAggregatesInput | VisitorLogScalarWhereWithAggregatesInput[]
    OR?: VisitorLogScalarWhereWithAggregatesInput[]
    NOT?: VisitorLogScalarWhereWithAggregatesInput | VisitorLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitorLog"> | string
    nome?: StringWithAggregatesFilter<"VisitorLog"> | string
    documento?: StringNullableWithAggregatesFilter<"VisitorLog"> | string | null
    apartamento?: StringNullableWithAggregatesFilter<"VisitorLog"> | string | null
    bloco?: StringNullableWithAggregatesFilter<"VisitorLog"> | string | null
    dataEntrada?: DateTimeWithAggregatesFilter<"VisitorLog"> | Date | string
    dataSaida?: DateTimeNullableWithAggregatesFilter<"VisitorLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisitorLog"> | Date | string
    createdById?: StringWithAggregatesFilter<"VisitorLog"> | string
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: StringFilter<"Delivery"> | string
    descricao?: StringFilter<"Delivery"> | string
    destinatarioEmail?: StringNullableFilter<"Delivery"> | string | null
    fotoUrl?: StringNullableFilter<"Delivery"> | string | null
    assinaturaUrl?: StringNullableFilter<"Delivery"> | string | null
    status?: StringFilter<"Delivery"> | string
    chegouEm?: DateTimeFilter<"Delivery"> | Date | string
    entregueEm?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    createdById?: StringFilter<"Delivery"> | string
    destinatarioId?: StringNullableFilter<"Delivery"> | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    destinatario?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    notificacoes?: NotificationListRelationFilter
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    destinatarioEmail?: SortOrderInput | SortOrder
    fotoUrl?: SortOrderInput | SortOrder
    assinaturaUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    chegouEm?: SortOrder
    entregueEm?: SortOrderInput | SortOrder
    createdById?: SortOrder
    destinatarioId?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    destinatario?: UserOrderByWithRelationInput
    notificacoes?: NotificationOrderByRelationAggregateInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    descricao?: StringFilter<"Delivery"> | string
    destinatarioEmail?: StringNullableFilter<"Delivery"> | string | null
    fotoUrl?: StringNullableFilter<"Delivery"> | string | null
    assinaturaUrl?: StringNullableFilter<"Delivery"> | string | null
    status?: StringFilter<"Delivery"> | string
    chegouEm?: DateTimeFilter<"Delivery"> | Date | string
    entregueEm?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    createdById?: StringFilter<"Delivery"> | string
    destinatarioId?: StringNullableFilter<"Delivery"> | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    destinatario?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    notificacoes?: NotificationListRelationFilter
  }, "id">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    destinatarioEmail?: SortOrderInput | SortOrder
    fotoUrl?: SortOrderInput | SortOrder
    assinaturaUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    chegouEm?: SortOrder
    entregueEm?: SortOrderInput | SortOrder
    createdById?: SortOrder
    destinatarioId?: SortOrderInput | SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delivery"> | string
    descricao?: StringWithAggregatesFilter<"Delivery"> | string
    destinatarioEmail?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    fotoUrl?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    assinaturaUrl?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    status?: StringWithAggregatesFilter<"Delivery"> | string
    chegouEm?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    entregueEm?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"Delivery"> | string
    destinatarioId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
  }

  export type ShiftNoteWhereInput = {
    AND?: ShiftNoteWhereInput | ShiftNoteWhereInput[]
    OR?: ShiftNoteWhereInput[]
    NOT?: ShiftNoteWhereInput | ShiftNoteWhereInput[]
    id?: StringFilter<"ShiftNote"> | string
    texto?: StringFilter<"ShiftNote"> | string
    createdAt?: DateTimeFilter<"ShiftNote"> | Date | string
    createdById?: StringFilter<"ShiftNote"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ShiftNoteOrderByWithRelationInput = {
    id?: SortOrder
    texto?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type ShiftNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftNoteWhereInput | ShiftNoteWhereInput[]
    OR?: ShiftNoteWhereInput[]
    NOT?: ShiftNoteWhereInput | ShiftNoteWhereInput[]
    texto?: StringFilter<"ShiftNote"> | string
    createdAt?: DateTimeFilter<"ShiftNote"> | Date | string
    createdById?: StringFilter<"ShiftNote"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ShiftNoteOrderByWithAggregationInput = {
    id?: SortOrder
    texto?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    _count?: ShiftNoteCountOrderByAggregateInput
    _max?: ShiftNoteMaxOrderByAggregateInput
    _min?: ShiftNoteMinOrderByAggregateInput
  }

  export type ShiftNoteScalarWhereWithAggregatesInput = {
    AND?: ShiftNoteScalarWhereWithAggregatesInput | ShiftNoteScalarWhereWithAggregatesInput[]
    OR?: ShiftNoteScalarWhereWithAggregatesInput[]
    NOT?: ShiftNoteScalarWhereWithAggregatesInput | ShiftNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftNote"> | string
    texto?: StringWithAggregatesFilter<"ShiftNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShiftNote"> | Date | string
    createdById?: StringWithAggregatesFilter<"ShiftNote"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    titulo?: StringFilter<"Notification"> | string
    mensagem?: StringFilter<"Notification"> | string
    imageUrl?: StringNullableFilter<"Notification"> | string | null
    lida?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    deliveryId?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    mensagem?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    lida?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    deliveryId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    delivery?: DeliveryOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    titulo?: StringFilter<"Notification"> | string
    mensagem?: StringFilter<"Notification"> | string
    imageUrl?: StringNullableFilter<"Notification"> | string | null
    lida?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    deliveryId?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    mensagem?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    lida?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    deliveryId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    titulo?: StringWithAggregatesFilter<"Notification"> | string
    mensagem?: StringWithAggregatesFilter<"Notification"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    lida?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    deliveryId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type AvisoWhereInput = {
    AND?: AvisoWhereInput | AvisoWhereInput[]
    OR?: AvisoWhereInput[]
    NOT?: AvisoWhereInput | AvisoWhereInput[]
    id?: StringFilter<"Aviso"> | string
    titulo?: StringFilter<"Aviso"> | string
    conteudo?: StringFilter<"Aviso"> | string
    createdAt?: DateTimeFilter<"Aviso"> | Date | string
  }

  export type AvisoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
  }

  export type AvisoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvisoWhereInput | AvisoWhereInput[]
    OR?: AvisoWhereInput[]
    NOT?: AvisoWhereInput | AvisoWhereInput[]
    titulo?: StringFilter<"Aviso"> | string
    conteudo?: StringFilter<"Aviso"> | string
    createdAt?: DateTimeFilter<"Aviso"> | Date | string
  }, "id">

  export type AvisoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    _count?: AvisoCountOrderByAggregateInput
    _max?: AvisoMaxOrderByAggregateInput
    _min?: AvisoMinOrderByAggregateInput
  }

  export type AvisoScalarWhereWithAggregatesInput = {
    AND?: AvisoScalarWhereWithAggregatesInput | AvisoScalarWhereWithAggregatesInput[]
    OR?: AvisoScalarWhereWithAggregatesInput[]
    NOT?: AvisoScalarWhereWithAggregatesInput | AvisoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Aviso"> | string
    titulo?: StringWithAggregatesFilter<"Aviso"> | string
    conteudo?: StringWithAggregatesFilter<"Aviso"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Aviso"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaComumCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    horarioInicio?: string | null
    horarioFim?: string | null
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutAreaInput
  }

  export type AreaComumUncheckedCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    horarioInicio?: string | null
    horarioFim?: string | null
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaComumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutAreaNestedInput
  }

  export type AreaComumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaComumCreateManyInput = {
    id?: string
    nome: string
    descricao?: string | null
    horarioInicio?: string | null
    horarioFim?: string | null
    createdAt?: Date | string
  }

  export type AreaComumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaComumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CondominioCreateInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
    blocos?: BlocoCreateNestedManyWithoutCondominioInput
    configuracoes?: ConfigReservaCreateNestedOneWithoutCondominioInput
  }

  export type CondominioUncheckedCreateInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
    blocos?: BlocoUncheckedCreateNestedManyWithoutCondominioInput
    configuracoes?: ConfigReservaUncheckedCreateNestedOneWithoutCondominioInput
  }

  export type CondominioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocos?: BlocoUpdateManyWithoutCondominioNestedInput
    configuracoes?: ConfigReservaUpdateOneWithoutCondominioNestedInput
  }

  export type CondominioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocos?: BlocoUncheckedUpdateManyWithoutCondominioNestedInput
    configuracoes?: ConfigReservaUncheckedUpdateOneWithoutCondominioNestedInput
  }

  export type CondominioCreateManyInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
  }

  export type CondominioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CondominioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlocoCreateInput = {
    id?: string
    nome: string
    condominio: CondominioCreateNestedOneWithoutBlocosInput
    unidades?: UnidadeCreateNestedManyWithoutBlocoInput
  }

  export type BlocoUncheckedCreateInput = {
    id?: string
    nome: string
    condominioId: string
    unidades?: UnidadeUncheckedCreateNestedManyWithoutBlocoInput
  }

  export type BlocoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    condominio?: CondominioUpdateOneRequiredWithoutBlocosNestedInput
    unidades?: UnidadeUpdateManyWithoutBlocoNestedInput
  }

  export type BlocoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    condominioId?: StringFieldUpdateOperationsInput | string
    unidades?: UnidadeUncheckedUpdateManyWithoutBlocoNestedInput
  }

  export type BlocoCreateManyInput = {
    id?: string
    nome: string
    condominioId: string
  }

  export type BlocoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type BlocoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    condominioId?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadeCreateInput = {
    id?: string
    numero: string
    createdAt?: Date | string
    bloco: BlocoCreateNestedOneWithoutUnidadesInput
    moradores?: UserCreateNestedManyWithoutUnidadeInput
    cobrancas?: CobrancaCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeUncheckedCreateInput = {
    id?: string
    numero: string
    blocoId: string
    createdAt?: Date | string
    moradores?: UserUncheckedCreateNestedManyWithoutUnidadeInput
    cobrancas?: CobrancaUncheckedCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloco?: BlocoUpdateOneRequiredWithoutUnidadesNestedInput
    moradores?: UserUpdateManyWithoutUnidadeNestedInput
    cobrancas?: CobrancaUpdateManyWithoutUnidadeNestedInput
  }

  export type UnidadeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    blocoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moradores?: UserUncheckedUpdateManyWithoutUnidadeNestedInput
    cobrancas?: CobrancaUncheckedUpdateManyWithoutUnidadeNestedInput
  }

  export type UnidadeCreateManyInput = {
    id?: string
    numero: string
    blocoId: string
    createdAt?: Date | string
  }

  export type UnidadeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnidadeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    blocoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigReservaCreateInput = {
    id?: string
    limitePorMes?: number
    antecedenciaDias?: number
    horarioInicio?: string | null
    horarioFim?: string | null
    condominio: CondominioCreateNestedOneWithoutConfiguracoesInput
  }

  export type ConfigReservaUncheckedCreateInput = {
    id?: string
    condominioId: string
    limitePorMes?: number
    antecedenciaDias?: number
    horarioInicio?: string | null
    horarioFim?: string | null
  }

  export type ConfigReservaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    limitePorMes?: IntFieldUpdateOperationsInput | number
    antecedenciaDias?: IntFieldUpdateOperationsInput | number
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    condominio?: CondominioUpdateOneRequiredWithoutConfiguracoesNestedInput
  }

  export type ConfigReservaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    condominioId?: StringFieldUpdateOperationsInput | string
    limitePorMes?: IntFieldUpdateOperationsInput | number
    antecedenciaDias?: IntFieldUpdateOperationsInput | number
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigReservaCreateManyInput = {
    id?: string
    condominioId: string
    limitePorMes?: number
    antecedenciaDias?: number
    horarioInicio?: string | null
    horarioFim?: string | null
  }

  export type ConfigReservaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    limitePorMes?: IntFieldUpdateOperationsInput | number
    antecedenciaDias?: IntFieldUpdateOperationsInput | number
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigReservaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    condominioId?: StringFieldUpdateOperationsInput | string
    limitePorMes?: IntFieldUpdateOperationsInput | number
    antecedenciaDias?: IntFieldUpdateOperationsInput | number
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CobrancaCreateInput = {
    id?: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
    unidade: UnidadeCreateNestedOneWithoutCobrancasInput
    pagamentos?: PagamentoCreateNestedManyWithoutCobrancaInput
  }

  export type CobrancaUncheckedCreateInput = {
    id?: string
    unidadeId: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutCobrancaInput
  }

  export type CobrancaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unidade?: UnidadeUpdateOneRequiredWithoutCobrancasNestedInput
    pagamentos?: PagamentoUpdateManyWithoutCobrancaNestedInput
  }

  export type CobrancaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unidadeId?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamentos?: PagamentoUncheckedUpdateManyWithoutCobrancaNestedInput
  }

  export type CobrancaCreateManyInput = {
    id?: string
    unidadeId: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
  }

  export type CobrancaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CobrancaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unidadeId?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateInput = {
    id?: string
    valor?: Decimal | DecimalJsLike | number | string
    pagoEm?: Date | string
    comprovanteUrl?: string | null
    cobranca: CobrancaCreateNestedOneWithoutPagamentosInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: string
    cobrancaId: string
    valor?: Decimal | DecimalJsLike | number | string
    pagoEm?: Date | string
    comprovanteUrl?: string | null
  }

  export type PagamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cobranca?: CobrancaUpdateOneRequiredWithoutPagamentosNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cobrancaId?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoCreateManyInput = {
    id?: string
    cobrancaId: string
    valor?: Decimal | DecimalJsLike | number | string
    pagoEm?: Date | string
    comprovanteUrl?: string | null
  }

  export type PagamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cobrancaId?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogAuditoriaCreateInput = {
    id?: string
    acao: string
    entidade: string
    entidadeId?: string | null
    before?: string | null
    after?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LogAuditoriaUncheckedCreateInput = {
    id?: string
    acao: string
    entidade: string
    entidadeId?: string | null
    before?: string | null
    after?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LogAuditoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAuditoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAuditoriaCreateManyInput = {
    id?: string
    acao: string
    entidade: string
    entidadeId?: string | null
    before?: string | null
    after?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LogAuditoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogAuditoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    acao?: StringFieldUpdateOperationsInput | string
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaCreateInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    createdAt?: Date | string
    area: AreaComumCreateNestedOneWithoutReservasInput
    morador: UserCreateNestedOneWithoutReservasInput
    cancelledBy?: UserCreateNestedOneWithoutCancelacoesInput
  }

  export type ReservaUncheckedCreateInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    cancelledById?: string | null
    createdAt?: Date | string
    areaId: string
    moradorId: string
  }

  export type ReservaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaComumUpdateOneRequiredWithoutReservasNestedInput
    morador?: UserUpdateOneRequiredWithoutReservasNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelacoesNestedInput
  }

  export type ReservaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: StringFieldUpdateOperationsInput | string
    moradorId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservaCreateManyInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    cancelledById?: string | null
    createdAt?: Date | string
    areaId: string
    moradorId: string
  }

  export type ReservaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: StringFieldUpdateOperationsInput | string
    moradorId?: StringFieldUpdateOperationsInput | string
  }

  export type VisitorLogCreateInput = {
    id?: string
    nome: string
    documento?: string | null
    apartamento?: string | null
    bloco?: string | null
    dataEntrada?: Date | string
    dataSaida?: Date | string | null
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutVisitanteRegistrosInput
  }

  export type VisitorLogUncheckedCreateInput = {
    id?: string
    nome: string
    documento?: string | null
    apartamento?: string | null
    bloco?: string | null
    dataEntrada?: Date | string
    dataSaida?: Date | string | null
    createdAt?: Date | string
    createdById: string
  }

  export type VisitorLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutVisitanteRegistrosNestedInput
  }

  export type VisitorLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type VisitorLogCreateManyInput = {
    id?: string
    nome: string
    documento?: string | null
    apartamento?: string | null
    bloco?: string | null
    dataEntrada?: Date | string
    dataSaida?: Date | string | null
    createdAt?: Date | string
    createdById: string
  }

  export type VisitorLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryCreateInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdBy: UserCreateNestedOneWithoutEntregasCriadasInput
    destinatario?: UserCreateNestedOneWithoutEntregasRecebidasInput
    notificacoes?: NotificationCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdById: string
    destinatarioId?: string | null
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutEntregasCriadasNestedInput
    destinatario?: UserUpdateOneWithoutEntregasRecebidasNestedInput
    notificacoes?: NotificationUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    destinatarioId?: NullableStringFieldUpdateOperationsInput | string | null
    notificacoes?: NotificationUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryCreateManyInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdById: string
    destinatarioId?: string | null
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    destinatarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftNoteCreateInput = {
    id?: string
    texto: string
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPlantaoNotasInput
  }

  export type ShiftNoteUncheckedCreateInput = {
    id?: string
    texto: string
    createdAt?: Date | string
    createdById: string
  }

  export type ShiftNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPlantaoNotasNestedInput
  }

  export type ShiftNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftNoteCreateManyInput = {
    id?: string
    texto: string
    createdAt?: Date | string
    createdById: string
  }

  export type ShiftNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificacoesInput
    delivery?: DeliveryCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    userId: string
    deliveryId?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificacoesNestedInput
    delivery?: DeliveryUpdateOneWithoutNotificacoesNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    userId: string
    deliveryId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvisoCreateInput = {
    id?: string
    titulo: string
    conteudo: string
    createdAt?: Date | string
  }

  export type AvisoUncheckedCreateInput = {
    id?: string
    titulo: string
    conteudo: string
    createdAt?: Date | string
  }

  export type AvisoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvisoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvisoCreateManyInput = {
    id?: string
    titulo: string
    conteudo: string
    createdAt?: Date | string
  }

  export type AvisoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvisoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReservaListRelationFilter = {
    every?: ReservaWhereInput
    some?: ReservaWhereInput
    none?: ReservaWhereInput
  }

  export type VisitorLogListRelationFilter = {
    every?: VisitorLogWhereInput
    some?: VisitorLogWhereInput
    none?: VisitorLogWhereInput
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type ShiftNoteListRelationFilter = {
    every?: ShiftNoteWhereInput
    some?: ShiftNoteWhereInput
    none?: ShiftNoteWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UnidadeNullableRelationFilter = {
    is?: UnidadeWhereInput | null
    isNot?: UnidadeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReservaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitorLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    apartamento?: SortOrder
    bloco?: SortOrder
    unidadeId?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    apartamento?: SortOrder
    bloco?: SortOrder
    unidadeId?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    apartamento?: SortOrder
    bloco?: SortOrder
    unidadeId?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AreaComumCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    createdAt?: SortOrder
  }

  export type AreaComumMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    createdAt?: SortOrder
  }

  export type AreaComumMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    createdAt?: SortOrder
  }

  export type BlocoListRelationFilter = {
    every?: BlocoWhereInput
    some?: BlocoWhereInput
    none?: BlocoWhereInput
  }

  export type ConfigReservaNullableRelationFilter = {
    is?: ConfigReservaWhereInput | null
    isNot?: ConfigReservaWhereInput | null
  }

  export type BlocoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CondominioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    createdAt?: SortOrder
  }

  export type CondominioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    createdAt?: SortOrder
  }

  export type CondominioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    createdAt?: SortOrder
  }

  export type CondominioRelationFilter = {
    is?: CondominioWhereInput
    isNot?: CondominioWhereInput
  }

  export type UnidadeListRelationFilter = {
    every?: UnidadeWhereInput
    some?: UnidadeWhereInput
    none?: UnidadeWhereInput
  }

  export type UnidadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlocoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    condominioId?: SortOrder
  }

  export type BlocoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    condominioId?: SortOrder
  }

  export type BlocoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    condominioId?: SortOrder
  }

  export type BlocoRelationFilter = {
    is?: BlocoWhereInput
    isNot?: BlocoWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CobrancaListRelationFilter = {
    every?: CobrancaWhereInput
    some?: CobrancaWhereInput
    none?: CobrancaWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CobrancaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnidadeCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    blocoId?: SortOrder
    createdAt?: SortOrder
  }

  export type UnidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    blocoId?: SortOrder
    createdAt?: SortOrder
  }

  export type UnidadeMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    blocoId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ConfigReservaCountOrderByAggregateInput = {
    id?: SortOrder
    condominioId?: SortOrder
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
  }

  export type ConfigReservaAvgOrderByAggregateInput = {
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
  }

  export type ConfigReservaMaxOrderByAggregateInput = {
    id?: SortOrder
    condominioId?: SortOrder
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
  }

  export type ConfigReservaMinOrderByAggregateInput = {
    id?: SortOrder
    condominioId?: SortOrder
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
  }

  export type ConfigReservaSumOrderByAggregateInput = {
    limitePorMes?: SortOrder
    antecedenciaDias?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UnidadeRelationFilter = {
    is?: UnidadeWhereInput
    isNot?: UnidadeWhereInput
  }

  export type PagamentoListRelationFilter = {
    every?: PagamentoWhereInput
    some?: PagamentoWhereInput
    none?: PagamentoWhereInput
  }

  export type PagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CobrancaCountOrderByAggregateInput = {
    id?: SortOrder
    unidadeId?: SortOrder
    mesRef?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    vencimento?: SortOrder
    boletoUrl?: SortOrder
    linhaDigitavel?: SortOrder
    createdAt?: SortOrder
  }

  export type CobrancaAvgOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type CobrancaMaxOrderByAggregateInput = {
    id?: SortOrder
    unidadeId?: SortOrder
    mesRef?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    vencimento?: SortOrder
    boletoUrl?: SortOrder
    linhaDigitavel?: SortOrder
    createdAt?: SortOrder
  }

  export type CobrancaMinOrderByAggregateInput = {
    id?: SortOrder
    unidadeId?: SortOrder
    mesRef?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    vencimento?: SortOrder
    boletoUrl?: SortOrder
    linhaDigitavel?: SortOrder
    createdAt?: SortOrder
  }

  export type CobrancaSumOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CobrancaRelationFilter = {
    is?: CobrancaWhereInput
    isNot?: CobrancaWhereInput
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    cobrancaId?: SortOrder
    valor?: SortOrder
    pagoEm?: SortOrder
    comprovanteUrl?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    cobrancaId?: SortOrder
    valor?: SortOrder
    pagoEm?: SortOrder
    comprovanteUrl?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    cobrancaId?: SortOrder
    valor?: SortOrder
    pagoEm?: SortOrder
    comprovanteUrl?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type LogAuditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    acao?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogAuditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    acao?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogAuditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    acao?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AreaComumRelationFilter = {
    is?: AreaComumWhereInput
    isNot?: AreaComumWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReservaCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrder
    cancelledById?: SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    moradorId?: SortOrder
  }

  export type ReservaMaxOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrder
    cancelledById?: SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    moradorId?: SortOrder
  }

  export type ReservaMinOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    horarioInicio?: SortOrder
    horarioFim?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrder
    cancelledById?: SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    moradorId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type VisitorLogCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    apartamento?: SortOrder
    bloco?: SortOrder
    dataEntrada?: SortOrder
    dataSaida?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type VisitorLogMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    apartamento?: SortOrder
    bloco?: SortOrder
    dataEntrada?: SortOrder
    dataSaida?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type VisitorLogMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    apartamento?: SortOrder
    bloco?: SortOrder
    dataEntrada?: SortOrder
    dataSaida?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    destinatarioEmail?: SortOrder
    fotoUrl?: SortOrder
    assinaturaUrl?: SortOrder
    status?: SortOrder
    chegouEm?: SortOrder
    entregueEm?: SortOrder
    createdById?: SortOrder
    destinatarioId?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    destinatarioEmail?: SortOrder
    fotoUrl?: SortOrder
    assinaturaUrl?: SortOrder
    status?: SortOrder
    chegouEm?: SortOrder
    entregueEm?: SortOrder
    createdById?: SortOrder
    destinatarioId?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    destinatarioEmail?: SortOrder
    fotoUrl?: SortOrder
    assinaturaUrl?: SortOrder
    status?: SortOrder
    chegouEm?: SortOrder
    entregueEm?: SortOrder
    createdById?: SortOrder
    destinatarioId?: SortOrder
  }

  export type ShiftNoteCountOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type ShiftNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type ShiftNoteMinOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DeliveryNullableRelationFilter = {
    is?: DeliveryWhereInput | null
    isNot?: DeliveryWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    mensagem?: SortOrder
    imageUrl?: SortOrder
    lida?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    deliveryId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    mensagem?: SortOrder
    imageUrl?: SortOrder
    lida?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    deliveryId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    mensagem?: SortOrder
    imageUrl?: SortOrder
    lida?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    deliveryId?: SortOrder
  }

  export type AvisoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
  }

  export type AvisoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
  }

  export type AvisoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
  }

  export type ReservaCreateNestedManyWithoutMoradorInput = {
    create?: XOR<ReservaCreateWithoutMoradorInput, ReservaUncheckedCreateWithoutMoradorInput> | ReservaCreateWithoutMoradorInput[] | ReservaUncheckedCreateWithoutMoradorInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMoradorInput | ReservaCreateOrConnectWithoutMoradorInput[]
    createMany?: ReservaCreateManyMoradorInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type ReservaCreateNestedManyWithoutCancelledByInput = {
    create?: XOR<ReservaCreateWithoutCancelledByInput, ReservaUncheckedCreateWithoutCancelledByInput> | ReservaCreateWithoutCancelledByInput[] | ReservaUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutCancelledByInput | ReservaCreateOrConnectWithoutCancelledByInput[]
    createMany?: ReservaCreateManyCancelledByInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type VisitorLogCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VisitorLogCreateWithoutCreatedByInput, VisitorLogUncheckedCreateWithoutCreatedByInput> | VisitorLogCreateWithoutCreatedByInput[] | VisitorLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitorLogCreateOrConnectWithoutCreatedByInput | VisitorLogCreateOrConnectWithoutCreatedByInput[]
    createMany?: VisitorLogCreateManyCreatedByInputEnvelope
    connect?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<DeliveryCreateWithoutDestinatarioInput, DeliveryUncheckedCreateWithoutDestinatarioInput> | DeliveryCreateWithoutDestinatarioInput[] | DeliveryUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDestinatarioInput | DeliveryCreateOrConnectWithoutDestinatarioInput[]
    createMany?: DeliveryCreateManyDestinatarioInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type ShiftNoteCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ShiftNoteCreateWithoutCreatedByInput, ShiftNoteUncheckedCreateWithoutCreatedByInput> | ShiftNoteCreateWithoutCreatedByInput[] | ShiftNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftNoteCreateOrConnectWithoutCreatedByInput | ShiftNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: ShiftNoteCreateManyCreatedByInputEnvelope
    connect?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UnidadeCreateNestedOneWithoutMoradoresInput = {
    create?: XOR<UnidadeCreateWithoutMoradoresInput, UnidadeUncheckedCreateWithoutMoradoresInput>
    connectOrCreate?: UnidadeCreateOrConnectWithoutMoradoresInput
    connect?: UnidadeWhereUniqueInput
  }

  export type ReservaUncheckedCreateNestedManyWithoutMoradorInput = {
    create?: XOR<ReservaCreateWithoutMoradorInput, ReservaUncheckedCreateWithoutMoradorInput> | ReservaCreateWithoutMoradorInput[] | ReservaUncheckedCreateWithoutMoradorInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMoradorInput | ReservaCreateOrConnectWithoutMoradorInput[]
    createMany?: ReservaCreateManyMoradorInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type ReservaUncheckedCreateNestedManyWithoutCancelledByInput = {
    create?: XOR<ReservaCreateWithoutCancelledByInput, ReservaUncheckedCreateWithoutCancelledByInput> | ReservaCreateWithoutCancelledByInput[] | ReservaUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutCancelledByInput | ReservaCreateOrConnectWithoutCancelledByInput[]
    createMany?: ReservaCreateManyCancelledByInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VisitorLogCreateWithoutCreatedByInput, VisitorLogUncheckedCreateWithoutCreatedByInput> | VisitorLogCreateWithoutCreatedByInput[] | VisitorLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitorLogCreateOrConnectWithoutCreatedByInput | VisitorLogCreateOrConnectWithoutCreatedByInput[]
    createMany?: VisitorLogCreateManyCreatedByInputEnvelope
    connect?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<DeliveryCreateWithoutDestinatarioInput, DeliveryUncheckedCreateWithoutDestinatarioInput> | DeliveryCreateWithoutDestinatarioInput[] | DeliveryUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDestinatarioInput | DeliveryCreateOrConnectWithoutDestinatarioInput[]
    createMany?: DeliveryCreateManyDestinatarioInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ShiftNoteCreateWithoutCreatedByInput, ShiftNoteUncheckedCreateWithoutCreatedByInput> | ShiftNoteCreateWithoutCreatedByInput[] | ShiftNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftNoteCreateOrConnectWithoutCreatedByInput | ShiftNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: ShiftNoteCreateManyCreatedByInputEnvelope
    connect?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReservaUpdateManyWithoutMoradorNestedInput = {
    create?: XOR<ReservaCreateWithoutMoradorInput, ReservaUncheckedCreateWithoutMoradorInput> | ReservaCreateWithoutMoradorInput[] | ReservaUncheckedCreateWithoutMoradorInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMoradorInput | ReservaCreateOrConnectWithoutMoradorInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutMoradorInput | ReservaUpsertWithWhereUniqueWithoutMoradorInput[]
    createMany?: ReservaCreateManyMoradorInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutMoradorInput | ReservaUpdateWithWhereUniqueWithoutMoradorInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutMoradorInput | ReservaUpdateManyWithWhereWithoutMoradorInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type ReservaUpdateManyWithoutCancelledByNestedInput = {
    create?: XOR<ReservaCreateWithoutCancelledByInput, ReservaUncheckedCreateWithoutCancelledByInput> | ReservaCreateWithoutCancelledByInput[] | ReservaUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutCancelledByInput | ReservaCreateOrConnectWithoutCancelledByInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutCancelledByInput | ReservaUpsertWithWhereUniqueWithoutCancelledByInput[]
    createMany?: ReservaCreateManyCancelledByInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutCancelledByInput | ReservaUpdateWithWhereUniqueWithoutCancelledByInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutCancelledByInput | ReservaUpdateManyWithWhereWithoutCancelledByInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type VisitorLogUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VisitorLogCreateWithoutCreatedByInput, VisitorLogUncheckedCreateWithoutCreatedByInput> | VisitorLogCreateWithoutCreatedByInput[] | VisitorLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitorLogCreateOrConnectWithoutCreatedByInput | VisitorLogCreateOrConnectWithoutCreatedByInput[]
    upsert?: VisitorLogUpsertWithWhereUniqueWithoutCreatedByInput | VisitorLogUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VisitorLogCreateManyCreatedByInputEnvelope
    set?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    disconnect?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    delete?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    connect?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    update?: VisitorLogUpdateWithWhereUniqueWithoutCreatedByInput | VisitorLogUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VisitorLogUpdateManyWithWhereWithoutCreatedByInput | VisitorLogUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VisitorLogScalarWhereInput | VisitorLogScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCreatedByInput | DeliveryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCreatedByInput | DeliveryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCreatedByInput | DeliveryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutDestinatarioNestedInput = {
    create?: XOR<DeliveryCreateWithoutDestinatarioInput, DeliveryUncheckedCreateWithoutDestinatarioInput> | DeliveryCreateWithoutDestinatarioInput[] | DeliveryUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDestinatarioInput | DeliveryCreateOrConnectWithoutDestinatarioInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutDestinatarioInput | DeliveryUpsertWithWhereUniqueWithoutDestinatarioInput[]
    createMany?: DeliveryCreateManyDestinatarioInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutDestinatarioInput | DeliveryUpdateWithWhereUniqueWithoutDestinatarioInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutDestinatarioInput | DeliveryUpdateManyWithWhereWithoutDestinatarioInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type ShiftNoteUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ShiftNoteCreateWithoutCreatedByInput, ShiftNoteUncheckedCreateWithoutCreatedByInput> | ShiftNoteCreateWithoutCreatedByInput[] | ShiftNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftNoteCreateOrConnectWithoutCreatedByInput | ShiftNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: ShiftNoteUpsertWithWhereUniqueWithoutCreatedByInput | ShiftNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ShiftNoteCreateManyCreatedByInputEnvelope
    set?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    disconnect?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    delete?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    connect?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    update?: ShiftNoteUpdateWithWhereUniqueWithoutCreatedByInput | ShiftNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ShiftNoteUpdateManyWithWhereWithoutCreatedByInput | ShiftNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ShiftNoteScalarWhereInput | ShiftNoteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UnidadeUpdateOneWithoutMoradoresNestedInput = {
    create?: XOR<UnidadeCreateWithoutMoradoresInput, UnidadeUncheckedCreateWithoutMoradoresInput>
    connectOrCreate?: UnidadeCreateOrConnectWithoutMoradoresInput
    upsert?: UnidadeUpsertWithoutMoradoresInput
    disconnect?: UnidadeWhereInput | boolean
    delete?: UnidadeWhereInput | boolean
    connect?: UnidadeWhereUniqueInput
    update?: XOR<XOR<UnidadeUpdateToOneWithWhereWithoutMoradoresInput, UnidadeUpdateWithoutMoradoresInput>, UnidadeUncheckedUpdateWithoutMoradoresInput>
  }

  export type ReservaUncheckedUpdateManyWithoutMoradorNestedInput = {
    create?: XOR<ReservaCreateWithoutMoradorInput, ReservaUncheckedCreateWithoutMoradorInput> | ReservaCreateWithoutMoradorInput[] | ReservaUncheckedCreateWithoutMoradorInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMoradorInput | ReservaCreateOrConnectWithoutMoradorInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutMoradorInput | ReservaUpsertWithWhereUniqueWithoutMoradorInput[]
    createMany?: ReservaCreateManyMoradorInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutMoradorInput | ReservaUpdateWithWhereUniqueWithoutMoradorInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutMoradorInput | ReservaUpdateManyWithWhereWithoutMoradorInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type ReservaUncheckedUpdateManyWithoutCancelledByNestedInput = {
    create?: XOR<ReservaCreateWithoutCancelledByInput, ReservaUncheckedCreateWithoutCancelledByInput> | ReservaCreateWithoutCancelledByInput[] | ReservaUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutCancelledByInput | ReservaCreateOrConnectWithoutCancelledByInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutCancelledByInput | ReservaUpsertWithWhereUniqueWithoutCancelledByInput[]
    createMany?: ReservaCreateManyCancelledByInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutCancelledByInput | ReservaUpdateWithWhereUniqueWithoutCancelledByInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutCancelledByInput | ReservaUpdateManyWithWhereWithoutCancelledByInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VisitorLogCreateWithoutCreatedByInput, VisitorLogUncheckedCreateWithoutCreatedByInput> | VisitorLogCreateWithoutCreatedByInput[] | VisitorLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VisitorLogCreateOrConnectWithoutCreatedByInput | VisitorLogCreateOrConnectWithoutCreatedByInput[]
    upsert?: VisitorLogUpsertWithWhereUniqueWithoutCreatedByInput | VisitorLogUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VisitorLogCreateManyCreatedByInputEnvelope
    set?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    disconnect?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    delete?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    connect?: VisitorLogWhereUniqueInput | VisitorLogWhereUniqueInput[]
    update?: VisitorLogUpdateWithWhereUniqueWithoutCreatedByInput | VisitorLogUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VisitorLogUpdateManyWithWhereWithoutCreatedByInput | VisitorLogUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VisitorLogScalarWhereInput | VisitorLogScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCreatedByInput | DeliveryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCreatedByInput | DeliveryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCreatedByInput | DeliveryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput = {
    create?: XOR<DeliveryCreateWithoutDestinatarioInput, DeliveryUncheckedCreateWithoutDestinatarioInput> | DeliveryCreateWithoutDestinatarioInput[] | DeliveryUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDestinatarioInput | DeliveryCreateOrConnectWithoutDestinatarioInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutDestinatarioInput | DeliveryUpsertWithWhereUniqueWithoutDestinatarioInput[]
    createMany?: DeliveryCreateManyDestinatarioInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutDestinatarioInput | DeliveryUpdateWithWhereUniqueWithoutDestinatarioInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutDestinatarioInput | DeliveryUpdateManyWithWhereWithoutDestinatarioInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ShiftNoteCreateWithoutCreatedByInput, ShiftNoteUncheckedCreateWithoutCreatedByInput> | ShiftNoteCreateWithoutCreatedByInput[] | ShiftNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftNoteCreateOrConnectWithoutCreatedByInput | ShiftNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: ShiftNoteUpsertWithWhereUniqueWithoutCreatedByInput | ShiftNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ShiftNoteCreateManyCreatedByInputEnvelope
    set?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    disconnect?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    delete?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    connect?: ShiftNoteWhereUniqueInput | ShiftNoteWhereUniqueInput[]
    update?: ShiftNoteUpdateWithWhereUniqueWithoutCreatedByInput | ShiftNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ShiftNoteUpdateManyWithWhereWithoutCreatedByInput | ShiftNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ShiftNoteScalarWhereInput | ShiftNoteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReservaCreateNestedManyWithoutAreaInput = {
    create?: XOR<ReservaCreateWithoutAreaInput, ReservaUncheckedCreateWithoutAreaInput> | ReservaCreateWithoutAreaInput[] | ReservaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutAreaInput | ReservaCreateOrConnectWithoutAreaInput[]
    createMany?: ReservaCreateManyAreaInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type ReservaUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ReservaCreateWithoutAreaInput, ReservaUncheckedCreateWithoutAreaInput> | ReservaCreateWithoutAreaInput[] | ReservaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutAreaInput | ReservaCreateOrConnectWithoutAreaInput[]
    createMany?: ReservaCreateManyAreaInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type ReservaUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ReservaCreateWithoutAreaInput, ReservaUncheckedCreateWithoutAreaInput> | ReservaCreateWithoutAreaInput[] | ReservaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutAreaInput | ReservaCreateOrConnectWithoutAreaInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutAreaInput | ReservaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ReservaCreateManyAreaInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutAreaInput | ReservaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutAreaInput | ReservaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type ReservaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ReservaCreateWithoutAreaInput, ReservaUncheckedCreateWithoutAreaInput> | ReservaCreateWithoutAreaInput[] | ReservaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutAreaInput | ReservaCreateOrConnectWithoutAreaInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutAreaInput | ReservaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ReservaCreateManyAreaInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutAreaInput | ReservaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutAreaInput | ReservaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type BlocoCreateNestedManyWithoutCondominioInput = {
    create?: XOR<BlocoCreateWithoutCondominioInput, BlocoUncheckedCreateWithoutCondominioInput> | BlocoCreateWithoutCondominioInput[] | BlocoUncheckedCreateWithoutCondominioInput[]
    connectOrCreate?: BlocoCreateOrConnectWithoutCondominioInput | BlocoCreateOrConnectWithoutCondominioInput[]
    createMany?: BlocoCreateManyCondominioInputEnvelope
    connect?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
  }

  export type ConfigReservaCreateNestedOneWithoutCondominioInput = {
    create?: XOR<ConfigReservaCreateWithoutCondominioInput, ConfigReservaUncheckedCreateWithoutCondominioInput>
    connectOrCreate?: ConfigReservaCreateOrConnectWithoutCondominioInput
    connect?: ConfigReservaWhereUniqueInput
  }

  export type BlocoUncheckedCreateNestedManyWithoutCondominioInput = {
    create?: XOR<BlocoCreateWithoutCondominioInput, BlocoUncheckedCreateWithoutCondominioInput> | BlocoCreateWithoutCondominioInput[] | BlocoUncheckedCreateWithoutCondominioInput[]
    connectOrCreate?: BlocoCreateOrConnectWithoutCondominioInput | BlocoCreateOrConnectWithoutCondominioInput[]
    createMany?: BlocoCreateManyCondominioInputEnvelope
    connect?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
  }

  export type ConfigReservaUncheckedCreateNestedOneWithoutCondominioInput = {
    create?: XOR<ConfigReservaCreateWithoutCondominioInput, ConfigReservaUncheckedCreateWithoutCondominioInput>
    connectOrCreate?: ConfigReservaCreateOrConnectWithoutCondominioInput
    connect?: ConfigReservaWhereUniqueInput
  }

  export type BlocoUpdateManyWithoutCondominioNestedInput = {
    create?: XOR<BlocoCreateWithoutCondominioInput, BlocoUncheckedCreateWithoutCondominioInput> | BlocoCreateWithoutCondominioInput[] | BlocoUncheckedCreateWithoutCondominioInput[]
    connectOrCreate?: BlocoCreateOrConnectWithoutCondominioInput | BlocoCreateOrConnectWithoutCondominioInput[]
    upsert?: BlocoUpsertWithWhereUniqueWithoutCondominioInput | BlocoUpsertWithWhereUniqueWithoutCondominioInput[]
    createMany?: BlocoCreateManyCondominioInputEnvelope
    set?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    disconnect?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    delete?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    connect?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    update?: BlocoUpdateWithWhereUniqueWithoutCondominioInput | BlocoUpdateWithWhereUniqueWithoutCondominioInput[]
    updateMany?: BlocoUpdateManyWithWhereWithoutCondominioInput | BlocoUpdateManyWithWhereWithoutCondominioInput[]
    deleteMany?: BlocoScalarWhereInput | BlocoScalarWhereInput[]
  }

  export type ConfigReservaUpdateOneWithoutCondominioNestedInput = {
    create?: XOR<ConfigReservaCreateWithoutCondominioInput, ConfigReservaUncheckedCreateWithoutCondominioInput>
    connectOrCreate?: ConfigReservaCreateOrConnectWithoutCondominioInput
    upsert?: ConfigReservaUpsertWithoutCondominioInput
    disconnect?: ConfigReservaWhereInput | boolean
    delete?: ConfigReservaWhereInput | boolean
    connect?: ConfigReservaWhereUniqueInput
    update?: XOR<XOR<ConfigReservaUpdateToOneWithWhereWithoutCondominioInput, ConfigReservaUpdateWithoutCondominioInput>, ConfigReservaUncheckedUpdateWithoutCondominioInput>
  }

  export type BlocoUncheckedUpdateManyWithoutCondominioNestedInput = {
    create?: XOR<BlocoCreateWithoutCondominioInput, BlocoUncheckedCreateWithoutCondominioInput> | BlocoCreateWithoutCondominioInput[] | BlocoUncheckedCreateWithoutCondominioInput[]
    connectOrCreate?: BlocoCreateOrConnectWithoutCondominioInput | BlocoCreateOrConnectWithoutCondominioInput[]
    upsert?: BlocoUpsertWithWhereUniqueWithoutCondominioInput | BlocoUpsertWithWhereUniqueWithoutCondominioInput[]
    createMany?: BlocoCreateManyCondominioInputEnvelope
    set?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    disconnect?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    delete?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    connect?: BlocoWhereUniqueInput | BlocoWhereUniqueInput[]
    update?: BlocoUpdateWithWhereUniqueWithoutCondominioInput | BlocoUpdateWithWhereUniqueWithoutCondominioInput[]
    updateMany?: BlocoUpdateManyWithWhereWithoutCondominioInput | BlocoUpdateManyWithWhereWithoutCondominioInput[]
    deleteMany?: BlocoScalarWhereInput | BlocoScalarWhereInput[]
  }

  export type ConfigReservaUncheckedUpdateOneWithoutCondominioNestedInput = {
    create?: XOR<ConfigReservaCreateWithoutCondominioInput, ConfigReservaUncheckedCreateWithoutCondominioInput>
    connectOrCreate?: ConfigReservaCreateOrConnectWithoutCondominioInput
    upsert?: ConfigReservaUpsertWithoutCondominioInput
    disconnect?: ConfigReservaWhereInput | boolean
    delete?: ConfigReservaWhereInput | boolean
    connect?: ConfigReservaWhereUniqueInput
    update?: XOR<XOR<ConfigReservaUpdateToOneWithWhereWithoutCondominioInput, ConfigReservaUpdateWithoutCondominioInput>, ConfigReservaUncheckedUpdateWithoutCondominioInput>
  }

  export type CondominioCreateNestedOneWithoutBlocosInput = {
    create?: XOR<CondominioCreateWithoutBlocosInput, CondominioUncheckedCreateWithoutBlocosInput>
    connectOrCreate?: CondominioCreateOrConnectWithoutBlocosInput
    connect?: CondominioWhereUniqueInput
  }

  export type UnidadeCreateNestedManyWithoutBlocoInput = {
    create?: XOR<UnidadeCreateWithoutBlocoInput, UnidadeUncheckedCreateWithoutBlocoInput> | UnidadeCreateWithoutBlocoInput[] | UnidadeUncheckedCreateWithoutBlocoInput[]
    connectOrCreate?: UnidadeCreateOrConnectWithoutBlocoInput | UnidadeCreateOrConnectWithoutBlocoInput[]
    createMany?: UnidadeCreateManyBlocoInputEnvelope
    connect?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
  }

  export type UnidadeUncheckedCreateNestedManyWithoutBlocoInput = {
    create?: XOR<UnidadeCreateWithoutBlocoInput, UnidadeUncheckedCreateWithoutBlocoInput> | UnidadeCreateWithoutBlocoInput[] | UnidadeUncheckedCreateWithoutBlocoInput[]
    connectOrCreate?: UnidadeCreateOrConnectWithoutBlocoInput | UnidadeCreateOrConnectWithoutBlocoInput[]
    createMany?: UnidadeCreateManyBlocoInputEnvelope
    connect?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
  }

  export type CondominioUpdateOneRequiredWithoutBlocosNestedInput = {
    create?: XOR<CondominioCreateWithoutBlocosInput, CondominioUncheckedCreateWithoutBlocosInput>
    connectOrCreate?: CondominioCreateOrConnectWithoutBlocosInput
    upsert?: CondominioUpsertWithoutBlocosInput
    connect?: CondominioWhereUniqueInput
    update?: XOR<XOR<CondominioUpdateToOneWithWhereWithoutBlocosInput, CondominioUpdateWithoutBlocosInput>, CondominioUncheckedUpdateWithoutBlocosInput>
  }

  export type UnidadeUpdateManyWithoutBlocoNestedInput = {
    create?: XOR<UnidadeCreateWithoutBlocoInput, UnidadeUncheckedCreateWithoutBlocoInput> | UnidadeCreateWithoutBlocoInput[] | UnidadeUncheckedCreateWithoutBlocoInput[]
    connectOrCreate?: UnidadeCreateOrConnectWithoutBlocoInput | UnidadeCreateOrConnectWithoutBlocoInput[]
    upsert?: UnidadeUpsertWithWhereUniqueWithoutBlocoInput | UnidadeUpsertWithWhereUniqueWithoutBlocoInput[]
    createMany?: UnidadeCreateManyBlocoInputEnvelope
    set?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    disconnect?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    delete?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    connect?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    update?: UnidadeUpdateWithWhereUniqueWithoutBlocoInput | UnidadeUpdateWithWhereUniqueWithoutBlocoInput[]
    updateMany?: UnidadeUpdateManyWithWhereWithoutBlocoInput | UnidadeUpdateManyWithWhereWithoutBlocoInput[]
    deleteMany?: UnidadeScalarWhereInput | UnidadeScalarWhereInput[]
  }

  export type UnidadeUncheckedUpdateManyWithoutBlocoNestedInput = {
    create?: XOR<UnidadeCreateWithoutBlocoInput, UnidadeUncheckedCreateWithoutBlocoInput> | UnidadeCreateWithoutBlocoInput[] | UnidadeUncheckedCreateWithoutBlocoInput[]
    connectOrCreate?: UnidadeCreateOrConnectWithoutBlocoInput | UnidadeCreateOrConnectWithoutBlocoInput[]
    upsert?: UnidadeUpsertWithWhereUniqueWithoutBlocoInput | UnidadeUpsertWithWhereUniqueWithoutBlocoInput[]
    createMany?: UnidadeCreateManyBlocoInputEnvelope
    set?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    disconnect?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    delete?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    connect?: UnidadeWhereUniqueInput | UnidadeWhereUniqueInput[]
    update?: UnidadeUpdateWithWhereUniqueWithoutBlocoInput | UnidadeUpdateWithWhereUniqueWithoutBlocoInput[]
    updateMany?: UnidadeUpdateManyWithWhereWithoutBlocoInput | UnidadeUpdateManyWithWhereWithoutBlocoInput[]
    deleteMany?: UnidadeScalarWhereInput | UnidadeScalarWhereInput[]
  }

  export type BlocoCreateNestedOneWithoutUnidadesInput = {
    create?: XOR<BlocoCreateWithoutUnidadesInput, BlocoUncheckedCreateWithoutUnidadesInput>
    connectOrCreate?: BlocoCreateOrConnectWithoutUnidadesInput
    connect?: BlocoWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutUnidadeInput = {
    create?: XOR<UserCreateWithoutUnidadeInput, UserUncheckedCreateWithoutUnidadeInput> | UserCreateWithoutUnidadeInput[] | UserUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUnidadeInput | UserCreateOrConnectWithoutUnidadeInput[]
    createMany?: UserCreateManyUnidadeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CobrancaCreateNestedManyWithoutUnidadeInput = {
    create?: XOR<CobrancaCreateWithoutUnidadeInput, CobrancaUncheckedCreateWithoutUnidadeInput> | CobrancaCreateWithoutUnidadeInput[] | CobrancaUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: CobrancaCreateOrConnectWithoutUnidadeInput | CobrancaCreateOrConnectWithoutUnidadeInput[]
    createMany?: CobrancaCreateManyUnidadeInputEnvelope
    connect?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUnidadeInput = {
    create?: XOR<UserCreateWithoutUnidadeInput, UserUncheckedCreateWithoutUnidadeInput> | UserCreateWithoutUnidadeInput[] | UserUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUnidadeInput | UserCreateOrConnectWithoutUnidadeInput[]
    createMany?: UserCreateManyUnidadeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CobrancaUncheckedCreateNestedManyWithoutUnidadeInput = {
    create?: XOR<CobrancaCreateWithoutUnidadeInput, CobrancaUncheckedCreateWithoutUnidadeInput> | CobrancaCreateWithoutUnidadeInput[] | CobrancaUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: CobrancaCreateOrConnectWithoutUnidadeInput | CobrancaCreateOrConnectWithoutUnidadeInput[]
    createMany?: CobrancaCreateManyUnidadeInputEnvelope
    connect?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
  }

  export type BlocoUpdateOneRequiredWithoutUnidadesNestedInput = {
    create?: XOR<BlocoCreateWithoutUnidadesInput, BlocoUncheckedCreateWithoutUnidadesInput>
    connectOrCreate?: BlocoCreateOrConnectWithoutUnidadesInput
    upsert?: BlocoUpsertWithoutUnidadesInput
    connect?: BlocoWhereUniqueInput
    update?: XOR<XOR<BlocoUpdateToOneWithWhereWithoutUnidadesInput, BlocoUpdateWithoutUnidadesInput>, BlocoUncheckedUpdateWithoutUnidadesInput>
  }

  export type UserUpdateManyWithoutUnidadeNestedInput = {
    create?: XOR<UserCreateWithoutUnidadeInput, UserUncheckedCreateWithoutUnidadeInput> | UserCreateWithoutUnidadeInput[] | UserUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUnidadeInput | UserCreateOrConnectWithoutUnidadeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUnidadeInput | UserUpsertWithWhereUniqueWithoutUnidadeInput[]
    createMany?: UserCreateManyUnidadeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUnidadeInput | UserUpdateWithWhereUniqueWithoutUnidadeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUnidadeInput | UserUpdateManyWithWhereWithoutUnidadeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CobrancaUpdateManyWithoutUnidadeNestedInput = {
    create?: XOR<CobrancaCreateWithoutUnidadeInput, CobrancaUncheckedCreateWithoutUnidadeInput> | CobrancaCreateWithoutUnidadeInput[] | CobrancaUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: CobrancaCreateOrConnectWithoutUnidadeInput | CobrancaCreateOrConnectWithoutUnidadeInput[]
    upsert?: CobrancaUpsertWithWhereUniqueWithoutUnidadeInput | CobrancaUpsertWithWhereUniqueWithoutUnidadeInput[]
    createMany?: CobrancaCreateManyUnidadeInputEnvelope
    set?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    disconnect?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    delete?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    connect?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    update?: CobrancaUpdateWithWhereUniqueWithoutUnidadeInput | CobrancaUpdateWithWhereUniqueWithoutUnidadeInput[]
    updateMany?: CobrancaUpdateManyWithWhereWithoutUnidadeInput | CobrancaUpdateManyWithWhereWithoutUnidadeInput[]
    deleteMany?: CobrancaScalarWhereInput | CobrancaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUnidadeNestedInput = {
    create?: XOR<UserCreateWithoutUnidadeInput, UserUncheckedCreateWithoutUnidadeInput> | UserCreateWithoutUnidadeInput[] | UserUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUnidadeInput | UserCreateOrConnectWithoutUnidadeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUnidadeInput | UserUpsertWithWhereUniqueWithoutUnidadeInput[]
    createMany?: UserCreateManyUnidadeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUnidadeInput | UserUpdateWithWhereUniqueWithoutUnidadeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUnidadeInput | UserUpdateManyWithWhereWithoutUnidadeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CobrancaUncheckedUpdateManyWithoutUnidadeNestedInput = {
    create?: XOR<CobrancaCreateWithoutUnidadeInput, CobrancaUncheckedCreateWithoutUnidadeInput> | CobrancaCreateWithoutUnidadeInput[] | CobrancaUncheckedCreateWithoutUnidadeInput[]
    connectOrCreate?: CobrancaCreateOrConnectWithoutUnidadeInput | CobrancaCreateOrConnectWithoutUnidadeInput[]
    upsert?: CobrancaUpsertWithWhereUniqueWithoutUnidadeInput | CobrancaUpsertWithWhereUniqueWithoutUnidadeInput[]
    createMany?: CobrancaCreateManyUnidadeInputEnvelope
    set?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    disconnect?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    delete?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    connect?: CobrancaWhereUniqueInput | CobrancaWhereUniqueInput[]
    update?: CobrancaUpdateWithWhereUniqueWithoutUnidadeInput | CobrancaUpdateWithWhereUniqueWithoutUnidadeInput[]
    updateMany?: CobrancaUpdateManyWithWhereWithoutUnidadeInput | CobrancaUpdateManyWithWhereWithoutUnidadeInput[]
    deleteMany?: CobrancaScalarWhereInput | CobrancaScalarWhereInput[]
  }

  export type CondominioCreateNestedOneWithoutConfiguracoesInput = {
    create?: XOR<CondominioCreateWithoutConfiguracoesInput, CondominioUncheckedCreateWithoutConfiguracoesInput>
    connectOrCreate?: CondominioCreateOrConnectWithoutConfiguracoesInput
    connect?: CondominioWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CondominioUpdateOneRequiredWithoutConfiguracoesNestedInput = {
    create?: XOR<CondominioCreateWithoutConfiguracoesInput, CondominioUncheckedCreateWithoutConfiguracoesInput>
    connectOrCreate?: CondominioCreateOrConnectWithoutConfiguracoesInput
    upsert?: CondominioUpsertWithoutConfiguracoesInput
    connect?: CondominioWhereUniqueInput
    update?: XOR<XOR<CondominioUpdateToOneWithWhereWithoutConfiguracoesInput, CondominioUpdateWithoutConfiguracoesInput>, CondominioUncheckedUpdateWithoutConfiguracoesInput>
  }

  export type UnidadeCreateNestedOneWithoutCobrancasInput = {
    create?: XOR<UnidadeCreateWithoutCobrancasInput, UnidadeUncheckedCreateWithoutCobrancasInput>
    connectOrCreate?: UnidadeCreateOrConnectWithoutCobrancasInput
    connect?: UnidadeWhereUniqueInput
  }

  export type PagamentoCreateNestedManyWithoutCobrancaInput = {
    create?: XOR<PagamentoCreateWithoutCobrancaInput, PagamentoUncheckedCreateWithoutCobrancaInput> | PagamentoCreateWithoutCobrancaInput[] | PagamentoUncheckedCreateWithoutCobrancaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutCobrancaInput | PagamentoCreateOrConnectWithoutCobrancaInput[]
    createMany?: PagamentoCreateManyCobrancaInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutCobrancaInput = {
    create?: XOR<PagamentoCreateWithoutCobrancaInput, PagamentoUncheckedCreateWithoutCobrancaInput> | PagamentoCreateWithoutCobrancaInput[] | PagamentoUncheckedCreateWithoutCobrancaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutCobrancaInput | PagamentoCreateOrConnectWithoutCobrancaInput[]
    createMany?: PagamentoCreateManyCobrancaInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UnidadeUpdateOneRequiredWithoutCobrancasNestedInput = {
    create?: XOR<UnidadeCreateWithoutCobrancasInput, UnidadeUncheckedCreateWithoutCobrancasInput>
    connectOrCreate?: UnidadeCreateOrConnectWithoutCobrancasInput
    upsert?: UnidadeUpsertWithoutCobrancasInput
    connect?: UnidadeWhereUniqueInput
    update?: XOR<XOR<UnidadeUpdateToOneWithWhereWithoutCobrancasInput, UnidadeUpdateWithoutCobrancasInput>, UnidadeUncheckedUpdateWithoutCobrancasInput>
  }

  export type PagamentoUpdateManyWithoutCobrancaNestedInput = {
    create?: XOR<PagamentoCreateWithoutCobrancaInput, PagamentoUncheckedCreateWithoutCobrancaInput> | PagamentoCreateWithoutCobrancaInput[] | PagamentoUncheckedCreateWithoutCobrancaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutCobrancaInput | PagamentoCreateOrConnectWithoutCobrancaInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutCobrancaInput | PagamentoUpsertWithWhereUniqueWithoutCobrancaInput[]
    createMany?: PagamentoCreateManyCobrancaInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutCobrancaInput | PagamentoUpdateWithWhereUniqueWithoutCobrancaInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutCobrancaInput | PagamentoUpdateManyWithWhereWithoutCobrancaInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutCobrancaNestedInput = {
    create?: XOR<PagamentoCreateWithoutCobrancaInput, PagamentoUncheckedCreateWithoutCobrancaInput> | PagamentoCreateWithoutCobrancaInput[] | PagamentoUncheckedCreateWithoutCobrancaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutCobrancaInput | PagamentoCreateOrConnectWithoutCobrancaInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutCobrancaInput | PagamentoUpsertWithWhereUniqueWithoutCobrancaInput[]
    createMany?: PagamentoCreateManyCobrancaInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutCobrancaInput | PagamentoUpdateWithWhereUniqueWithoutCobrancaInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutCobrancaInput | PagamentoUpdateManyWithWhereWithoutCobrancaInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type CobrancaCreateNestedOneWithoutPagamentosInput = {
    create?: XOR<CobrancaCreateWithoutPagamentosInput, CobrancaUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: CobrancaCreateOrConnectWithoutPagamentosInput
    connect?: CobrancaWhereUniqueInput
  }

  export type CobrancaUpdateOneRequiredWithoutPagamentosNestedInput = {
    create?: XOR<CobrancaCreateWithoutPagamentosInput, CobrancaUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: CobrancaCreateOrConnectWithoutPagamentosInput
    upsert?: CobrancaUpsertWithoutPagamentosInput
    connect?: CobrancaWhereUniqueInput
    update?: XOR<XOR<CobrancaUpdateToOneWithWhereWithoutPagamentosInput, CobrancaUpdateWithoutPagamentosInput>, CobrancaUncheckedUpdateWithoutPagamentosInput>
  }

  export type AreaComumCreateNestedOneWithoutReservasInput = {
    create?: XOR<AreaComumCreateWithoutReservasInput, AreaComumUncheckedCreateWithoutReservasInput>
    connectOrCreate?: AreaComumCreateOrConnectWithoutReservasInput
    connect?: AreaComumWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReservasInput = {
    create?: XOR<UserCreateWithoutReservasInput, UserUncheckedCreateWithoutReservasInput>
    connectOrCreate?: UserCreateOrConnectWithoutReservasInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCancelacoesInput = {
    create?: XOR<UserCreateWithoutCancelacoesInput, UserUncheckedCreateWithoutCancelacoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancelacoesInput
    connect?: UserWhereUniqueInput
  }

  export type AreaComumUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<AreaComumCreateWithoutReservasInput, AreaComumUncheckedCreateWithoutReservasInput>
    connectOrCreate?: AreaComumCreateOrConnectWithoutReservasInput
    upsert?: AreaComumUpsertWithoutReservasInput
    connect?: AreaComumWhereUniqueInput
    update?: XOR<XOR<AreaComumUpdateToOneWithWhereWithoutReservasInput, AreaComumUpdateWithoutReservasInput>, AreaComumUncheckedUpdateWithoutReservasInput>
  }

  export type UserUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<UserCreateWithoutReservasInput, UserUncheckedCreateWithoutReservasInput>
    connectOrCreate?: UserCreateOrConnectWithoutReservasInput
    upsert?: UserUpsertWithoutReservasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReservasInput, UserUpdateWithoutReservasInput>, UserUncheckedUpdateWithoutReservasInput>
  }

  export type UserUpdateOneWithoutCancelacoesNestedInput = {
    create?: XOR<UserCreateWithoutCancelacoesInput, UserUncheckedCreateWithoutCancelacoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancelacoesInput
    upsert?: UserUpsertWithoutCancelacoesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCancelacoesInput, UserUpdateWithoutCancelacoesInput>, UserUncheckedUpdateWithoutCancelacoesInput>
  }

  export type UserCreateNestedOneWithoutVisitanteRegistrosInput = {
    create?: XOR<UserCreateWithoutVisitanteRegistrosInput, UserUncheckedCreateWithoutVisitanteRegistrosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitanteRegistrosInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutVisitanteRegistrosNestedInput = {
    create?: XOR<UserCreateWithoutVisitanteRegistrosInput, UserUncheckedCreateWithoutVisitanteRegistrosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitanteRegistrosInput
    upsert?: UserUpsertWithoutVisitanteRegistrosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVisitanteRegistrosInput, UserUpdateWithoutVisitanteRegistrosInput>, UserUncheckedUpdateWithoutVisitanteRegistrosInput>
  }

  export type UserCreateNestedOneWithoutEntregasCriadasInput = {
    create?: XOR<UserCreateWithoutEntregasCriadasInput, UserUncheckedCreateWithoutEntregasCriadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEntregasCriadasInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEntregasRecebidasInput = {
    create?: XOR<UserCreateWithoutEntregasRecebidasInput, UserUncheckedCreateWithoutEntregasRecebidasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEntregasRecebidasInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<NotificationCreateWithoutDeliveryInput, NotificationUncheckedCreateWithoutDeliveryInput> | NotificationCreateWithoutDeliveryInput[] | NotificationUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveryInput | NotificationCreateOrConnectWithoutDeliveryInput[]
    createMany?: NotificationCreateManyDeliveryInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<NotificationCreateWithoutDeliveryInput, NotificationUncheckedCreateWithoutDeliveryInput> | NotificationCreateWithoutDeliveryInput[] | NotificationUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveryInput | NotificationCreateOrConnectWithoutDeliveryInput[]
    createMany?: NotificationCreateManyDeliveryInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutEntregasCriadasNestedInput = {
    create?: XOR<UserCreateWithoutEntregasCriadasInput, UserUncheckedCreateWithoutEntregasCriadasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEntregasCriadasInput
    upsert?: UserUpsertWithoutEntregasCriadasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEntregasCriadasInput, UserUpdateWithoutEntregasCriadasInput>, UserUncheckedUpdateWithoutEntregasCriadasInput>
  }

  export type UserUpdateOneWithoutEntregasRecebidasNestedInput = {
    create?: XOR<UserCreateWithoutEntregasRecebidasInput, UserUncheckedCreateWithoutEntregasRecebidasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEntregasRecebidasInput
    upsert?: UserUpsertWithoutEntregasRecebidasInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEntregasRecebidasInput, UserUpdateWithoutEntregasRecebidasInput>, UserUncheckedUpdateWithoutEntregasRecebidasInput>
  }

  export type NotificationUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<NotificationCreateWithoutDeliveryInput, NotificationUncheckedCreateWithoutDeliveryInput> | NotificationCreateWithoutDeliveryInput[] | NotificationUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveryInput | NotificationCreateOrConnectWithoutDeliveryInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDeliveryInput | NotificationUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: NotificationCreateManyDeliveryInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDeliveryInput | NotificationUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDeliveryInput | NotificationUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<NotificationCreateWithoutDeliveryInput, NotificationUncheckedCreateWithoutDeliveryInput> | NotificationCreateWithoutDeliveryInput[] | NotificationUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveryInput | NotificationCreateOrConnectWithoutDeliveryInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDeliveryInput | NotificationUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: NotificationCreateManyDeliveryInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDeliveryInput | NotificationUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDeliveryInput | NotificationUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPlantaoNotasInput = {
    create?: XOR<UserCreateWithoutPlantaoNotasInput, UserUncheckedCreateWithoutPlantaoNotasInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlantaoNotasInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlantaoNotasNestedInput = {
    create?: XOR<UserCreateWithoutPlantaoNotasInput, UserUncheckedCreateWithoutPlantaoNotasInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlantaoNotasInput
    upsert?: UserUpsertWithoutPlantaoNotasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlantaoNotasInput, UserUpdateWithoutPlantaoNotasInput>, UserUncheckedUpdateWithoutPlantaoNotasInput>
  }

  export type UserCreateNestedOneWithoutNotificacoesInput = {
    create?: XOR<UserCreateWithoutNotificacoesInput, UserUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificacoesInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryCreateNestedOneWithoutNotificacoesInput = {
    create?: XOR<DeliveryCreateWithoutNotificacoesInput, DeliveryUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutNotificacoesInput
    connect?: DeliveryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificacoesNestedInput = {
    create?: XOR<UserCreateWithoutNotificacoesInput, UserUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificacoesInput
    upsert?: UserUpsertWithoutNotificacoesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificacoesInput, UserUpdateWithoutNotificacoesInput>, UserUncheckedUpdateWithoutNotificacoesInput>
  }

  export type DeliveryUpdateOneWithoutNotificacoesNestedInput = {
    create?: XOR<DeliveryCreateWithoutNotificacoesInput, DeliveryUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutNotificacoesInput
    upsert?: DeliveryUpsertWithoutNotificacoesInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutNotificacoesInput, DeliveryUpdateWithoutNotificacoesInput>, DeliveryUncheckedUpdateWithoutNotificacoesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ReservaCreateWithoutMoradorInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    createdAt?: Date | string
    area: AreaComumCreateNestedOneWithoutReservasInput
    cancelledBy?: UserCreateNestedOneWithoutCancelacoesInput
  }

  export type ReservaUncheckedCreateWithoutMoradorInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    cancelledById?: string | null
    createdAt?: Date | string
    areaId: string
  }

  export type ReservaCreateOrConnectWithoutMoradorInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutMoradorInput, ReservaUncheckedCreateWithoutMoradorInput>
  }

  export type ReservaCreateManyMoradorInputEnvelope = {
    data: ReservaCreateManyMoradorInput | ReservaCreateManyMoradorInput[]
    skipDuplicates?: boolean
  }

  export type ReservaCreateWithoutCancelledByInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    createdAt?: Date | string
    area: AreaComumCreateNestedOneWithoutReservasInput
    morador: UserCreateNestedOneWithoutReservasInput
  }

  export type ReservaUncheckedCreateWithoutCancelledByInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    createdAt?: Date | string
    areaId: string
    moradorId: string
  }

  export type ReservaCreateOrConnectWithoutCancelledByInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutCancelledByInput, ReservaUncheckedCreateWithoutCancelledByInput>
  }

  export type ReservaCreateManyCancelledByInputEnvelope = {
    data: ReservaCreateManyCancelledByInput | ReservaCreateManyCancelledByInput[]
    skipDuplicates?: boolean
  }

  export type VisitorLogCreateWithoutCreatedByInput = {
    id?: string
    nome: string
    documento?: string | null
    apartamento?: string | null
    bloco?: string | null
    dataEntrada?: Date | string
    dataSaida?: Date | string | null
    createdAt?: Date | string
  }

  export type VisitorLogUncheckedCreateWithoutCreatedByInput = {
    id?: string
    nome: string
    documento?: string | null
    apartamento?: string | null
    bloco?: string | null
    dataEntrada?: Date | string
    dataSaida?: Date | string | null
    createdAt?: Date | string
  }

  export type VisitorLogCreateOrConnectWithoutCreatedByInput = {
    where: VisitorLogWhereUniqueInput
    create: XOR<VisitorLogCreateWithoutCreatedByInput, VisitorLogUncheckedCreateWithoutCreatedByInput>
  }

  export type VisitorLogCreateManyCreatedByInputEnvelope = {
    data: VisitorLogCreateManyCreatedByInput | VisitorLogCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutCreatedByInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    destinatario?: UserCreateNestedOneWithoutEntregasRecebidasInput
    notificacoes?: NotificationCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutCreatedByInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    destinatarioId?: string | null
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutCreatedByInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput>
  }

  export type DeliveryCreateManyCreatedByInputEnvelope = {
    data: DeliveryCreateManyCreatedByInput | DeliveryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutDestinatarioInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdBy: UserCreateNestedOneWithoutEntregasCriadasInput
    notificacoes?: NotificationCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutDestinatarioInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdById: string
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutDestinatarioInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutDestinatarioInput, DeliveryUncheckedCreateWithoutDestinatarioInput>
  }

  export type DeliveryCreateManyDestinatarioInputEnvelope = {
    data: DeliveryCreateManyDestinatarioInput | DeliveryCreateManyDestinatarioInput[]
    skipDuplicates?: boolean
  }

  export type ShiftNoteCreateWithoutCreatedByInput = {
    id?: string
    texto: string
    createdAt?: Date | string
  }

  export type ShiftNoteUncheckedCreateWithoutCreatedByInput = {
    id?: string
    texto: string
    createdAt?: Date | string
  }

  export type ShiftNoteCreateOrConnectWithoutCreatedByInput = {
    where: ShiftNoteWhereUniqueInput
    create: XOR<ShiftNoteCreateWithoutCreatedByInput, ShiftNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type ShiftNoteCreateManyCreatedByInputEnvelope = {
    data: ShiftNoteCreateManyCreatedByInput | ShiftNoteCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    delivery?: DeliveryCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    deliveryId?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UnidadeCreateWithoutMoradoresInput = {
    id?: string
    numero: string
    createdAt?: Date | string
    bloco: BlocoCreateNestedOneWithoutUnidadesInput
    cobrancas?: CobrancaCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeUncheckedCreateWithoutMoradoresInput = {
    id?: string
    numero: string
    blocoId: string
    createdAt?: Date | string
    cobrancas?: CobrancaUncheckedCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeCreateOrConnectWithoutMoradoresInput = {
    where: UnidadeWhereUniqueInput
    create: XOR<UnidadeCreateWithoutMoradoresInput, UnidadeUncheckedCreateWithoutMoradoresInput>
  }

  export type ReservaUpsertWithWhereUniqueWithoutMoradorInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutMoradorInput, ReservaUncheckedUpdateWithoutMoradorInput>
    create: XOR<ReservaCreateWithoutMoradorInput, ReservaUncheckedCreateWithoutMoradorInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutMoradorInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutMoradorInput, ReservaUncheckedUpdateWithoutMoradorInput>
  }

  export type ReservaUpdateManyWithWhereWithoutMoradorInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutMoradorInput>
  }

  export type ReservaScalarWhereInput = {
    AND?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
    OR?: ReservaScalarWhereInput[]
    NOT?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
    id?: StringFilter<"Reserva"> | string
    data?: DateTimeFilter<"Reserva"> | Date | string
    horarioInicio?: StringFilter<"Reserva"> | string
    horarioFim?: StringFilter<"Reserva"> | string
    status?: StringFilter<"Reserva"> | string
    cancelReason?: StringNullableFilter<"Reserva"> | string | null
    cancelledById?: StringNullableFilter<"Reserva"> | string | null
    createdAt?: DateTimeFilter<"Reserva"> | Date | string
    areaId?: StringFilter<"Reserva"> | string
    moradorId?: StringFilter<"Reserva"> | string
  }

  export type ReservaUpsertWithWhereUniqueWithoutCancelledByInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutCancelledByInput, ReservaUncheckedUpdateWithoutCancelledByInput>
    create: XOR<ReservaCreateWithoutCancelledByInput, ReservaUncheckedCreateWithoutCancelledByInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutCancelledByInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutCancelledByInput, ReservaUncheckedUpdateWithoutCancelledByInput>
  }

  export type ReservaUpdateManyWithWhereWithoutCancelledByInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutCancelledByInput>
  }

  export type VisitorLogUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: VisitorLogWhereUniqueInput
    update: XOR<VisitorLogUpdateWithoutCreatedByInput, VisitorLogUncheckedUpdateWithoutCreatedByInput>
    create: XOR<VisitorLogCreateWithoutCreatedByInput, VisitorLogUncheckedCreateWithoutCreatedByInput>
  }

  export type VisitorLogUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: VisitorLogWhereUniqueInput
    data: XOR<VisitorLogUpdateWithoutCreatedByInput, VisitorLogUncheckedUpdateWithoutCreatedByInput>
  }

  export type VisitorLogUpdateManyWithWhereWithoutCreatedByInput = {
    where: VisitorLogScalarWhereInput
    data: XOR<VisitorLogUpdateManyMutationInput, VisitorLogUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type VisitorLogScalarWhereInput = {
    AND?: VisitorLogScalarWhereInput | VisitorLogScalarWhereInput[]
    OR?: VisitorLogScalarWhereInput[]
    NOT?: VisitorLogScalarWhereInput | VisitorLogScalarWhereInput[]
    id?: StringFilter<"VisitorLog"> | string
    nome?: StringFilter<"VisitorLog"> | string
    documento?: StringNullableFilter<"VisitorLog"> | string | null
    apartamento?: StringNullableFilter<"VisitorLog"> | string | null
    bloco?: StringNullableFilter<"VisitorLog"> | string | null
    dataEntrada?: DateTimeFilter<"VisitorLog"> | Date | string
    dataSaida?: DateTimeNullableFilter<"VisitorLog"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitorLog"> | Date | string
    createdById?: StringFilter<"VisitorLog"> | string
  }

  export type DeliveryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutCreatedByInput, DeliveryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutCreatedByInput, DeliveryUncheckedUpdateWithoutCreatedByInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutCreatedByInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    OR?: DeliveryScalarWhereInput[]
    NOT?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    id?: StringFilter<"Delivery"> | string
    descricao?: StringFilter<"Delivery"> | string
    destinatarioEmail?: StringNullableFilter<"Delivery"> | string | null
    fotoUrl?: StringNullableFilter<"Delivery"> | string | null
    assinaturaUrl?: StringNullableFilter<"Delivery"> | string | null
    status?: StringFilter<"Delivery"> | string
    chegouEm?: DateTimeFilter<"Delivery"> | Date | string
    entregueEm?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    createdById?: StringFilter<"Delivery"> | string
    destinatarioId?: StringNullableFilter<"Delivery"> | string | null
  }

  export type DeliveryUpsertWithWhereUniqueWithoutDestinatarioInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutDestinatarioInput, DeliveryUncheckedUpdateWithoutDestinatarioInput>
    create: XOR<DeliveryCreateWithoutDestinatarioInput, DeliveryUncheckedCreateWithoutDestinatarioInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutDestinatarioInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutDestinatarioInput, DeliveryUncheckedUpdateWithoutDestinatarioInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutDestinatarioInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutDestinatarioInput>
  }

  export type ShiftNoteUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ShiftNoteWhereUniqueInput
    update: XOR<ShiftNoteUpdateWithoutCreatedByInput, ShiftNoteUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ShiftNoteCreateWithoutCreatedByInput, ShiftNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type ShiftNoteUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ShiftNoteWhereUniqueInput
    data: XOR<ShiftNoteUpdateWithoutCreatedByInput, ShiftNoteUncheckedUpdateWithoutCreatedByInput>
  }

  export type ShiftNoteUpdateManyWithWhereWithoutCreatedByInput = {
    where: ShiftNoteScalarWhereInput
    data: XOR<ShiftNoteUpdateManyMutationInput, ShiftNoteUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ShiftNoteScalarWhereInput = {
    AND?: ShiftNoteScalarWhereInput | ShiftNoteScalarWhereInput[]
    OR?: ShiftNoteScalarWhereInput[]
    NOT?: ShiftNoteScalarWhereInput | ShiftNoteScalarWhereInput[]
    id?: StringFilter<"ShiftNote"> | string
    texto?: StringFilter<"ShiftNote"> | string
    createdAt?: DateTimeFilter<"ShiftNote"> | Date | string
    createdById?: StringFilter<"ShiftNote"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    titulo?: StringFilter<"Notification"> | string
    mensagem?: StringFilter<"Notification"> | string
    imageUrl?: StringNullableFilter<"Notification"> | string | null
    lida?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    deliveryId?: StringNullableFilter<"Notification"> | string | null
  }

  export type UnidadeUpsertWithoutMoradoresInput = {
    update: XOR<UnidadeUpdateWithoutMoradoresInput, UnidadeUncheckedUpdateWithoutMoradoresInput>
    create: XOR<UnidadeCreateWithoutMoradoresInput, UnidadeUncheckedCreateWithoutMoradoresInput>
    where?: UnidadeWhereInput
  }

  export type UnidadeUpdateToOneWithWhereWithoutMoradoresInput = {
    where?: UnidadeWhereInput
    data: XOR<UnidadeUpdateWithoutMoradoresInput, UnidadeUncheckedUpdateWithoutMoradoresInput>
  }

  export type UnidadeUpdateWithoutMoradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloco?: BlocoUpdateOneRequiredWithoutUnidadesNestedInput
    cobrancas?: CobrancaUpdateManyWithoutUnidadeNestedInput
  }

  export type UnidadeUncheckedUpdateWithoutMoradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    blocoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cobrancas?: CobrancaUncheckedUpdateManyWithoutUnidadeNestedInput
  }

  export type ReservaCreateWithoutAreaInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    createdAt?: Date | string
    morador: UserCreateNestedOneWithoutReservasInput
    cancelledBy?: UserCreateNestedOneWithoutCancelacoesInput
  }

  export type ReservaUncheckedCreateWithoutAreaInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    cancelledById?: string | null
    createdAt?: Date | string
    moradorId: string
  }

  export type ReservaCreateOrConnectWithoutAreaInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutAreaInput, ReservaUncheckedCreateWithoutAreaInput>
  }

  export type ReservaCreateManyAreaInputEnvelope = {
    data: ReservaCreateManyAreaInput | ReservaCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ReservaUpsertWithWhereUniqueWithoutAreaInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutAreaInput, ReservaUncheckedUpdateWithoutAreaInput>
    create: XOR<ReservaCreateWithoutAreaInput, ReservaUncheckedCreateWithoutAreaInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutAreaInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutAreaInput, ReservaUncheckedUpdateWithoutAreaInput>
  }

  export type ReservaUpdateManyWithWhereWithoutAreaInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutAreaInput>
  }

  export type BlocoCreateWithoutCondominioInput = {
    id?: string
    nome: string
    unidades?: UnidadeCreateNestedManyWithoutBlocoInput
  }

  export type BlocoUncheckedCreateWithoutCondominioInput = {
    id?: string
    nome: string
    unidades?: UnidadeUncheckedCreateNestedManyWithoutBlocoInput
  }

  export type BlocoCreateOrConnectWithoutCondominioInput = {
    where: BlocoWhereUniqueInput
    create: XOR<BlocoCreateWithoutCondominioInput, BlocoUncheckedCreateWithoutCondominioInput>
  }

  export type BlocoCreateManyCondominioInputEnvelope = {
    data: BlocoCreateManyCondominioInput | BlocoCreateManyCondominioInput[]
    skipDuplicates?: boolean
  }

  export type ConfigReservaCreateWithoutCondominioInput = {
    id?: string
    limitePorMes?: number
    antecedenciaDias?: number
    horarioInicio?: string | null
    horarioFim?: string | null
  }

  export type ConfigReservaUncheckedCreateWithoutCondominioInput = {
    id?: string
    limitePorMes?: number
    antecedenciaDias?: number
    horarioInicio?: string | null
    horarioFim?: string | null
  }

  export type ConfigReservaCreateOrConnectWithoutCondominioInput = {
    where: ConfigReservaWhereUniqueInput
    create: XOR<ConfigReservaCreateWithoutCondominioInput, ConfigReservaUncheckedCreateWithoutCondominioInput>
  }

  export type BlocoUpsertWithWhereUniqueWithoutCondominioInput = {
    where: BlocoWhereUniqueInput
    update: XOR<BlocoUpdateWithoutCondominioInput, BlocoUncheckedUpdateWithoutCondominioInput>
    create: XOR<BlocoCreateWithoutCondominioInput, BlocoUncheckedCreateWithoutCondominioInput>
  }

  export type BlocoUpdateWithWhereUniqueWithoutCondominioInput = {
    where: BlocoWhereUniqueInput
    data: XOR<BlocoUpdateWithoutCondominioInput, BlocoUncheckedUpdateWithoutCondominioInput>
  }

  export type BlocoUpdateManyWithWhereWithoutCondominioInput = {
    where: BlocoScalarWhereInput
    data: XOR<BlocoUpdateManyMutationInput, BlocoUncheckedUpdateManyWithoutCondominioInput>
  }

  export type BlocoScalarWhereInput = {
    AND?: BlocoScalarWhereInput | BlocoScalarWhereInput[]
    OR?: BlocoScalarWhereInput[]
    NOT?: BlocoScalarWhereInput | BlocoScalarWhereInput[]
    id?: StringFilter<"Bloco"> | string
    nome?: StringFilter<"Bloco"> | string
    condominioId?: StringFilter<"Bloco"> | string
  }

  export type ConfigReservaUpsertWithoutCondominioInput = {
    update: XOR<ConfigReservaUpdateWithoutCondominioInput, ConfigReservaUncheckedUpdateWithoutCondominioInput>
    create: XOR<ConfigReservaCreateWithoutCondominioInput, ConfigReservaUncheckedCreateWithoutCondominioInput>
    where?: ConfigReservaWhereInput
  }

  export type ConfigReservaUpdateToOneWithWhereWithoutCondominioInput = {
    where?: ConfigReservaWhereInput
    data: XOR<ConfigReservaUpdateWithoutCondominioInput, ConfigReservaUncheckedUpdateWithoutCondominioInput>
  }

  export type ConfigReservaUpdateWithoutCondominioInput = {
    id?: StringFieldUpdateOperationsInput | string
    limitePorMes?: IntFieldUpdateOperationsInput | number
    antecedenciaDias?: IntFieldUpdateOperationsInput | number
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigReservaUncheckedUpdateWithoutCondominioInput = {
    id?: StringFieldUpdateOperationsInput | string
    limitePorMes?: IntFieldUpdateOperationsInput | number
    antecedenciaDias?: IntFieldUpdateOperationsInput | number
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CondominioCreateWithoutBlocosInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
    configuracoes?: ConfigReservaCreateNestedOneWithoutCondominioInput
  }

  export type CondominioUncheckedCreateWithoutBlocosInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
    configuracoes?: ConfigReservaUncheckedCreateNestedOneWithoutCondominioInput
  }

  export type CondominioCreateOrConnectWithoutBlocosInput = {
    where: CondominioWhereUniqueInput
    create: XOR<CondominioCreateWithoutBlocosInput, CondominioUncheckedCreateWithoutBlocosInput>
  }

  export type UnidadeCreateWithoutBlocoInput = {
    id?: string
    numero: string
    createdAt?: Date | string
    moradores?: UserCreateNestedManyWithoutUnidadeInput
    cobrancas?: CobrancaCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeUncheckedCreateWithoutBlocoInput = {
    id?: string
    numero: string
    createdAt?: Date | string
    moradores?: UserUncheckedCreateNestedManyWithoutUnidadeInput
    cobrancas?: CobrancaUncheckedCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeCreateOrConnectWithoutBlocoInput = {
    where: UnidadeWhereUniqueInput
    create: XOR<UnidadeCreateWithoutBlocoInput, UnidadeUncheckedCreateWithoutBlocoInput>
  }

  export type UnidadeCreateManyBlocoInputEnvelope = {
    data: UnidadeCreateManyBlocoInput | UnidadeCreateManyBlocoInput[]
    skipDuplicates?: boolean
  }

  export type CondominioUpsertWithoutBlocosInput = {
    update: XOR<CondominioUpdateWithoutBlocosInput, CondominioUncheckedUpdateWithoutBlocosInput>
    create: XOR<CondominioCreateWithoutBlocosInput, CondominioUncheckedCreateWithoutBlocosInput>
    where?: CondominioWhereInput
  }

  export type CondominioUpdateToOneWithWhereWithoutBlocosInput = {
    where?: CondominioWhereInput
    data: XOR<CondominioUpdateWithoutBlocosInput, CondominioUncheckedUpdateWithoutBlocosInput>
  }

  export type CondominioUpdateWithoutBlocosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuracoes?: ConfigReservaUpdateOneWithoutCondominioNestedInput
  }

  export type CondominioUncheckedUpdateWithoutBlocosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configuracoes?: ConfigReservaUncheckedUpdateOneWithoutCondominioNestedInput
  }

  export type UnidadeUpsertWithWhereUniqueWithoutBlocoInput = {
    where: UnidadeWhereUniqueInput
    update: XOR<UnidadeUpdateWithoutBlocoInput, UnidadeUncheckedUpdateWithoutBlocoInput>
    create: XOR<UnidadeCreateWithoutBlocoInput, UnidadeUncheckedCreateWithoutBlocoInput>
  }

  export type UnidadeUpdateWithWhereUniqueWithoutBlocoInput = {
    where: UnidadeWhereUniqueInput
    data: XOR<UnidadeUpdateWithoutBlocoInput, UnidadeUncheckedUpdateWithoutBlocoInput>
  }

  export type UnidadeUpdateManyWithWhereWithoutBlocoInput = {
    where: UnidadeScalarWhereInput
    data: XOR<UnidadeUpdateManyMutationInput, UnidadeUncheckedUpdateManyWithoutBlocoInput>
  }

  export type UnidadeScalarWhereInput = {
    AND?: UnidadeScalarWhereInput | UnidadeScalarWhereInput[]
    OR?: UnidadeScalarWhereInput[]
    NOT?: UnidadeScalarWhereInput | UnidadeScalarWhereInput[]
    id?: StringFilter<"Unidade"> | string
    numero?: StringFilter<"Unidade"> | string
    blocoId?: StringFilter<"Unidade"> | string
    createdAt?: DateTimeFilter<"Unidade"> | Date | string
  }

  export type BlocoCreateWithoutUnidadesInput = {
    id?: string
    nome: string
    condominio: CondominioCreateNestedOneWithoutBlocosInput
  }

  export type BlocoUncheckedCreateWithoutUnidadesInput = {
    id?: string
    nome: string
    condominioId: string
  }

  export type BlocoCreateOrConnectWithoutUnidadesInput = {
    where: BlocoWhereUniqueInput
    create: XOR<BlocoCreateWithoutUnidadesInput, BlocoUncheckedCreateWithoutUnidadesInput>
  }

  export type UserCreateWithoutUnidadeInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUnidadeInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUnidadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUnidadeInput, UserUncheckedCreateWithoutUnidadeInput>
  }

  export type UserCreateManyUnidadeInputEnvelope = {
    data: UserCreateManyUnidadeInput | UserCreateManyUnidadeInput[]
    skipDuplicates?: boolean
  }

  export type CobrancaCreateWithoutUnidadeInput = {
    id?: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
    pagamentos?: PagamentoCreateNestedManyWithoutCobrancaInput
  }

  export type CobrancaUncheckedCreateWithoutUnidadeInput = {
    id?: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutCobrancaInput
  }

  export type CobrancaCreateOrConnectWithoutUnidadeInput = {
    where: CobrancaWhereUniqueInput
    create: XOR<CobrancaCreateWithoutUnidadeInput, CobrancaUncheckedCreateWithoutUnidadeInput>
  }

  export type CobrancaCreateManyUnidadeInputEnvelope = {
    data: CobrancaCreateManyUnidadeInput | CobrancaCreateManyUnidadeInput[]
    skipDuplicates?: boolean
  }

  export type BlocoUpsertWithoutUnidadesInput = {
    update: XOR<BlocoUpdateWithoutUnidadesInput, BlocoUncheckedUpdateWithoutUnidadesInput>
    create: XOR<BlocoCreateWithoutUnidadesInput, BlocoUncheckedCreateWithoutUnidadesInput>
    where?: BlocoWhereInput
  }

  export type BlocoUpdateToOneWithWhereWithoutUnidadesInput = {
    where?: BlocoWhereInput
    data: XOR<BlocoUpdateWithoutUnidadesInput, BlocoUncheckedUpdateWithoutUnidadesInput>
  }

  export type BlocoUpdateWithoutUnidadesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    condominio?: CondominioUpdateOneRequiredWithoutBlocosNestedInput
  }

  export type BlocoUncheckedUpdateWithoutUnidadesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    condominioId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithWhereUniqueWithoutUnidadeInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUnidadeInput, UserUncheckedUpdateWithoutUnidadeInput>
    create: XOR<UserCreateWithoutUnidadeInput, UserUncheckedCreateWithoutUnidadeInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUnidadeInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUnidadeInput, UserUncheckedUpdateWithoutUnidadeInput>
  }

  export type UserUpdateManyWithWhereWithoutUnidadeInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUnidadeInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    senhaHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    apartamento?: StringNullableFilter<"User"> | string | null
    bloco?: StringNullableFilter<"User"> | string | null
    unidadeId?: StringNullableFilter<"User"> | string | null
    ativo?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type CobrancaUpsertWithWhereUniqueWithoutUnidadeInput = {
    where: CobrancaWhereUniqueInput
    update: XOR<CobrancaUpdateWithoutUnidadeInput, CobrancaUncheckedUpdateWithoutUnidadeInput>
    create: XOR<CobrancaCreateWithoutUnidadeInput, CobrancaUncheckedCreateWithoutUnidadeInput>
  }

  export type CobrancaUpdateWithWhereUniqueWithoutUnidadeInput = {
    where: CobrancaWhereUniqueInput
    data: XOR<CobrancaUpdateWithoutUnidadeInput, CobrancaUncheckedUpdateWithoutUnidadeInput>
  }

  export type CobrancaUpdateManyWithWhereWithoutUnidadeInput = {
    where: CobrancaScalarWhereInput
    data: XOR<CobrancaUpdateManyMutationInput, CobrancaUncheckedUpdateManyWithoutUnidadeInput>
  }

  export type CobrancaScalarWhereInput = {
    AND?: CobrancaScalarWhereInput | CobrancaScalarWhereInput[]
    OR?: CobrancaScalarWhereInput[]
    NOT?: CobrancaScalarWhereInput | CobrancaScalarWhereInput[]
    id?: StringFilter<"Cobranca"> | string
    unidadeId?: StringFilter<"Cobranca"> | string
    mesRef?: StringFilter<"Cobranca"> | string
    valor?: DecimalFilter<"Cobranca"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Cobranca"> | string
    vencimento?: DateTimeFilter<"Cobranca"> | Date | string
    boletoUrl?: StringNullableFilter<"Cobranca"> | string | null
    linhaDigitavel?: StringNullableFilter<"Cobranca"> | string | null
    createdAt?: DateTimeFilter<"Cobranca"> | Date | string
  }

  export type CondominioCreateWithoutConfiguracoesInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
    blocos?: BlocoCreateNestedManyWithoutCondominioInput
  }

  export type CondominioUncheckedCreateWithoutConfiguracoesInput = {
    id?: string
    nome: string
    cnpj?: string | null
    endereco?: string | null
    createdAt?: Date | string
    blocos?: BlocoUncheckedCreateNestedManyWithoutCondominioInput
  }

  export type CondominioCreateOrConnectWithoutConfiguracoesInput = {
    where: CondominioWhereUniqueInput
    create: XOR<CondominioCreateWithoutConfiguracoesInput, CondominioUncheckedCreateWithoutConfiguracoesInput>
  }

  export type CondominioUpsertWithoutConfiguracoesInput = {
    update: XOR<CondominioUpdateWithoutConfiguracoesInput, CondominioUncheckedUpdateWithoutConfiguracoesInput>
    create: XOR<CondominioCreateWithoutConfiguracoesInput, CondominioUncheckedCreateWithoutConfiguracoesInput>
    where?: CondominioWhereInput
  }

  export type CondominioUpdateToOneWithWhereWithoutConfiguracoesInput = {
    where?: CondominioWhereInput
    data: XOR<CondominioUpdateWithoutConfiguracoesInput, CondominioUncheckedUpdateWithoutConfiguracoesInput>
  }

  export type CondominioUpdateWithoutConfiguracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocos?: BlocoUpdateManyWithoutCondominioNestedInput
  }

  export type CondominioUncheckedUpdateWithoutConfiguracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocos?: BlocoUncheckedUpdateManyWithoutCondominioNestedInput
  }

  export type UnidadeCreateWithoutCobrancasInput = {
    id?: string
    numero: string
    createdAt?: Date | string
    bloco: BlocoCreateNestedOneWithoutUnidadesInput
    moradores?: UserCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeUncheckedCreateWithoutCobrancasInput = {
    id?: string
    numero: string
    blocoId: string
    createdAt?: Date | string
    moradores?: UserUncheckedCreateNestedManyWithoutUnidadeInput
  }

  export type UnidadeCreateOrConnectWithoutCobrancasInput = {
    where: UnidadeWhereUniqueInput
    create: XOR<UnidadeCreateWithoutCobrancasInput, UnidadeUncheckedCreateWithoutCobrancasInput>
  }

  export type PagamentoCreateWithoutCobrancaInput = {
    id?: string
    valor?: Decimal | DecimalJsLike | number | string
    pagoEm?: Date | string
    comprovanteUrl?: string | null
  }

  export type PagamentoUncheckedCreateWithoutCobrancaInput = {
    id?: string
    valor?: Decimal | DecimalJsLike | number | string
    pagoEm?: Date | string
    comprovanteUrl?: string | null
  }

  export type PagamentoCreateOrConnectWithoutCobrancaInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutCobrancaInput, PagamentoUncheckedCreateWithoutCobrancaInput>
  }

  export type PagamentoCreateManyCobrancaInputEnvelope = {
    data: PagamentoCreateManyCobrancaInput | PagamentoCreateManyCobrancaInput[]
    skipDuplicates?: boolean
  }

  export type UnidadeUpsertWithoutCobrancasInput = {
    update: XOR<UnidadeUpdateWithoutCobrancasInput, UnidadeUncheckedUpdateWithoutCobrancasInput>
    create: XOR<UnidadeCreateWithoutCobrancasInput, UnidadeUncheckedCreateWithoutCobrancasInput>
    where?: UnidadeWhereInput
  }

  export type UnidadeUpdateToOneWithWhereWithoutCobrancasInput = {
    where?: UnidadeWhereInput
    data: XOR<UnidadeUpdateWithoutCobrancasInput, UnidadeUncheckedUpdateWithoutCobrancasInput>
  }

  export type UnidadeUpdateWithoutCobrancasInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloco?: BlocoUpdateOneRequiredWithoutUnidadesNestedInput
    moradores?: UserUpdateManyWithoutUnidadeNestedInput
  }

  export type UnidadeUncheckedUpdateWithoutCobrancasInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    blocoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moradores?: UserUncheckedUpdateManyWithoutUnidadeNestedInput
  }

  export type PagamentoUpsertWithWhereUniqueWithoutCobrancaInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutCobrancaInput, PagamentoUncheckedUpdateWithoutCobrancaInput>
    create: XOR<PagamentoCreateWithoutCobrancaInput, PagamentoUncheckedCreateWithoutCobrancaInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutCobrancaInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutCobrancaInput, PagamentoUncheckedUpdateWithoutCobrancaInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutCobrancaInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutCobrancaInput>
  }

  export type PagamentoScalarWhereInput = {
    AND?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    OR?: PagamentoScalarWhereInput[]
    NOT?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    id?: StringFilter<"Pagamento"> | string
    cobrancaId?: StringFilter<"Pagamento"> | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFilter<"Pagamento"> | Date | string
    comprovanteUrl?: StringNullableFilter<"Pagamento"> | string | null
  }

  export type CobrancaCreateWithoutPagamentosInput = {
    id?: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
    unidade: UnidadeCreateNestedOneWithoutCobrancasInput
  }

  export type CobrancaUncheckedCreateWithoutPagamentosInput = {
    id?: string
    unidadeId: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
  }

  export type CobrancaCreateOrConnectWithoutPagamentosInput = {
    where: CobrancaWhereUniqueInput
    create: XOR<CobrancaCreateWithoutPagamentosInput, CobrancaUncheckedCreateWithoutPagamentosInput>
  }

  export type CobrancaUpsertWithoutPagamentosInput = {
    update: XOR<CobrancaUpdateWithoutPagamentosInput, CobrancaUncheckedUpdateWithoutPagamentosInput>
    create: XOR<CobrancaCreateWithoutPagamentosInput, CobrancaUncheckedCreateWithoutPagamentosInput>
    where?: CobrancaWhereInput
  }

  export type CobrancaUpdateToOneWithWhereWithoutPagamentosInput = {
    where?: CobrancaWhereInput
    data: XOR<CobrancaUpdateWithoutPagamentosInput, CobrancaUncheckedUpdateWithoutPagamentosInput>
  }

  export type CobrancaUpdateWithoutPagamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unidade?: UnidadeUpdateOneRequiredWithoutCobrancasNestedInput
  }

  export type CobrancaUncheckedUpdateWithoutPagamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    unidadeId?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaComumCreateWithoutReservasInput = {
    id?: string
    nome: string
    descricao?: string | null
    horarioInicio?: string | null
    horarioFim?: string | null
    createdAt?: Date | string
  }

  export type AreaComumUncheckedCreateWithoutReservasInput = {
    id?: string
    nome: string
    descricao?: string | null
    horarioInicio?: string | null
    horarioFim?: string | null
    createdAt?: Date | string
  }

  export type AreaComumCreateOrConnectWithoutReservasInput = {
    where: AreaComumWhereUniqueInput
    create: XOR<AreaComumCreateWithoutReservasInput, AreaComumUncheckedCreateWithoutReservasInput>
  }

  export type UserCreateWithoutReservasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutReservasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReservasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReservasInput, UserUncheckedCreateWithoutReservasInput>
  }

  export type UserCreateWithoutCancelacoesInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutCancelacoesInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCancelacoesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCancelacoesInput, UserUncheckedCreateWithoutCancelacoesInput>
  }

  export type AreaComumUpsertWithoutReservasInput = {
    update: XOR<AreaComumUpdateWithoutReservasInput, AreaComumUncheckedUpdateWithoutReservasInput>
    create: XOR<AreaComumCreateWithoutReservasInput, AreaComumUncheckedCreateWithoutReservasInput>
    where?: AreaComumWhereInput
  }

  export type AreaComumUpdateToOneWithWhereWithoutReservasInput = {
    where?: AreaComumWhereInput
    data: XOR<AreaComumUpdateWithoutReservasInput, AreaComumUncheckedUpdateWithoutReservasInput>
  }

  export type AreaComumUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaComumUncheckedUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    horarioInicio?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFim?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReservasInput = {
    update: XOR<UserUpdateWithoutReservasInput, UserUncheckedUpdateWithoutReservasInput>
    create: XOR<UserCreateWithoutReservasInput, UserUncheckedCreateWithoutReservasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReservasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReservasInput, UserUncheckedUpdateWithoutReservasInput>
  }

  export type UserUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCancelacoesInput = {
    update: XOR<UserUpdateWithoutCancelacoesInput, UserUncheckedUpdateWithoutCancelacoesInput>
    create: XOR<UserCreateWithoutCancelacoesInput, UserUncheckedCreateWithoutCancelacoesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCancelacoesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCancelacoesInput, UserUncheckedUpdateWithoutCancelacoesInput>
  }

  export type UserUpdateWithoutCancelacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutCancelacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVisitanteRegistrosInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutVisitanteRegistrosInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVisitanteRegistrosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisitanteRegistrosInput, UserUncheckedCreateWithoutVisitanteRegistrosInput>
  }

  export type UserUpsertWithoutVisitanteRegistrosInput = {
    update: XOR<UserUpdateWithoutVisitanteRegistrosInput, UserUncheckedUpdateWithoutVisitanteRegistrosInput>
    create: XOR<UserCreateWithoutVisitanteRegistrosInput, UserUncheckedCreateWithoutVisitanteRegistrosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVisitanteRegistrosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVisitanteRegistrosInput, UserUncheckedUpdateWithoutVisitanteRegistrosInput>
  }

  export type UserUpdateWithoutVisitanteRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutVisitanteRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEntregasCriadasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutEntregasCriadasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEntregasCriadasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEntregasCriadasInput, UserUncheckedCreateWithoutEntregasCriadasInput>
  }

  export type UserCreateWithoutEntregasRecebidasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutEntregasRecebidasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEntregasRecebidasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEntregasRecebidasInput, UserUncheckedCreateWithoutEntregasRecebidasInput>
  }

  export type NotificationCreateWithoutDeliveryInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificationUncheckedCreateWithoutDeliveryInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    userId: string
  }

  export type NotificationCreateOrConnectWithoutDeliveryInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDeliveryInput, NotificationUncheckedCreateWithoutDeliveryInput>
  }

  export type NotificationCreateManyDeliveryInputEnvelope = {
    data: NotificationCreateManyDeliveryInput | NotificationCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEntregasCriadasInput = {
    update: XOR<UserUpdateWithoutEntregasCriadasInput, UserUncheckedUpdateWithoutEntregasCriadasInput>
    create: XOR<UserCreateWithoutEntregasCriadasInput, UserUncheckedCreateWithoutEntregasCriadasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEntregasCriadasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEntregasCriadasInput, UserUncheckedUpdateWithoutEntregasCriadasInput>
  }

  export type UserUpdateWithoutEntregasCriadasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutEntregasCriadasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutEntregasRecebidasInput = {
    update: XOR<UserUpdateWithoutEntregasRecebidasInput, UserUncheckedUpdateWithoutEntregasRecebidasInput>
    create: XOR<UserCreateWithoutEntregasRecebidasInput, UserUncheckedCreateWithoutEntregasRecebidasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEntregasRecebidasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEntregasRecebidasInput, UserUncheckedUpdateWithoutEntregasRecebidasInput>
  }

  export type UserUpdateWithoutEntregasRecebidasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutEntregasRecebidasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutDeliveryInput, NotificationUncheckedUpdateWithoutDeliveryInput>
    create: XOR<NotificationCreateWithoutDeliveryInput, NotificationUncheckedCreateWithoutDeliveryInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutDeliveryInput, NotificationUncheckedUpdateWithoutDeliveryInput>
  }

  export type NotificationUpdateManyWithWhereWithoutDeliveryInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type UserCreateWithoutPlantaoNotasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    notificacoes?: NotificationCreateNestedManyWithoutUserInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutPlantaoNotasInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    notificacoes?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlantaoNotasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlantaoNotasInput, UserUncheckedCreateWithoutPlantaoNotasInput>
  }

  export type UserUpsertWithoutPlantaoNotasInput = {
    update: XOR<UserUpdateWithoutPlantaoNotasInput, UserUncheckedUpdateWithoutPlantaoNotasInput>
    create: XOR<UserCreateWithoutPlantaoNotasInput, UserUncheckedCreateWithoutPlantaoNotasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlantaoNotasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlantaoNotasInput, UserUncheckedUpdateWithoutPlantaoNotasInput>
  }

  export type UserUpdateWithoutPlantaoNotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutPlantaoNotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificacoesInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteCreateNestedManyWithoutCreatedByInput
    unidade?: UnidadeCreateNestedOneWithoutMoradoresInput
  }

  export type UserUncheckedCreateWithoutNotificacoesInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    unidadeId?: string | null
    ativo?: boolean
    createdAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMoradorInput
    cancelacoes?: ReservaUncheckedCreateNestedManyWithoutCancelledByInput
    visitanteRegistros?: VisitorLogUncheckedCreateNestedManyWithoutCreatedByInput
    entregasCriadas?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    entregasRecebidas?: DeliveryUncheckedCreateNestedManyWithoutDestinatarioInput
    plantaoNotas?: ShiftNoteUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificacoesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificacoesInput, UserUncheckedCreateWithoutNotificacoesInput>
  }

  export type DeliveryCreateWithoutNotificacoesInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdBy: UserCreateNestedOneWithoutEntregasCriadasInput
    destinatario?: UserCreateNestedOneWithoutEntregasRecebidasInput
  }

  export type DeliveryUncheckedCreateWithoutNotificacoesInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdById: string
    destinatarioId?: string | null
  }

  export type DeliveryCreateOrConnectWithoutNotificacoesInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutNotificacoesInput, DeliveryUncheckedCreateWithoutNotificacoesInput>
  }

  export type UserUpsertWithoutNotificacoesInput = {
    update: XOR<UserUpdateWithoutNotificacoesInput, UserUncheckedUpdateWithoutNotificacoesInput>
    create: XOR<UserCreateWithoutNotificacoesInput, UserUncheckedCreateWithoutNotificacoesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificacoesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificacoesInput, UserUncheckedUpdateWithoutNotificacoesInput>
  }

  export type UserUpdateWithoutNotificacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    unidade?: UnidadeUpdateOneWithoutMoradoresNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    unidadeId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type DeliveryUpsertWithoutNotificacoesInput = {
    update: XOR<DeliveryUpdateWithoutNotificacoesInput, DeliveryUncheckedUpdateWithoutNotificacoesInput>
    create: XOR<DeliveryCreateWithoutNotificacoesInput, DeliveryUncheckedCreateWithoutNotificacoesInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutNotificacoesInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutNotificacoesInput, DeliveryUncheckedUpdateWithoutNotificacoesInput>
  }

  export type DeliveryUpdateWithoutNotificacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutEntregasCriadasNestedInput
    destinatario?: UserUpdateOneWithoutEntregasRecebidasNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutNotificacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    destinatarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservaCreateManyMoradorInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    cancelledById?: string | null
    createdAt?: Date | string
    areaId: string
  }

  export type ReservaCreateManyCancelledByInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    createdAt?: Date | string
    areaId: string
    moradorId: string
  }

  export type VisitorLogCreateManyCreatedByInput = {
    id?: string
    nome: string
    documento?: string | null
    apartamento?: string | null
    bloco?: string | null
    dataEntrada?: Date | string
    dataSaida?: Date | string | null
    createdAt?: Date | string
  }

  export type DeliveryCreateManyCreatedByInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    destinatarioId?: string | null
  }

  export type DeliveryCreateManyDestinatarioInput = {
    id?: string
    descricao: string
    destinatarioEmail?: string | null
    fotoUrl?: string | null
    assinaturaUrl?: string | null
    status?: string
    chegouEm?: Date | string
    entregueEm?: Date | string | null
    createdById: string
  }

  export type ShiftNoteCreateManyCreatedByInput = {
    id?: string
    texto: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    deliveryId?: string | null
  }

  export type ReservaUpdateWithoutMoradorInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaComumUpdateOneRequiredWithoutReservasNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelacoesNestedInput
  }

  export type ReservaUncheckedUpdateWithoutMoradorInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservaUncheckedUpdateManyWithoutMoradorInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservaUpdateWithoutCancelledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaComumUpdateOneRequiredWithoutReservasNestedInput
    morador?: UserUpdateOneRequiredWithoutReservasNestedInput
  }

  export type ReservaUncheckedUpdateWithoutCancelledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: StringFieldUpdateOperationsInput | string
    moradorId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservaUncheckedUpdateManyWithoutCancelledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: StringFieldUpdateOperationsInput | string
    moradorId?: StringFieldUpdateOperationsInput | string
  }

  export type VisitorLogUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorLogUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorLogUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataSaida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinatario?: UserUpdateOneWithoutEntregasRecebidasNestedInput
    notificacoes?: NotificationUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinatarioId?: NullableStringFieldUpdateOperationsInput | string | null
    notificacoes?: NotificationUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinatarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryUpdateWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutEntregasCriadasNestedInput
    notificacoes?: NotificationUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    notificacoes?: NotificationUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    destinatarioEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assinaturaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chegouEm?: DateTimeFieldUpdateOperationsInput | Date | string
    entregueEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ShiftNoteUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftNoteUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftNoteUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    texto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: DeliveryUpdateOneWithoutNotificacoesNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservaCreateManyAreaInput = {
    id?: string
    data: Date | string
    horarioInicio: string
    horarioFim: string
    status?: string
    cancelReason?: string | null
    cancelledById?: string | null
    createdAt?: Date | string
    moradorId: string
  }

  export type ReservaUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    morador?: UserUpdateOneRequiredWithoutReservasNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelacoesNestedInput
  }

  export type ReservaUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moradorId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservaUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    horarioInicio?: StringFieldUpdateOperationsInput | string
    horarioFim?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moradorId?: StringFieldUpdateOperationsInput | string
  }

  export type BlocoCreateManyCondominioInput = {
    id?: string
    nome: string
  }

  export type BlocoUpdateWithoutCondominioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    unidades?: UnidadeUpdateManyWithoutBlocoNestedInput
  }

  export type BlocoUncheckedUpdateWithoutCondominioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    unidades?: UnidadeUncheckedUpdateManyWithoutBlocoNestedInput
  }

  export type BlocoUncheckedUpdateManyWithoutCondominioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadeCreateManyBlocoInput = {
    id?: string
    numero: string
    createdAt?: Date | string
  }

  export type UnidadeUpdateWithoutBlocoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moradores?: UserUpdateManyWithoutUnidadeNestedInput
    cobrancas?: CobrancaUpdateManyWithoutUnidadeNestedInput
  }

  export type UnidadeUncheckedUpdateWithoutBlocoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moradores?: UserUncheckedUpdateManyWithoutUnidadeNestedInput
    cobrancas?: CobrancaUncheckedUpdateManyWithoutUnidadeNestedInput
  }

  export type UnidadeUncheckedUpdateManyWithoutBlocoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyUnidadeInput = {
    id?: string
    nome: string
    email: string
    senhaHash: string
    role: $Enums.UserRole
    apartamento?: string | null
    bloco?: string | null
    ativo?: boolean
    createdAt?: Date | string
  }

  export type CobrancaCreateManyUnidadeInput = {
    id?: string
    mesRef: string
    valor?: Decimal | DecimalJsLike | number | string
    status?: string
    vencimento: Date | string
    boletoUrl?: string | null
    linhaDigitavel?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateWithoutUnidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUnidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMoradorNestedInput
    cancelacoes?: ReservaUncheckedUpdateManyWithoutCancelledByNestedInput
    visitanteRegistros?: VisitorLogUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasCriadas?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    entregasRecebidas?: DeliveryUncheckedUpdateManyWithoutDestinatarioNestedInput
    plantaoNotas?: ShiftNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notificacoes?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUnidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    apartamento?: NullableStringFieldUpdateOperationsInput | string | null
    bloco?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CobrancaUpdateWithoutUnidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamentos?: PagamentoUpdateManyWithoutCobrancaNestedInput
  }

  export type CobrancaUncheckedUpdateWithoutUnidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamentos?: PagamentoUncheckedUpdateManyWithoutCobrancaNestedInput
  }

  export type CobrancaUncheckedUpdateManyWithoutUnidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mesRef?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    vencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    boletoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linhaDigitavel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyCobrancaInput = {
    id?: string
    valor?: Decimal | DecimalJsLike | number | string
    pagoEm?: Date | string
    comprovanteUrl?: string | null
  }

  export type PagamentoUpdateWithoutCobrancaInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoUncheckedUpdateWithoutCobrancaInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoUncheckedUpdateManyWithoutCobrancaInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comprovanteUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyDeliveryInput = {
    id?: string
    titulo: string
    mensagem: string
    imageUrl?: string | null
    lida?: boolean
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificacoesNestedInput
  }

  export type NotificationUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lida?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaComumCountOutputTypeDefaultArgs instead
     */
    export type AreaComumCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaComumCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CondominioCountOutputTypeDefaultArgs instead
     */
    export type CondominioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CondominioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlocoCountOutputTypeDefaultArgs instead
     */
    export type BlocoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlocoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnidadeCountOutputTypeDefaultArgs instead
     */
    export type UnidadeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnidadeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CobrancaCountOutputTypeDefaultArgs instead
     */
    export type CobrancaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CobrancaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryCountOutputTypeDefaultArgs instead
     */
    export type DeliveryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaComumDefaultArgs instead
     */
    export type AreaComumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaComumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CondominioDefaultArgs instead
     */
    export type CondominioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CondominioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlocoDefaultArgs instead
     */
    export type BlocoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlocoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnidadeDefaultArgs instead
     */
    export type UnidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnidadeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigReservaDefaultArgs instead
     */
    export type ConfigReservaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigReservaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CobrancaDefaultArgs instead
     */
    export type CobrancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CobrancaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagamentoDefaultArgs instead
     */
    export type PagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogAuditoriaDefaultArgs instead
     */
    export type LogAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogAuditoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservaDefaultArgs instead
     */
    export type ReservaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitorLogDefaultArgs instead
     */
    export type VisitorLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitorLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryDefaultArgs instead
     */
    export type DeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftNoteDefaultArgs instead
     */
    export type ShiftNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AvisoDefaultArgs instead
     */
    export type AvisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AvisoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}